

  Listing 12.2




#include &lt;linux/fb.h&gt;
#include &lt;linux/dma-mapping.h&gt;
#include &lt;linux/platform_device.h&gt;

/* Address map of LCD controller registers */
#define LCD_CONTROLLER_BASE 0x01000D00
#define SIZE_REG     (*(volatile u32*)(LCD_CONTROLLER_BASE))
#define HSYNC_REG    (*(volatile u32*)(LCD_CONTROLLER_BASE + 4))
#define VSYNC_REG    (*(volatile u32*)(LCD_CONTROLLER_BASE + 8))
#define CONF_REG     (*(volatile u32*)(LCD_CONTROLLER_BASE + 12))
#define CTRL_REG     (*(volatile u32*)(LCD_CONTROLLER_BASE + 16))
#define DMA_REG      (*(volatile u32*)(LCD_CONTROLLER_BASE + 20))
#define STATUS_REG   (*(volatile u32 *)(LCD_CONTROLLER_BASE + 24))
#define CONTRAST_REG (*(volatile u32 *)(LCD_CONTROLLER_BASE + 28))
#define LCD_CONTROLLER_SIZE 32

/* Resources for the LCD controller platform device */
static struct resource myfb_resources[] = {
    [0] = {
        .start = LCD_CONTROLLER_BASE,
        .end = LCD_CONTROLLER_SIZE,
        .flags = IORESOURCE_MEM,
    },
};

/* Platform device definition */
static struct platform_device myfb_device = {
    .name = &quot;myfb&quot;,
    .id = 0,
    .dev = {
        .coherent_dma_mask = 0xffffffff,
    },
    .num_resources = ARRAY_SIZE(myfb_resources),
    .resource = myfb_resources,
};

/* Set LCD controller parameters */
static int
myfb_set_par(struct fb_info *info)
{
    unsigned long adjusted_fb_start;
    struct fb_var_screeninfo *var = &amp;info-&gt;var;
    struct fb_fix_screeninfo *fix = &amp;info-&gt;fix;

    /* Top 16 bits of HSYNC_REG hold HSYNC duration, next 8 contain
       the left margin, while the bottom 8 house the right margin */
    HSYNC_REG = (var-&gt;hsync_len &lt;&lt; 16) |
        (var-&gt;left_margin &lt;&lt; 8)|
        (var-&gt;right_margin);

    /* Top 16 bits of VSYNC_REG hold VSYNC duration, next 8 contain
       the upper margin, while the bottom 8 house the lower margin */
    VSYNC_REG = (var-&gt;vsync_len &lt;&lt; 16) |
        (var-&gt;upper_margin &lt;&lt; 8)|
        (var-&gt;lower_margin);

    /* Top 16 bits of SIZE_REG hold xres, bottom 16 hold yres */
    SIZE_REG = (var-&gt;xres &lt;&lt; 16) | (var-&gt;yres);

    /* Set bits per pixel, pixel polarity, clock dividers for
       the pixclock, and color/monochrome mode in CONF_REG */

    /* ... */

    /* Fill DMA_REG with the start address of the frame buffer
       coherently allocated from myfb_probe(). Adjust this address
       to account for any offset to the start of screen area */
    adjusted_fb_start = fix-&gt;smem_start +
        (var-&gt;yoffset * var-&gt;xres_virtual + var-&gt;xoffset) *
        (var-&gt;bits_per_pixel) / 8;
    __raw_writel(adjusted_fb_start, (unsigned long *)DMA_REG);

    /* Set the DMA burst length and watermark sizes in DMA_REG */
    /* ... */

    /* Set fixed information */
    fix-&gt;accel = FB_ACCEL_NONE; /* No hardware acceleration */
    fix-&gt;visual = FB_VISUAL_TRUECOLOR; /* True color mode */
    fix-&gt;line_length = var-&gt;xres_virtual * var-&gt;bits_per_pixel/8;

    return 0;
}

/* Enable LCD controller */
static void
myfb_enable_controller(struct fb_info *info)
{
    /* Enable LCD controller, start DMA, enable clocks and power
       by writing to CTRL_REG */
    /* ... */
}

/* Disable LCD controller */
static void
myfb_disable_controller(struct fb_info *info)
{
    /* Disable LCD controller, stop DMA, disable clocks and power
       by writing to CTRL_REG */
    /* ... */
}

/* Sanity check and adjustment of variables */
static int
myfb_check_var(struct fb_var_screeninfo *var, struct fb_info *info)
{
    /* Round up to the minimum resolution supported by
       the LCD controller */
    if (var-&gt;xres &lt; 64) var-&gt;xres = 64;
    if (var-&gt;yres &lt; 64) var-&gt;yres = 64;

    /* ... */

    /* This hardware supports the RGB565 color format.
       See the section &quot;Color Modes&quot; for more details */
    if (var-&gt;bits_per_pixel == 16) {
        /* Encoding Red */
        var-&gt;red.length = 5;
        var-&gt;red.offset = 11;
        /* Encoding Green */
        var-&gt;green.length = 6;
        var-&gt;green.offset = 5;
        /* Encoding Blue */
        var-&gt;blue.length = 5;
        var-&gt;blue.offset = 0;
        /* No hardware support for alpha blending */
        var-&gt;transp.length = 0;
        var-&gt;transp.offset = 0;
    }

    return 0;
}

/* Blank/unblank screen */
static int
myfb_blank(int blank_mode, struct fb_info *info)
{
    switch (blank_mode) {
    case FB_BLANK_POWERDOWN:
    case FB_BLANK_VSYNC_SUSPEND:
    case FB_BLANK_HSYNC_SUSPEND:
    case FB_BLANK_NORMAL:
        myfb_disable_controller(info);
        break;
    case FB_BLANK_UNBLANK:
        myfb_enable_controller(info);
        break;
    }
    return 0;
}

/* Configure pseudo color palette map */
static int
myfb_setcolreg(u_int color_index, u_int red, u_int green,
               u_int blue, u_int transp, struct fb_info *info)
{
    if (info-&gt;fix.visual == FB_VISUAL_TRUECOLOR) {
        /* Do any required translations to convert red, blue, green and
           transp, to values that can be directly fed to the hardware */
        /* ... */
        ((u32 *)(info-&gt;pseudo_palette))[color_index] =
            (red &lt;&lt; info-&gt;var.red.offset) |
            (green &lt;&lt; info-&gt;var.green.offset) |
            (blue &lt;&lt; info-&gt;var.blue.offset) |
            (transp &lt;&lt; info-&gt;var.transp.offset);
    }
    return 0;
}

/* Device-specific ioctl definition */
#define MYFB_SET_BRIGHTNESS _IOW('M', 3, int8_t)

/* Device-specific ioctl */
static int
myfb_ioctl(struct fb_info *info, unsigned int cmd,
           unsigned long arg)
{
    u32 blevel ;
    switch (cmd) {
    case MYFB_SET_BRIGHTNESS :
        copy_from_user((void *)&amp;blevel, (void *)arg,
                       sizeof(blevel)) ;
        /* Write blevel to CONTRAST_REG */
        /* ... */
        break;
    default:
        return -EINVAL;
    }
    return 0;
}

/* The fb_ops structure */
static struct fb_ops myfb_ops = {
    .owner = THIS_MODULE,
    .fb_check_var = myfb_check_var,/* Sanity check */
    .fb_set_par = myfb_set_par,    /* Program controller registers */
    .fb_setcolreg = myfb_setcolreg,/* Set color map */
    .fb_blank = myfb_blank,        /* Blank/unblank display */
    .fb_fillrect = cfb_fillrect,   /* Generic function to fill
                                      rectangle */
    .fb_copyarea = cfb_copyarea,   /* Generic function to copy area */
    .fb_imageblit = cfb_imageblit, /* Generic function to draw */
    .fb_ioctl = myfb_ioctl,        /* Device-specific ioctl */
};

/* Platform driver's probe() routine */
static int __init
myfb_probe(struct platform_device *pdev)
{
    struct fb_info *info;
    struct resource *res;
    info = framebuffer_alloc(0, &amp;pdev-&gt;dev);

    /* ... */

    /* Obtain the associated resource defined while registering the
       corresponding platform_device */
    res = platform_get_resource(pdev, IORESOURCE_MEM, 0);

    /* Get the kernel's sanction for using the I/O memory chunk
       starting from LCD_CONTROLLER_BASE and having a size of
       LCD_CONTROLLER_SIZE bytes */
    res = request_mem_region(res-&gt;start, res-&gt;end - res-&gt;start + 1,
                             pdev-&gt;name);

    /* Fill the fb_info structure with fixed (info-&gt;fix) and variable
       (info-&gt;var) values such as frame buffer length, xres, yres,
       bits_per_pixel, fbops, cmap, etc */
    initialize_fb_info(info, pdev); /* Not expanded */
    info-&gt;fbops = &amp;myfb_ops;
    fb_alloc_cmap(&amp;info-&gt;cmap, 16, 0);

    /* DMA-map the frame buffer memory coherently. info-&gt;screen_base
       holds the CPU address of the mapped buffer,
       info-&gt;fix.smem_start carries the associated hardware address */
    info-&gt;screen_base = dma_alloc_coherent(0, info-&gt;fix.smem_len,
                                           (dma_addr_t *)&amp;info-&gt;fix.smem_start,
                                           GFP_DMA | GFP_KERNEL);

    /* Set the information in info-&gt;var to the appropriate
       LCD controller registers */
    myfb_set_par(info);

    /* Register with the frame buffer core */
    register_framebuffer(info);

    return 0;
}

/* Platform driver's remove() routine */
static int
myfb_remove(struct platform_device *pdev)
{
    struct fb_info *info = platform_get_drvdata(pdev);
    struct resource *res;

    /* Disable screen refresh, turn off DMA,.. */
    myfb_disable_controller(info);

    /* Unregister frame buffer driver */
    unregister_framebuffer(info);

    /* Deallocate color map */
    fb_dealloc_cmap(&amp;info-&gt;cmap);
    kfree(info-&gt;pseudo_palette);

    /* Reverse of framebuffer_alloc() */
    framebuffer_release(info);

    /* Release memory region */
    res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
    release_mem_region(res-&gt;start, res-&gt;end - res-&gt;start + 1);
    platform_set_drvdata(pdev, NULL);

    return 0;
}

/* The platform driver structure */
static struct platform_driver myfb_driver = {
    .probe = myfb_probe,
    .remove = myfb_remove,
    .driver = {
        .name = &quot;myfb&quot;,
    },
};

/* Module Initialization */
int __init
myfb_init(void)
{
    platform_device_add(&amp;myfb_device);
    return platform_driver_register(&amp;myfb_driver);
}

/* Module Exit */
void __exit
myfb_exit(void)
{
    platform_driver_unregister(&amp;myfb_driver);
    platform_device_unregister(&amp;myfb_device);
}

module_init(myfb_init);
module_exit(myfb_exit);

 



syntax highlighted by Code2HTML, v. 0.9.1


lines: 0
