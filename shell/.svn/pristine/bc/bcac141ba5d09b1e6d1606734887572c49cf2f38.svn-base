

  Listing 5.6




#include &lt;linux/fs.h&gt;
#include &lt;linux/cdev.h&gt;
#include &lt;linux/parport.h&gt;
#include &lt;asm/uaccess.h&gt;
#include &lt;linux/platform_device.h&gt;

#define DEVICE_NAME &quot;led&quot;

static dev_t dev_number;        /* Allotted device number */
static struct class *led_class; /* Class to which this device
                                   belongs */
struct cdev led_cdev;           /* Associated cdev */
struct pardevice *pdev;         /* Parallel port device */

/* LED open */
int
led_open(struct inode *inode, struct file *file)
{
    return 0;
}

/* Write to the LED */
ssize_t
led_write(struct file *file, const char *buf,
          size_t count, loff_t *ppos)
{
    char kbuf;

    if (copy_from_user(&amp;kbuf, buf, 1)) return -EFAULT;

    /* Claim the port */
    parport_claim_or_block(pdev);

    /* Write to the device */
    parport_write_data(pdev-&gt;port, kbuf);

    /* Release the port */
    parport_release(pdev);
    return count;
}

/* Release the device */
int
led_release(struct inode *inode, struct file *file)
{
    return 0;
}

/* File Operations */
static struct file_operations led_fops = {
    .owner = THIS_MODULE,
    .open = led_open,
    .write = led_write,
    .release = led_release,
};

static int
led_preempt(void *handle)
{
    return 1;
}

/* Parport attach method */
static void
led_attach(struct parport *port)
{
    /* Register the parallel LED device with parport */
    pdev = parport_register_device(port, DEVICE_NAME,
                                   led_preempt, NULL,
                                   NULL, 0, NULL);
    if (pdev == NULL) printk(&quot;Bad register\n&quot;);
}

/* Parport detach method */
static void
led_detach(struct parport *port)
{
    /* Do nothing */
}

/* Parport driver operations */
static struct parport_driver led_driver = {
    .name = &quot;led&quot;,
    .attach = led_attach,
    .detach = led_detach,
};

/* Driver Initialization */
int __init
led_init(void)
{
    /* Request dynamic allocation of a device major number */
    if (alloc_chrdev_region(&amp;dev_number, 0, 1, DEVICE_NAME)
        &lt; 0) {
        printk(KERN_DEBUG &quot;Can't register device\n&quot;);
        return -1;
    }

    /* Create the led class */
    led_class = class_create(THIS_MODULE, DEVICE_NAME);
    if (IS_ERR(led_class)) printk(&quot;Bad class create\n&quot;);

    /* Connect the file operations with the cdev */
    cdev_init(&amp;led_cdev, &amp;led_fops);
    led_cdev.owner = THIS_MODULE;

    /* Connect the major/minor number to the cdev */
    if (cdev_add(&amp;led_cdev, dev_number, 1)) {
        printk(&quot;Bad cdev add\n&quot;);
        return 1;
    }
    class_device_create(led_class, NULL, dev_number,
                        NULL, DEVICE_NAME);

    /* Register this driver with parport */
    if (parport_register_driver(&amp;led_driver)) {
        printk(KERN_ERR &quot;Bad Parport Register\n&quot;);
        return -EIO;
    }

    printk(&quot;LED Driver Initialized.\n&quot;);
    return 0;
}

/* Driver Exit */
void __exit
led_cleanup(void)
{
    unregister_chrdev_region(dev_number, 1);
    class_device_destroy(led_class,dev_number);
    class_destroy(led_class);
    return;
}

module_init(led_init);
module_exit(led_cleanup);
MODULE_LICENSE(&quot;GPL&quot;);



syntax highlighted by Code2HTML, v. 0.9.1


lines: 0
