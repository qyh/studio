

  Listing 19.1




#include &lt;linux/rtc.h&gt;
#include &lt;sys/ioctl.h&gt;
#include &lt;sys/time.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;pthread.h&gt;
#include &lt;linux/mman.h&gt;

/* Read the lower half of the Pentium Time Stamp Counter
   using the rdtsc instruction */
#define rdtscl(val) __asm__ __volatile__ (&quot;rdtsc&quot; : &quot;=A&quot; (val))

int
main()
{
    unsigned long ts0, ts1, now, worst; /* Store TSC ticks */
    struct sched_param sched_p;         /* Information related to
                                           scheduling priority */
    int fd, i=0;
    unsigned long data;
    
    /* Change the scheduling policy to SCHED_FIFO */
    sched_getparam(getpid(), &amp;sched_p);
    sched_p.sched_priority = 50; /* RT Priority */
    sched_setscheduler(getpid(), SCHED_FIFO, &amp;sched_p);

    /* Avoid paging and related indeterminism */
    mlockall(MCL_CURRENT);

    /* Open the RTC */
    fd = open(&quot;/dev/rtc&quot;, O_RDONLY);

    /* Set the periodic interrupt frequency to 8192Hz
       This should give an interrupt rate of 122uS */
    ioctl(fd, RTC_IRQP_SET, 8192);

    /* Enable periodic interrupts */
    ioctl(fd, RTC_PIE_ON, 0);
    rdtscl(ts0);
    worst = 0;
    while (i++ &lt; 10000) {
        /* Block until the next periodic interrupt */
        read(fd, &amp;data, sizeof(unsigned long));
        /* Use the TSC to precisely measure the time consumed.
           Reading the lower half of the TSC is sufficient */
        rdtscl(ts1);
        now = (ts1-ts0);
        /* Update the worst case latency */
        if (now &gt; worst) worst = now;
        ts0 = ts1;
        /* Do work that is to be done periodically */
        do_work(); /* NOP for the purpose of this measurement */
    }

    printf(&quot;Worst latency was %8ld\n&quot;, worst);

    /* Disable periodic interrupts */
    ioctl(fd, RTC_PIE_OFF, 0);
}




syntax highlighted by Code2HTML, v. 0.9.1


lines: 0
