0.加法运算符重载

#include <iostream.h>

class bignum
{
private:
	unsigned int *bit;
public:
	bignum(int n)
	{
		bit=new unsigned int[n];for(int a=0;a<n;a++)bit[a]=0;
	}
	~bignum()
	{
		delete[] bit;
	}

void input();
//friend unsigned __int64 operator +(bignum &a,bignum &b);
friend bignum operator +(bignum &a,bignum &b);
};


void bignum::input()
{
	for(int a=0;;a++)
	{
		cin>>hex>>bit[a];
		if(bit[a]==0)break;
	}
}



bignum operator+ (bignum &a,bignum &b)
{
	bignum rt(10);
	unsigned __int64 c=0;
	for(int i=0;i<10;i++)
	{
	rt.bit[i]+=c>>32;
	c = unsigned __int64(a.bit[i])+b.bit[i];
	rt.bit[i]+=c;
	}
	//bignum rt(10);
	return rt;
}
void main()
{
	bignum a(10),b(10),c(10);
	a.input();b.input();
	//a=b;
	c=a+b;
}

1.创建文件夹
/*
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
#include <cstring>
#include <erron.h>
#include <cstdlib>
*/
if(mkdir(%%1,0777)==-1) {
//strerror(errno);
}

2.创建文件
/*
#include <sys/types.h>
#include <sys/stat.h>
#include <fcnt1.h>
*/
if(creat(%%1,mode&~umask))
{
%%2
}
//#include <sys/stat.h>
//int umask(int newmask);

3.删除文件
//#include <unistd.h>
if(unlink(%%1))
{
%%2
}
/*
//#include <stdio.h>
if(remove(%%1))
{
%%2
}
*/

4.删除文件夹
/*
#include <direct.h>
#include <unistd.h>
*/
if(rmdir(%%1)==-1)
{
%%2
}

5.删除一个目录下所有的文件夹
/*
#include <stdio.h>
#include <unistd.h>
#include <direct.h>
#include <string.h>
#include <sys/stat.h>
#include <stdlib.h>
*/
char *dir=%%1
int depth=0;
DIR *dp;
struct direct *entry;
struct stat statbuf;
if((dp=opendir(dir))==NULL)
{
fprintf(stderr,"cannot open directory:%s\n",dir);
return;
}
chdir(dir);
while((entry=readdir(dp))!=NULL)
{
lstat(entry->d_name,&statbuf);
if(S_ISDIR(statbuf.st_mode))
{
if(strcmp(".",entry->d_name)==0 || strcmp("..",entry->d_name)==0)
continue;
else
rmdir(entry->d_name);
}
chdir("..");
closedir(dp);
}

6.清空文件夹
/*
#include <windows.h>
#include <string>
#include <deque>
using namespace std;
*/
	TCHAR path[MAX_PATH]=%%1;
	if(!RemoveDirectory(path))
	{
		deque<string>delfiles;
		deque<string>folderList;
		strcat(path,"\\*.*");
		delfiles.push_back(string(path));
		string filepath;
		string filename;
		while(delfiles.size()>0)
		{
			WIN32_FIND_DATA fd;
			string pathfile=delfiles.front();
			folderList.push_back(pathfile);
			HANDLE hFind=FindFirstFile(pathfile.c_str(),&fd);
			delfiles.pop_front();
			if(hFind!=INVALID_HANDLE_VALUE)
			{
				BOOL bWorking=TRUE;
				while(bWorking)
				{
					bWorking=FindNextFile(hFind,&fd);
					if((fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) && fd.cFileName[0] != '.')
					{
						filename=pathfile;
						basic_string<char>::iterator _It=filename.begin()+filename.find("\\*.*");
						filename.insert(_It++,'\\');
						filename.insert(_It-filename.begin(),fd.cFileName);
						WIN32_FIND_DATA fd2;
						HANDLE hFound=FindFirstFile(filename.c_str(),&fd2);
						if(hFound!=INVALID_HANDLE_VALUE)
						{
							BOOL aWorking=TRUE;
							while(aWorking)
							{
								aWorking=FindNextFile(hFound,&fd2); 
								filepath=filename;
								_It=filepath.begin()+filepath.find("\\*.*");
								filepath.insert(_It++,'\\');
								if((fd2.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) && fd2.cFileName[0] != '.')
								{
									filepath.insert(_It-filepath.begin(),fd2.cFileName);
									delfiles.push_back(filepath);
								}
								else if(!(fd2.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) && fd2.cFileName[0] != '.')
								{
									filepath.replace(_It,filepath.end(),fd2.cFileName);
									DeleteFile(filepath.c_str());
								}
							}
							FindClose(hFound);
						}
					}
					else if(!(fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) && fd.cFileName[0] != '.')
					{
						string pathname=pathfile;
						pathname.replace(pathname.find("*.*"),3,fd.cFileName);
						DeleteFile(pathname.c_str());
					}
				}
				FindClose(hFind);
			}
		}
		while(folderList.size()>0)
		{
			string folder=folderList.back();
			filepath=folder;
			folder.erase(folder.find("\\*.*"),folder.length());
			if(RemoveDirectory(folder.c_str()))
				folderList.pop_back();
			else
			{
				WIN32_FIND_DATA fdata;
				HANDLE hFind=FindFirstFile(filepath.c_str(),&fdata);
				if(hFind!=INVALID_HANDLE_VALUE)
				{
					BOOL bWorking=TRUE;
					while(bWorking)
					{
						bWorking=FindNextFile(hFind,&fdata);
						if((fdata.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) && fdata.cFileName[0] != '.')
						{
							basic_string<char>::iterator it=filepath.begin()+filepath.find("\\*.*");
							filepath.insert(it++,'\\');
							filepath.insert(it-filepath.begin(),fdata.cFileName);
							folderList.push_back(filepath);
						}
					}
				}
				FindClose(hFind);
			}
		}
if (CreateDirectory(%%1, (LPSECURITY_ATTRIBUTES)NULL))
{
%%2
}
else
    return GetLastError();
	}

7.读取文件
//#include <stdio.h>
	FILE* fd;
char buffer[10240];
	if(fd=fopen(%%1,"w"))
	{

int num;
if((num=fscanf(fd,"%s",buffer))!=EOF)

char %%2=buffer;
close(fd);
	}

============================================================
/*
#include <stdio.h>
#include <string.h>
#define MAX_LINE 1024
*/
char buf[MAX_LINE];
FILE *fp;
int len;
 if((fp = fopen(%%1, "r")) == NULL){
perror("fail to read");
exit(1);
}
 while(fgets(buf, MAX_LINE, fp) != NULL){
len = strlen(buf);
buf[len - 1] = '\0';
//printf("%s %d\n", buf, len - 1); /* 使用printf函数输出 */
}
============================================================
#define setprogname(s)
#ifndef __COPYRIGHT
#define __COPYRIGHT(arg)
#endif
#ifndef __RCSID
#define __RCSID(arg)
#endif

#if HAVE_NBTOOL_CONFIG_H
#include "nbtool_config.h"
#endif

#ifndef __KLIBC__
#include <sys/cdefs.h>
#endif
#if !defined(lint)
__COPYRIGHT("@(#) Copyright (c) 1989, 1993\n\
        The Regents of the University of California.  All rights reserved.\n");
#if 0
static char sccsid[] = "@(#)cat.c       8.2 (Berkeley) 4/27/95";
#else
__RCSID("$NetBSD: cat.c,v 1.43 2004/01/04 03:31:28 jschauma Exp $");
#endif
#endif                          /* not lint */

#include <sys/param.h>
#include <sys/stat.h>

#include <ctype.h>
#ifndef __KLIBC__
#include <err.h>
#endif
#include <errno.h>
#include <fcntl.h>
#ifndef __KLIBC__
#include <locale.h>
#endif
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

int bflag, eflag, fflag, lflag, nflag, sflag, tflag, vflag;
int rval;
const char *filename;

void cook_args(char *argv[]);
void cook_buf(FILE *);
void raw_args(char *argv[]);
void raw_cat(int);

void cook_args(char **argv)
{
        FILE *fp;

        fp = stdin;
        filename = "stdin";
        do {
                if (*argv) {
                        if (!strcmp(*argv, "-"))
                                fp = stdin;
                        else if ((fp = fopen(*argv,
                                             fflag ? "rf" : "r")) == NULL) {
                                perror("fopen");
                                rval = 1;
                                ++argv;
                                continue;
                        }
                        filename = *argv++;
                }
                cook_buf(fp);
                if (fp != stdin)
                        (void)fclose(fp);
        } while (*argv);
}

void cook_buf(FILE * fp)
{
        int ch, gobble, line, prev;
        int stdout_err = 0;

        line = gobble = 0;
        for (prev = '\n'; (ch = getc(fp)) != EOF; prev = ch) {
                if (prev == '\n') {
                        if (ch == '\n') {
                                if (sflag) {
                                        if (!gobble && putchar(ch) == EOF)
                                                break;
                                        gobble = 1;
                                        continue;
                                }
                                if (nflag) {
                                        if (!bflag) {
                                                if (fprintf(stdout,
                                                            "%6d\t",
                                                            ++line) < 0) {
                                                        stdout_err++;
                                                        break;
                                                }
                                        } else if (eflag) {
                                                if (fprintf(stdout,
                                                            "%6s\t", "") < 0) {
                                                        stdout_err++;
                                                        break;
                                                }
                                        }
                                }
                        } else if (nflag) {
                                if (fprintf(stdout, "%6d\t", ++line) < 0) {
                                        stdout_err++;
                                        break;
                                }
                        }
                }
                gobble = 0;
                if (ch == '\n') {
                        if (eflag)
                                if (putchar('$') == EOF)
                                        break;
                } else if (ch == '\t') {
                        if (tflag) {
                                if (putchar('^') == EOF || putchar('I') == EOF)
                                        break;
                                continue;
                        }
                } else if (vflag) {
                        if (!isascii(ch)) {
                                if (putchar('M') == EOF || putchar('-') == EOF)
                                        break;
                                ch = (ch) & 0x7f;
                        }
                        if (iscntrl(ch)) {
                                if (putchar('^') == EOF ||
                                    putchar(ch == '\177' ? '?' :
                                            ch | 0100) == EOF)
                                        break;
                                continue;
                        }
                }
                if (putchar(ch) == EOF)
                        break;
        }
        if (stdout_err) {
                perror(filename);
                rval = 1;
        }
}

void raw_args(char **argv)
{
        int fd;

        fd = fileno(stdin);
        filename = "stdin";
        do {
                if (*argv) {
                        if (!strcmp(*argv, "-"))
                                fd = fileno(stdin);
                        else if (fflag) {
                                struct stat st;
                                fd = open(*argv, O_RDONLY | O_NONBLOCK, 0);
                                if (fd < 0)
                                        goto skip;

                                if (fstat(fd, &st) == -1) {
                                        close(fd);
                                        goto skip;
                                }
                                if (!S_ISREG(st.st_mode)) {
                                        close(fd);
                                        errno = EINVAL;
                                        goto skipnomsg;
                                }
                        } else if ((fd = open(*argv, O_RDONLY, 0)) < 0) {
                              skip:
                                perror(*argv);
                              skipnomsg:
                                rval = 1;
                                ++argv;
                                continue;
                        }
                        filename = *argv++;
                }
                raw_cat(fd);
                if (fd != fileno(stdin))
                        (void)close(fd);
        } while (*argv);
}

void raw_cat(int rfd)
{
        static char *buf;
        static char fb_buf[BUFSIZ];
        static size_t bsize;

        struct stat sbuf;
        ssize_t nr, nw, off;
        int wfd;

        wfd = fileno(stdout);
        if (buf == NULL) {
                if (fstat(wfd, &sbuf) == 0) {
                        bsize = sbuf.st_blksize > BUFSIZ ?
                            sbuf.st_blksize : BUFSIZ;
                        buf = malloc(bsize);
                }
                if (buf == NULL) {
                        buf = fb_buf;
                        bsize = BUFSIZ;
                }
        }
        while ((nr = read(rfd, buf, bsize)) > 0)
                for (off = 0; nr; nr -= nw, off += nw)
                        if ((nw = write(wfd, buf + off, (size_t) nr)) < 0) {
                                perror("write");
                                exit(1);
                        }
        if (nr < 0) {
                fprintf(stderr, "%s: invalid length\n", filename);
                rval = 1;
        }
}

int main(int argc, char *argv[])
{
        int ch;
        struct flock stdout_lock;

#ifndef __KLIBC__
        setprogname(argv[0]);
        (void)setlocale(LC_ALL, "");
#endif

        while ((ch = getopt(argc, argv, "beflnstuv")) != -1)
                switch (ch) {
                case 'b':
                        bflag = nflag = 1;      /* -b implies -n */
                        break;
                case 'e':
                        eflag = vflag = 1;      /* -e implies -v */
                        break;
                case 'f':
                        fflag = 1;
                        break;
                case 'l':
                        lflag = 1;
                        break;
                case 'n':
                        nflag = 1;
                        break;
                case 's':
                        sflag = 1;
                        break;
                case 't':
                        tflag = vflag = 1;      /* -t implies -v */
                        break;
                case 'u':
#ifndef __KLIBC__
                        setbuf(stdout, NULL);
#endif
                        break;
                case 'v':
                        vflag = 1;
                        break;
                default:
                case '?':
                        (void)fprintf(stderr,
                                      "usage: cat [-beflnstuv] [-] [file ...]\n");
                        exit(1);
                        /* NOTREACHED */
                }
        argv += optind;

        if (lflag) {
                stdout_lock.l_len = 0;
                stdout_lock.l_start = 0;
                stdout_lock.l_type = F_WRLCK;
                stdout_lock.l_whence = SEEK_SET;
                if (fcntl(STDOUT_FILENO, F_SETLKW, &stdout_lock) == -1) {
                        perror("fcntl");
                        exit(1);
                }
        }

        if (bflag || eflag || nflag || sflag || tflag || vflag)
                cook_args(argv);
        else
                raw_args(argv);
        if (fclose(stdout)) {
                perror("fclose");
                exit(1);
        }
        exit(rval);
        /* NOTREACHED */
}


8.写入文件

//#include <stdio.h>
	FILE* fd;
	if(fd=fopen(%%1,"w"))
	{
		const char buf[]=%%2;
		if(fprintf(fd,buf))
		{
			%%3
		}
		close(fd);
	}

9.写入随机文件
//#include <sys/stat.h>
if(int fd=open(%%1,O_RDWR))
{
lseek(fd,1,SEEK_CUR); //SEEK_SET,SEEK_CUR,SEEK_END
write(fd,buf,sizeof(buf));
close(fd);
}

10.读取文件属性
//#include <sys/stat.h>
//int umask(int newmask);

11.写入属性
//#include <sys/stat.h>
//int umask(int newmask);

12.枚举一个目录下的所有文件夹
/*
#include <stdio.h>
#include <unistd.h>
#include <direct.h>
#include <string.h>
#include <sys/stat.h>
#include <stdlib.h>
*/
void printdir(char *dir,int depth)
{
DIR *dp;
struct direct *entry;
struct stat statbuf;
if((dp=opendir(dir))==NULL)
{
fprintf(stderr,"cannot open directory:%s\n",dir);
return;
}
chdir(dir);
while((entry=readdir(dp))!=NULL)
{
lstat(entry->d_name,&statbuf);
if(S_ISDIR(statbuf.st_mode))
{
if(strcmp(".",entry->d_name)==0 || strcmp("..",entry->d_name)==0)
continue;
printf("%*s%s/\n",depth," ",entry->d_name);
printdir(entry->d_name,depth+4);
else
printf("%*s%s\n",depth," ",entry->d_name);
}
chdir("..");
closedir(dp);
}
printdir(%%1); //"/home/neil"

13.复制文件
/*
#include <stdio.h>
#include <assert.h>
*/
FILE *fp1, *fp2; 
char buffer[1024];
assert((fp1 = fopen(%%1, "rb")) != NULL); //"D:\\NAS.rar"
assert((fp2 = fopen(%%2, "wb")) != NULL); //"D:\\1.rar"
while (!feof( fp1) )
{
    int nSize = fread(buffer, 1, 1024, fp1);
    fwrite(buffer, 1, nSize, fp2);    
}
fclose(fp1); 
fclose(fp2);
/*
读取文件
//#include <sys/stat.h>
if(int fd=open(%%1,O_RDONLY))
{
const char* buf=new char[2048];
if(read(fd,buf,sizeof(buf));
{
%%2
}
close(fd);
}
写入文件
//#include <sys/stat.h>
if(int fd=open(%%1,O_CREAT|O_WRONLY|O_TRUNC))
{
const char buf[]=%%2;
if(write(fd,buf,sizeof(buf)))
{
%%2
}
close(fd);
}

*/


14.复制一个目录下所有的文件夹到另一个目录下

15.移动文件夹

16.移动一个目录下所有的文件夹到另一个目录下

17.以一个文件夹的框架在另一个目录创建文件夹和空文件

18.复制文件

19.复制一个文件夹下所有的文件到另一个目录

20.提取扩展名
/*
#include <string>
using namespace std;
*/
string s(%%1);
size_t i=s.rfind('.',s.length());
char* %%2=NULL;
if(i!=string::npos)
%%2=s.substr(i+1,s.length()-i);

21.提取文件名
/*
#include <string>
using namespace std;
*/
string s(%%1);
char sep='/';
#ifdef _WIN32
sep='\\';
#endif
size_t i=s.rfind(sep,s.length());
char* %%2=NULL;
if(i!=string::npos)
%%2=s.substr(i+1,s.length()-i);

22.提取文件路径
/*
#include <string>
using namespace std;
*/
string s(%%1);
char sep='/';
#ifdef _WIN32
sep='\\';
#endif
size_t i=s.rfind(sep,s.length());
char* %%2=NULL;
if(i!=string::npos)
%%2=s.substr(0,i);

23.替换扩展名
/*
#include <string>
using namespace std;
*/
string s(%%1);
string newExt(%%2);
string::size_type i=s.rfind('.',s.length());
if(i!=string::npos)
{
s.replace(i+1,newExt.length(),newExt);
%%3
}

24.追加路径

25.移动文件

26.移动一个文件夹下所有文件到另一个目录

27.指定目录下搜索文件

28.打开对话框

29.文件分割

30.文件合并
/*
#include <iostream>
#include <fstream>
#include <cstdlib>
#include <cstdlib>
#include <cassert>
using namespace std;
*/
FILE * stream;
stream=fopen(%%3,"w");
const int BUFSIZE=1024;
char buf1[BUFSIZE],char buf2[BUFSIZE];
ifstream f1(%%1);
ifstream f2(%%2);
f1.getline(buf1,BUFSIZE);
f2.getline(buf2,BUFSIZE);
while(f1 && f2)
{
	if(strcmp(buf1,buf2)<=0)
	{
	fprintf(stream,buf1);
		f1.getline(buf1,BUFSIZE);
	}
	else
	{
	fprintf(stream,buf2);
		f2.getline(buf2,BUFSIZE);
	}
}
while(f1)
{
	fprintf(stream,buf1);
	f1.getline(buf1,BUFSIZE);
}
while(f2)
{
	fprintf(stream,buf2);
	f2.getline(buf2,BUFSIZE);
}
fclose(stream);
===============================================


31.文件简单加密


32.文件简单解密

33.读取ini文件属性
//ini文件操作类
//write by Khan 
//最开头的注释默认的 section为 "###"
//普通的注释和空行 key为"##"

//所以 大家不要让配置文件的key = "##"
支持的注释格式 "#注释"

//LIniFile.h
#ifndef __LINI_FILE_H__
#define __LINI_FILE_H__

#include <string>
#include <vector>
#include <stdio.h>
#include <utility> 

using namespace std;

class CLogFileException{
    string m_strError;

public:
    inline CLogFileException(string p_strError){ m_strError = m_strError; }
    inline string OnMessage(){ return this->m_strError; }
};

class LIniFile
{
public:
    LIniFile(const string p_strFileName);
    ~LIniFile(void);

public:
    string GetValue(const string p_strSection, const string p_strKey);
    int SetValue(const string p_strSection, const string p_strKey, const string p_strValue);
    void Print();

    int OpenIni(const string p_strFileName);
    int OpenIni();
    void CloseIni();
protected:

private:
    vector<pair<string, pair<string,string> > >   m_szStrItem;
    string m_strFileName;
    FILE*  m_fileHandle;



  string TrimL(string p_strValue);
  string TrimR(string p_strValue);
  string Trim(string p_strValue);
  void LIniFile::DeleteEnter(char *p_str, int size);
};

#endif //__LINI_FILE_H__


//LIniFile.cpp
#include "LIniFile.h"
#include <algorithm>


LIniFile::LIniFile(const string p_strFileName)
{
  this->m_strFileName = p_strFileName;
  this->m_fileHandle = NULL;
  //this->OpenIni(p_strFileName);
}

LIniFile::~LIniFile(void){
  //this->CloseIni();
}

int LIniFile::OpenIni(){
  return OpenIni(m_strFileName);
}

int  LIniFile::OpenIni(const string p_strFileName){
  this->m_fileHandle = fopen(p_strFileName.c_str(),"rt+");
  if (NULL == this->m_fileHandle) {
    return 0;
  }

  fseek(this->m_fileHandle, 0, SEEK_SET); //将文件指针指向文件开头 
  char cTemp[512];
  memset(cTemp, 0, sizeof(cTemp));

  vector<string> vecStrItem;
  int iLen = 0;

  while(NULL != fgets(cTemp, sizeof(cTemp), this->m_fileHandle)){
    DeleteEnter(cTemp, sizeof(cTemp));//去结尾回车符
    Trim(cTemp); //去前后空格
    string str = cTemp;
    vecStrItem.push_back(str);
  }

  this->CloseIni();
 
  pair<string, string> pKVItem;
  pair<string, pair<string, string> > pItem;
  string strSection = "";
  string strCurrentSection = "";

  for (unsigned int i = 0; i < vecStrItem.size(); i++) {
    string strLine = ((string)vecStrItem[i]);

    if( '[' == strLine[0] ){
      strSection = strLine;

      strSection = strSection.erase(0,1);
      if(']' == strSection[strSection.size() -1 ])
        strSection = strSection.erase(strSection.size() - 1 );
      if (strCurrentSection != strSection) 
        strCurrentSection = strSection;
      
  }else if( string::npos != strLine.find('=') ){
      if ("" != strCurrentSection ) {
        string strKey;
        string strValue;
        strKey = TrimR( strLine.substr(0, strLine.find('=')) );
        strValue = TrimL( strLine.substr(strLine.find('=') + 1, strLine.size() - strLine.find('=')  ) );
        pKVItem.first = strKey;
        pKVItem.second = strValue;
        pItem.first = strCurrentSection;
        pItem.second = pKVItem;
        m_szStrItem.push_back(pItem);
      }
  }else{
      if ("" != strCurrentSection ) {
          string strKey = "##";
          string strValue = TrimL( strLine );
          pKVItem.first = strKey;
          pKVItem.second = strValue;
          pItem.first = strCurrentSection;
          pItem.second = pKVItem;
          m_szStrItem.push_back(pItem);
    }else{
          string strKey = "##";
          string strValue = TrimL( strLine );
          pKVItem.first = strKey;
          pKVItem.second = strValue;
      pItem.first = "###";
          pItem.second = pKVItem;
          m_szStrItem.push_back(pItem);
    }
  }
  }

  return 1;
}

string LIniFile::GetValue(const string p_strSection, const string p_strKey){
  string strValue;
  for (unsigned i = 0; i< m_szStrItem.size(); i++) {
    if( p_strSection == (string) ( ((pair<string, pair<string, string> >)m_szStrItem[i]).first ) ){
      pair<string, string> pKVItem = ((pair<string, pair<string, string> >)m_szStrItem[i]).second;
      if ( p_strKey == (string)(pKVItem.first)) {
        strValue = (string)(pKVItem.second);
        break;
      }
    }
  }
  return strValue;
}


void LIniFile::Print(){
  string strValue;
  string strKey;
  string strSection;
  for (unsigned i = 0; i< m_szStrItem.size(); i++) {
    strSection = (string) ( ((pair<string, pair<string, string> >)m_szStrItem[i]).first );
    pair<string, string> pKVItem = ((pair<string, pair<string, string> >)m_szStrItem[i]).second;
    strKey = (string)(pKVItem.first);
    strValue = (string)(pKVItem.second);
  //if((strSection != "###") && (strKey != "##") )
    printf("[%s]:%s=%s\n", strSection.c_str(), strKey.c_str(), strValue.c_str());
  }
}


void LIniFile::CloseIni(){
  if(NULL != this->m_fileHandle){
    fclose(this->m_fileHandle);
    this->m_fileHandle = NULL;
  }
}


string LIniFile::TrimL(string p_strValue){
  int i = 0 ;
  if ((i=(int)(p_strValue.length())) < 1)
    return "";

  i = 0;
  while(isspace(p_strValue[i])){
    i++ ;
  }
  p_strValue.erase(0,i);

  return p_strValue;
}

string LIniFile::TrimR(string p_strValue){
  int i = 0;
  if ( (i = (int)(p_strValue.length()-1)) < 1 )
    return "";

  while( ( p_strValue[i] ) == ' ' ){
    i--;
  }
  p_strValue.erase(i + 1);
  return p_strValue;
}


string LIniFile::Trim(string p_strValue){
  return TrimL(TrimR(p_strValue));
}

int LIniFile::SetValue(const string p_strSection, const string p_strKey, const string p_strValue){
  pair<string, string> pKVItem;
  pair<string, pair<string, string> > pItem;

  pKVItem.first = p_strKey;
  pKVItem.second = p_strValue;
  pItem.first = p_strSection;
  pItem.second = pKVItem;

  int bFind = 0;

  for(int i = (int)(m_szStrItem.size())-1; i >= 0; i--){ //找到已有的section, 并在末尾添加
    string bb = m_szStrItem[i].second.first;
    if((m_szStrItem[i].first == p_strSection)  && (m_szStrItem[i].second.first != "##")/* && (m_szStrItem[i].second.second != "")*/){
      m_szStrItem.insert( m_szStrItem.begin()+ i+1, pItem );
      bFind = 1;
      break;
    }
  }

  if(bFind != 1) //如果是新增的section
    m_szStrItem.push_back(pItem);

  this->m_fileHandle = fopen(this->m_strFileName.c_str(),"wt+");
  //this->m_fileHandle = fopen("c:\\aaa.ini","wt+");
  if (NULL == this->m_fileHandle) {
    return 0;
  }

  string strCurSection = "";
  string strTmp = "";

  if((int)(m_szStrItem.size()) > 0){

    strCurSection = m_szStrItem[0].first;
    if(strCurSection != "###"){
      strTmp = "[" + strCurSection + "]" + "\n";
      fputs(strTmp.c_str(), this->m_fileHandle);
    }

    for(int i=0; i<(int)(m_szStrItem.size()); i++){
      if( strCurSection ==  m_szStrItem[i].first ){

        if((m_szStrItem[i].second.first == "##") && (m_szStrItem[i].second.second ==""))
          strTmp = "\n";
        else if((m_szStrItem[i].second.first == "##") && (m_szStrItem[i].second.second !=""))
          strTmp = m_szStrItem[i].second.second+ "\n";
        else
          strTmp = m_szStrItem[i].second.first + " = " + m_szStrItem[i].second.second+ "\n";

        fputs(strTmp.c_str(), this->m_fileHandle);
      }else{

        strCurSection = m_szStrItem[i].first;
        if(strCurSection != "###"){
          string strTmp = "[" + strCurSection + "]"+ "\n";
          fputs(strTmp.c_str(), this->m_fileHandle);
        }

        if((m_szStrItem[i].second.first == "##") && (m_szStrItem[i].second.second ==""))
          strTmp = "\n";
        else if((m_szStrItem[i].second.first == "##") && (m_szStrItem[i].second.second !=""))
          strTmp = m_szStrItem[i].second.second+ "\n";
        else
          strTmp = m_szStrItem[i].second.first + " = " + m_szStrItem[i].second.second+ "\n";

        fputs(strTmp.c_str(), this->m_fileHandle);
      }
    }
  }
  this->CloseIni();
  return 1;
}

void LIniFile::DeleteEnter(char *p_str, int size){
  int i_len = (int)(strlen(p_str));
  if(p_str[i_len-1] == 0x0d || p_str[i_len-1] == 0x0a) 
    p_str[i_len-1] = 0x00;

  i_len =  (int)(strlen(p_str));
  if(p_str[i_len-1] == 0x0d || p_str[i_len-1] == 0x0a) 
    p_str[i_len-1] = 0x00;
}

//#include "LIniFile.h"
    LIniFile ini("d:\\My Documents\\Visual Studio 2005\\Projects\\inifile\\cbm.ini");
    ini.OpenIni();
    ini.SetValue(%%1,%%2, %%3);
    ini.Print();
    ini.CloseIni();

34.合并一个文件下所有的文件
/*
#include <iostream>
#include <iostream.h>
#include <fstream>
#include <cstdlib>
#include <string>
#include <list>
#include <stdio.h>
using namespace std;
*/
const int BUFSIZE=1024;
struct FileInfo
{
	ifstream* f;
	char line[BUFSIZE];
	FileInfo(char* fname)
	{
		f=new ifstream(fname);
		f->getline(line,BUFSIZE);
	}
	~FileInfo()
	{
		f->close();
		delete f;
	}
};

string getNextLine(list<FileInfo*>& flist)
{
	char* next="\xff";
	list<FileInfo*>::iterator small;
	list<FileInfo*>::iterator p=flist.begin();
	while(p!=flist.end())
	{
		FileInfo* fp=*p;
		if(strcmp(next,fp->line)>0)
		{
			small=p;
			next=fp->line;
		}
		++p;
	}
	FileInfo* fp=*small;
	ifstream* f=fp->f;
	char* line=fp->line;
	string minLine(line);
	f->getline(line,BUFSIZE);
	if(f->eof())
	{
		delete fp;
		flist.erase(small);
	}
	return minLine;
}

int argc=%%1;
char* argv[]=%%2;
list<FileInfo*> flist;
for(int i=0;i<argc-1;i++)
flist.push_back(new FileInfo(argv[i+1]));
FILE* stream;
stream=fopen(%%3,"w");
while(flist.size()>0)
{
	fprintf(stream,getNextLine(flist).c_str());
}
fclose(stream);

35.写入ini文件属性
#include <STDIO.H>   
#include <STDLIB.H>   
#include <SYS types.h>   
#include <SYS stat.h>   
#include <TIME.H>   
#include <STRING.H>   
  
#define E_OK       1   
#define E_FAIL     -1   
#define FILE_SIZE_MAX 1000000   
#define   STR_LEN     128   
  
typedef struct {  
         char   year[5];  
         char   month[3];  
         char   day[3];  
         char   hour[3];  
         char   minute[3];  
         char   second[3];  
}CB_TIME;  
  
void  
Get_Time_Str( char _time_str[128]  )  
{  
    CB_TIME              cb_time;  
    char                 str_tmp[30];  
    time_t               itm;  
    struct tm            *stm;  
  
  
   memset( &cb_time,0x00, sizeof( CB_TIME ) );  
  
   itm = time( 0 );  
   stm = localtime( &itm );  
   strftime( cb_time.year,  5, "%Y", stm );  
   strftime( cb_time.month, 3, "%m", stm );  
   strftime( cb_time.day,   3, "%d", stm );  
   strftime( cb_time.hour,  3, "%H", stm );  
   strftime( cb_time.minute,3, "%M", stm );  
   strftime( cb_time.second,3, "%S", stm );  
  
  
   memset( str_tmp, '*', 29 ); str_tmp[29] = '\0';  
   sprintf( _time_str, "%s %s/%s/%s %s:%s:%s %s\n", \  
            str_tmp, cb_time.year, cb_time.month, cb_time.day, \  
            cb_time.hour, cb_time.minute, cb_time.second, str_tmp );  
  
  
}  
  
  
void  
GetTime( char _time_str[128]  )  
{  
    CB_TIME              cb_time;  
    char                 str_tmp[30];  
    time_t               itm;  
    struct tm            *stm;  
  
  
   memset( &cb_time,0x00, sizeof( CB_TIME ) );  
  
   itm = time( 0 );  
   stm = localtime( &itm );  
   strftime( cb_time.year,  5, "%Y", stm );  
   strftime( cb_time.month, 3, "%m", stm );  
   strftime( cb_time.day,   3, "%d", stm );  
   strftime( cb_time.hour,  3, "%H", stm );  
   strftime( cb_time.minute,3, "%M", stm );  
   strftime( cb_time.second,3, "%S", stm );  
  
   sprintf( _time_str, "%s%s%s%s%s%s", cb_time.year, cb_time.month, cb_time.day ,  \  
                                       cb_time.hour, cb_time.minute,cb_time.second );  
  
}  
  
void  
GetYMD( char _time_str[128]  )  
{  
    CB_TIME              cb_time;  
    char                 str_tmp[30];  
    time_t               itm;  
    struct tm            *stm;  
  
  
   memset( &cb_time,0x00, sizeof( CB_TIME ) );  
  
   itm = time( 0 );  
   stm = localtime( &itm );  
   strftime( cb_time.year,  5, "%Y", stm );  
   strftime( cb_time.month, 3, "%m", stm );  
   strftime( cb_time.day,   3, "%d", stm );  
   strftime( cb_time.hour,  3, "%H", stm );  
   strftime( cb_time.minute,3, "%M", stm );  
   strftime( cb_time.second,3, "%S", stm );  
  
   sprintf( _time_str, "%s-%s-%s", cb_time.year, cb_time.month, cb_time.day  );  
  
}  
  
  
  
void  
Get_minu( char _time_str[128]  )  
{  
    CB_TIME              cb_time;  
    char                 str_tmp[30];  
    time_t               itm;  
    struct tm            *stm;  
  
  
   memset( &cb_time,0x00, sizeof( CB_TIME ) );  
  
   itm = time( 0 );  
   stm = localtime( &itm );  
   strftime( cb_time.year,  5, "%Y", stm );  
   strftime( cb_time.month, 3, "%m", stm );  
   strftime( cb_time.day,   3, "%d", stm );  
   strftime( cb_time.hour,  3, "%H", stm );  
   strftime( cb_time.minute,3, "%M", stm );  
   strftime( cb_time.second,3, "%S", stm );  
  
   sprintf( _time_str, "%s", cb_time.minute  );  
  
}  
  
  
  
void  
Get_hour( char _time_str[128]  )  
{  
    CB_TIME              cb_time;  
    char                 str_tmp[30];  
    time_t               itm;  
    struct tm            *stm;  
  
  
   memset( &cb_time,0x00, sizeof( CB_TIME ) );  
  
   itm = time( 0 );  
   stm = localtime( &itm );  
   strftime( cb_time.year,  5, "%Y", stm );  
   strftime( cb_time.month, 3, "%m", stm );  
   strftime( cb_time.day,   3, "%d", stm );  
   strftime( cb_time.hour,  3, "%H", stm );  
   strftime( cb_time.minute,3, "%M", stm );  
   strftime( cb_time.second,3, "%S", stm );  
  
   sprintf( _time_str, "%s", cb_time.hour  );  
  
}  
  
  
  
int  
Errlog ( char *_file, int _line, char *Err_msg )  
{  
     FILE          *Err_File;  
     long          File_Size;  
     struct stat   file_stat;  
     char          str_time[128];       
     char          yyyymmdd[32];       
     char          FILE_NAME[ 128 ];  
  
  
     memset( FILE_NAME,0x00,128 );  
     memset( yyyymmdd,0x00,32 );  
     GetYMD( yyyymmdd );  
  
     sprintf( FILE_NAME,"%s/log/Recv_Data_%s.log",getenv("HOME"),yyyymmdd );  
  
     if(( Err_File = fopen( FILE_NAME, "a+" ) ) == NULL )   
          return E_FAIL;  
  
     if( stat( FILE_NAME,&file_stat ) == -1 )   
         return E_FAIL ;  
  
     File_Size = file_stat.st_size ;  
     if( File_Size > FILE_SIZE_MAX )  
         truncate( _file,0 );  
  
     Get_Time_Str( str_time );  
     fprintf( Err_File,"%s\n", str_time );  
  
     fprintf( Err_File,"\nLogmsg :   [%s]\n",Err_msg );   
       
     fclose( Err_File ) ;      
     return E_OK;  
}  
  
  
int  
Getted_Log ( char *_file, int _line, char *Err_msg )  
{  
     FILE          *Err_File;  
     long          File_Size;  
     struct stat   file_stat;  
     char          str_time[128];       
     char          yyyymmdd[32];       
     char          FILE_NAME[ 128 ];  
  
  
     memset( FILE_NAME,0x00,128 );  
     memset( yyyymmdd,0x00,32 );  
     GetYMD( yyyymmdd );  
  
     sprintf( FILE_NAME,"%s/log/Getted_File_%s.log",getenv("HOME"),yyyymmdd );  
  
     if(( Err_File = fopen( FILE_NAME, "a+" ) ) == NULL )   
          return E_FAIL;  
  
     if( stat( FILE_NAME,&file_stat ) == -1 )   
         return E_FAIL ;  
  
     File_Size = file_stat.st_size ;  
     if( File_Size > FILE_SIZE_MAX )  
         truncate( _file,0 );  
  
    /*** 
     Get_Time_Str( str_time ); 
     fprintf( Err_File,"%s\n", str_time ); 
 
    ***/  
     fprintf( Err_File,"[%s]\n",Err_msg );   
       
     fclose( Err_File ) ;      
     return E_OK;  
}  
  
  
  
int  
read_config( char *filename, char *section_name,char *val_name,char *str_ret ) {  
   FILE        *fp;  
   char        str_buf[STR_LEN],str_tmp[ STR_LEN ];  
   int         i,find_sec = 0 ;  
   char        conf_sec_name[50],conf_val_name[50];   
   char        *p = NULL,*p_sec = NULL;  
    
   if(( fp = fopen( filename,"r" ) ) == NULL ) {  
        Errlog( __FILE__,__LINE__,"fopen in read_config " ) ;  
        return   E_FAIL;  
   }  
     
   memset( str_buf ,0x00,STR_LEN  ) ;  
   memset( str_tmp ,0x00,STR_LEN  ) ;  
  
   while( 1 ) {  
         
       memset( conf_sec_name,0x00,50+1 );  
       memset( conf_val_name,0x00,50+1 );     
  
       if( fgets( str_buf,STR_LEN,fp ) == NULL ) {  
            Errlog( __FILE__,__LINE__,"fgets in read config " ) ;  
            Errlog( __FILE__,__LINE__,str_buf ) ;  
            break ;  
       }  
   
       if( str_buf[0] =='[' ) {  
             if(( p_sec = strchr( str_buf, ']' )) == NULL ) {  
                   Errlog( __FILE__,__LINE__, "strchr in read conf" );            
                   break;  
             }  
     
             strncpy( conf_sec_name,&str_buf[1] ,p_sec - &str_buf[1] );  
  
             if( strcmp(  conf_sec_name,section_name ) == 0 )  
                  find_sec = 1 ;  
       }   
  
        if( find_sec != 1 )   
              continue ;  
              
        if( fgets( str_tmp, STR_LEN, fp ) == NULL ) {  
              Errlog( __FILE__,__LINE__," fgets in second in read conf" );  
              break;  
         }  
                  
         for( i = 0 ; i < STR_LEN ; i++ )   
             if( str_tmp[i] =='\n' || str_tmp[i] =='\r' )  
                    str_tmp[i] = '\0' ;          
  
          while( str_tmp[0] !='[' ) {  
                if(( p = strchr( str_tmp,'=' )) == NULL )  {  
                     break;  
                 }  
                 strncpy( conf_val_name,&str_tmp[0] ,p - &str_tmp[0] );  
  
                 if( strcmp( conf_val_name,val_name ) == 0 ) {  
                      p = p + 1;  
                      strcpy( str_ret, p ) ;   
                      return E_OK ;  
                  }  
             
                 memset( str_tmp, 0x00, STR_LEN ) ;  
                     
                 if( fgets( str_tmp, STR_LEN, fp ) == NULL ) {  
                   Errlog( __FILE__,__LINE__," fgets in second in read conf" );  
                   break;  
                 }  
                  
              for( i = 0 ; i < STR_LEN ; i++ )   
                 if( str_tmp[i] =='\n' || str_tmp[i] =='\r' )  
                      str_tmp[i] = '\0' ;          
        } //while   
     } //while    
  
     if( find_sec == 0 )   
           return   E_FAIL;  
     return  E_OK ;  
}  
  
int daemon_init( void ) {  
    pid_t    pid ;  
      
    if( ( pid = fork( ) ) < 0 )  
         return  E_FAIL ;  
    else if( pid != 0 )      /* in parent  */  
         exit( 0 ) ;  
      
    /* in  child process */  
    setsid( ) ;  
    chdir( "/" ) ;  
    umask( 0 ) ;  
    return E_OK ;  
}  

36.获得当前路径
/*
#include <stdio.h> 
#include <stdlib.h> 
#include <unistd.h>
#include <string>
#define MAXBUFSIZE 1024 
using namespace std;
*/
char buf[ MAXBUFSIZE ]; 
int count= readlink( "/proc/self/exe", buf, MAXBUFSIZE ); 
if ( count < 0 || count >= MAXBUFSIZE ) 
{ 
//获取失败
return( EXIT_FAILURE ); 
}
buf[ count ] = '\0'; 
string curdir(buf);

XML相关
/*
www.sourceforge.net/projects/tinyxml
Original file by Yves Berquin.

This software is provided 'as-is', without any express or implied
warranty. In no event will the authors be held liable for any
damages arising from the use of this software.

Permission is granted to anyone to use this software for any
purpose, including commercial applications, and to alter it and
redistribute it freely, subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must
not claim that you wrote the original software. If you use this
software in a product, an acknowledgment in the product documentation
would be appreciated but is not required.

2. Altered source versions must be plainly marked as such, and
must not be misrepresented as being the original software.

3. This notice may not be removed or altered from any source
distribution.
*/

/*
 * THIS FILE WAS ALTERED BY Tyge Lovset, 7. April 2005.
 *
 * - completely rewritten. compact, clean, and fast implementation.
 * - sizeof(TiXmlString) = pointer size (4 bytes on 32-bit systems)
 * - fixed reserve() to work as per specification.
 * - fixed buggy compares operator==(), operator<(), and operator>()
 * - fixed operator+=() to take a const ref argument, following spec.
 * - added "copy" constructor with length, and most compare operators.
 * - added swap(), clear(), size(), capacity(), operator+().
 */

#ifndef TIXML_USE_STL

#ifndef TIXML_STRING_INCLUDED
#define TIXML_STRING_INCLUDED

#include <assert.h>
#include <string.h>

/*	The support for explicit isn't that universal, and it isn't really
	required - it is used to check that the TiXmlString class isn't incorrectly
	used. Be nice to old compilers and macro it here:
*/
#if defined(_MSC_VER) && (_MSC_VER >= 1200 )
	// Microsoft visual studio, version 6 and higher.
	#define TIXML_EXPLICIT explicit
#elif defined(__GNUC__) && (__GNUC__ >= 3 )
	// GCC version 3 and higher.s
	#define TIXML_EXPLICIT explicit
#else
	#define TIXML_EXPLICIT
#endif


/*
   TiXmlString is an emulation of a subset of the std::string template.
   Its purpose is to allow compiling TinyXML on compilers with no or poor STL support.
   Only the member functions relevant to the TinyXML project have been implemented.
   The buffer allocation is made by a simplistic power of 2 like mechanism : if we increase
   a string and there's no more room, we allocate a buffer twice as big as we need.
*/
class TiXmlString
{
  public :
	// The size type used
  	typedef size_t size_type;

	// Error value for find primitive
	static const size_type npos; // = -1;


	// TiXmlString empty constructor
	TiXmlString () : rep_(&nullrep_)
	{
	}

	// TiXmlString copy constructor
	TiXmlString ( const TiXmlString & copy) : rep_(0)
	{
		init(copy.length());
		memcpy(start(), copy.data(), length());
	}

	// TiXmlString constructor, based on a string
	TIXML_EXPLICIT TiXmlString ( const char * copy) : rep_(0)
	{
		init( static_cast<size_type>( strlen(copy) ));
		memcpy(start(), copy, length());
	}

	// TiXmlString constructor, based on a string
	TIXML_EXPLICIT TiXmlString ( const char * str, size_type len) : rep_(0)
	{
		init(len);
		memcpy(start(), str, len);
	}

	// TiXmlString destructor
	~TiXmlString ()
	{
		quit();
	}

	// = operator
	TiXmlString& operator = (const char * copy)
	{
		return assign( copy, (size_type)strlen(copy));
	}

	// = operator
	TiXmlString& operator = (const TiXmlString & copy)
	{
		return assign(copy.start(), copy.length());
	}


	// += operator. Maps to append
	TiXmlString& operator += (const char * suffix)
	{
		return append(suffix, static_cast<size_type>( strlen(suffix) ));
	}

	// += operator. Maps to append
	TiXmlString& operator += (char single)
	{
		return append(&single, 1);
	}

	// += operator. Maps to append
	TiXmlString& operator += (const TiXmlString & suffix)
	{
		return append(suffix.data(), suffix.length());
	}


	// Convert a TiXmlString into a null-terminated char *
	const char * c_str () const { return rep_->str; }

	// Convert a TiXmlString into a char * (need not be null terminated).
	const char * data () const { return rep_->str; }

	// Return the length of a TiXmlString
	size_type length () const { return rep_->size; }

	// Alias for length()
	size_type size () const { return rep_->size; }

	// Checks if a TiXmlString is empty
	bool empty () const { return rep_->size == 0; }

	// Return capacity of string
	size_type capacity () const { return rep_->capacity; }


	// single char extraction
	const char& at (size_type index) const
	{
		assert( index < length() );
		return rep_->str[ index ];
	}

	// [] operator
	char& operator [] (size_type index) const
	{
		assert( index < length() );
		return rep_->str[ index ];
	}

	// find a char in a string. Return TiXmlString::npos if not found
	size_type find (char lookup) const
	{
		return find(lookup, 0);
	}

	// find a char in a string from an offset. Return TiXmlString::npos if not found
	size_type find (char tofind, size_type offset) const
	{
		if (offset >= length()) return npos;

		for (const char* p = c_str() + offset; *p != '\0'; ++p)
		{
		   if (*p == tofind) return static_cast< size_type >( p - c_str() );
		}
		return npos;
	}

	void clear ()
	{
		//Lee:
		//The original was just too strange, though correct:
		//	TiXmlString().swap(*this);
		//Instead use the quit & re-init:
		quit();
		init(0,0);
	}

	/*	Function to reserve a big amount of data when we know we'll need it. Be aware that this
		function DOES NOT clear the content of the TiXmlString if any exists.
	*/
	void reserve (size_type cap);

	TiXmlString& assign (const char* str, size_type len);

	TiXmlString& append (const char* str, size_type len);

	void swap (TiXmlString& other)
	{
		Rep* r = rep_;
		rep_ = other.rep_;
		other.rep_ = r;
	}

  private:

	void init(size_type sz) { init(sz, sz); }
	void set_size(size_type sz) { rep_->str[ rep_->size = sz ] = '\0'; }
	char* start() const { return rep_->str; }
	char* finish() const { return rep_->str + rep_->size; }

	struct Rep
	{
		size_type size, capacity;
		char str[1];
	};

	void init(size_type sz, size_type cap)
	{
		if (cap)
		{
			// Lee: the original form:
			//	rep_ = static_cast<Rep*>(operator new(sizeof(Rep) + cap));
			// doesn't work in some cases of new being overloaded. Switching
			// to the normal allocation, although use an 'int' for systems
			// that are overly picky about structure alignment.
			const size_type bytesNeeded = sizeof(Rep) + cap;
			const size_type intsNeeded = ( bytesNeeded + sizeof(int) - 1 ) / sizeof( int ); 
			rep_ = reinterpret_cast<Rep*>( new int[ intsNeeded ] );

			rep_->str[ rep_->size = sz ] = '\0';
			rep_->capacity = cap;
		}
		else
		{
			rep_ = &nullrep_;
		}
	}

	void quit()
	{
		if (rep_ != &nullrep_)
		{
			// The rep_ is really an array of ints. (see the allocator, above).
			// Cast it back before delete, so the compiler won't incorrectly call destructors.
			delete [] ( reinterpret_cast<int*>( rep_ ) );
		}
	}

	Rep * rep_;
	static Rep nullrep_;

} ;


inline bool operator == (const TiXmlString & a, const TiXmlString & b)
{
	return    ( a.length() == b.length() )				// optimization on some platforms
	       && ( strcmp(a.c_str(), b.c_str()) == 0 );	// actual compare
}
inline bool operator < (const TiXmlString & a, const TiXmlString & b)
{
	return strcmp(a.c_str(), b.c_str()) < 0;
}

inline bool operator != (const TiXmlString & a, const TiXmlString & b) { return !(a == b); }
inline bool operator >  (const TiXmlString & a, const TiXmlString & b) { return b < a; }
inline bool operator <= (const TiXmlString & a, const TiXmlString & b) { return !(b < a); }
inline bool operator >= (const TiXmlString & a, const TiXmlString & b) { return !(a < b); }

inline bool operator == (const TiXmlString & a, const char* b) { return strcmp(a.c_str(), b) == 0; }
inline bool operator == (const char* a, const TiXmlString & b) { return b == a; }
inline bool operator != (const TiXmlString & a, const char* b) { return !(a == b); }
inline bool operator != (const char* a, const TiXmlString & b) { return !(b == a); }

TiXmlString operator + (const TiXmlString & a, const TiXmlString & b);
TiXmlString operator + (const TiXmlString & a, const char* b);
TiXmlString operator + (const char* a, const TiXmlString & b);


/*
   TiXmlOutStream is an emulation of std::ostream. It is based on TiXmlString.
   Only the operators that we need for TinyXML have been developped.
*/
class TiXmlOutStream : public TiXmlString
{
public :

	// TiXmlOutStream << operator.
	TiXmlOutStream & operator << (const TiXmlString & in)
	{
		*this += in;
		return *this;
	}

	// TiXmlOutStream << operator.
	TiXmlOutStream & operator << (const char * in)
	{
		*this += in;
		return *this;
	}

} ;

#endif	// TIXML_STRING_INCLUDED
#endif	// TIXML_USE_STL
/*
www.sourceforge.net/projects/tinyxml
Original code (2.0 and earlier )copyright (c) 2000-2006 Lee Thomason (www.grinninglizard.com)

This software is provided 'as-is', without any express or implied
warranty. In no event will the authors be held liable for any
damages arising from the use of this software.

Permission is granted to anyone to use this software for any
purpose, including commercial applications, and to alter it and
redistribute it freely, subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must
not claim that you wrote the original software. If you use this
software in a product, an acknowledgment in the product documentation
would be appreciated but is not required.

2. Altered source versions must be plainly marked as such, and
must not be misrepresented as being the original software.

3. This notice may not be removed or altered from any source
distribution.
*/


#ifndef TINYXML_INCLUDED
#define TINYXML_INCLUDED

#ifdef _MSC_VER
#pragma warning( push )
#pragma warning( disable : 4530 )
#pragma warning( disable : 4786 )
#endif

#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>

// Help out windows:
#if defined( _DEBUG ) && !defined( DEBUG )
#define DEBUG
#endif

#ifdef TIXML_USE_STL
	#include <string>
 	#include <iostream>
	#include <sstream>
	#define TIXML_STRING		std::string
#else
	#define TIXML_STRING		TiXmlString
#endif

// Deprecated library function hell. Compilers want to use the
// new safe versions. This probably doesn't fully address the problem,
// but it gets closer. There are too many compilers for me to fully
// test. If you get compilation troubles, undefine TIXML_SAFE
#define TIXML_SAFE

#ifdef TIXML_SAFE
	#if defined(_MSC_VER) && (_MSC_VER >= 1400 )
		// Microsoft visual studio, version 2005 and higher.
		#define TIXML_SNPRINTF _snprintf_s
		#define TIXML_SSCANF   sscanf_s
	#elif defined(_MSC_VER) && (_MSC_VER >= 1200 )
		// Microsoft visual studio, version 6 and higher.
		//#pragma message( "Using _sn* functions." )
		#define TIXML_SNPRINTF _snprintf
		#define TIXML_SSCANF   sscanf
	#elif defined(__GNUC__) && (__GNUC__ >= 3 )
		// GCC version 3 and higher.s
		//#warning( "Using sn* functions." )
		#define TIXML_SNPRINTF snprintf
		#define TIXML_SSCANF   sscanf
	#else
		#define TIXML_SNPRINTF snprintf
		#define TIXML_SSCANF   sscanf
	#endif
#endif	

class TiXmlDocument;
class TiXmlElement;
class TiXmlComment;
class TiXmlUnknown;
class TiXmlAttribute;
class TiXmlText;
class TiXmlDeclaration;
class TiXmlParsingData;

const int TIXML_MAJOR_VERSION = 2;
const int TIXML_MINOR_VERSION = 6;
const int TIXML_PATCH_VERSION = 1;

/*	Internal structure for tracking location of items 
	in the XML file.
*/
struct TiXmlCursor
{
	TiXmlCursor()		{ Clear(); }
	void Clear()		{ row = col = -1; }

	int row;	// 0 based.
	int col;	// 0 based.
};


/**
	Implements the interface to the "Visitor pattern" (see the Accept() method.)
	If you call the Accept() method, it requires being passed a TiXmlVisitor
	class to handle callbacks. For nodes that contain other nodes (Document, Element)
	you will get called with a VisitEnter/VisitExit pair. Nodes that are always leaves
	are simply called with Visit().

	If you return 'true' from a Visit method, recursive parsing will continue. If you return
	false, <b>no children of this node or its sibilings</b> will be Visited.

	All flavors of Visit methods have a default implementation that returns 'true' (continue 
	visiting). You need to only override methods that are interesting to you.

	Generally Accept() is called on the TiXmlDocument, although all nodes suppert Visiting.

	You should never change the document from a callback.

	@sa TiXmlNode::Accept()
*/
class TiXmlVisitor
{
public:
	virtual ~TiXmlVisitor() {}

	/// Visit a document.
	virtual bool VisitEnter( const TiXmlDocument& /*doc*/ )			{ return true; }
	/// Visit a document.
	virtual bool VisitExit( const TiXmlDocument& /*doc*/ )			{ return true; }

	/// Visit an element.
	virtual bool VisitEnter( const TiXmlElement& /*element*/, const TiXmlAttribute* /*firstAttribute*/ )	{ return true; }
	/// Visit an element.
	virtual bool VisitExit( const TiXmlElement& /*element*/ )		{ return true; }

	/// Visit a declaration
	virtual bool Visit( const TiXmlDeclaration& /*declaration*/ )	{ return true; }
	/// Visit a text node
	virtual bool Visit( const TiXmlText& /*text*/ )					{ return true; }
	/// Visit a comment node
	virtual bool Visit( const TiXmlComment& /*comment*/ )			{ return true; }
	/// Visit an unknow node
	virtual bool Visit( const TiXmlUnknown& /*unknown*/ )			{ return true; }
};

// Only used by Attribute::Query functions
enum 
{ 
	TIXML_SUCCESS,
	TIXML_NO_ATTRIBUTE,
	TIXML_WRONG_TYPE
};


// Used by the parsing routines.
enum TiXmlEncoding
{
	TIXML_ENCODING_UNKNOWN,
	TIXML_ENCODING_UTF8,
	TIXML_ENCODING_LEGACY
};

const TiXmlEncoding TIXML_DEFAULT_ENCODING = TIXML_ENCODING_UNKNOWN;

/** TiXmlBase is a base class for every class in TinyXml.
	It does little except to establish that TinyXml classes
	can be printed and provide some utility functions.

	In XML, the document and elements can contain
	other elements and other types of nodes.

	@verbatim
	A Document can contain:	Element	(container or leaf)
							Comment (leaf)
							Unknown (leaf)
							Declaration( leaf )

	An Element can contain:	Element (container or leaf)
							Text	(leaf)
							Attributes (not on tree)
							Comment (leaf)
							Unknown (leaf)

	A Decleration contains: Attributes (not on tree)
	@endverbatim
*/
class TiXmlBase
{
	friend class TiXmlNode;
	friend class TiXmlElement;
	friend class TiXmlDocument;

public:
	TiXmlBase()	:	userData(0)		{}
	virtual ~TiXmlBase()			{}

	/**	All TinyXml classes can print themselves to a filestream
		or the string class (TiXmlString in non-STL mode, std::string
		in STL mode.) Either or both cfile and str can be null.
		
		This is a formatted print, and will insert 
		tabs and newlines.
		
		(For an unformatted stream, use the << operator.)
	*/
	virtual void Print( FILE* cfile, int depth ) const = 0;

	/**	The world does not agree on whether white space should be kept or
		not. In order to make everyone happy, these global, static functions
		are provided to set whether or not TinyXml will condense all white space
		into a single space or not. The default is to condense. Note changing this
		value is not thread safe.
	*/
	static void SetCondenseWhiteSpace( bool condense )		{ condenseWhiteSpace = condense; }

	/// Return the current white space setting.
	static bool IsWhiteSpaceCondensed()						{ return condenseWhiteSpace; }

	/** Return the position, in the original source file, of this node or attribute.
		The row and column are 1-based. (That is the first row and first column is
		1,1). If the returns values are 0 or less, then the parser does not have
		a row and column value.

		Generally, the row and column value will be set when the TiXmlDocument::Load(),
		TiXmlDocument::LoadFile(), or any TiXmlNode::Parse() is called. It will NOT be set
		when the DOM was created from operator>>.

		The values reflect the initial load. Once the DOM is modified programmatically
		(by adding or changing nodes and attributes) the new values will NOT update to
		reflect changes in the document.

		There is a minor performance cost to computing the row and column. Computation
		can be disabled if TiXmlDocument::SetTabSize() is called with 0 as the value.

		@sa TiXmlDocument::SetTabSize()
	*/
	int Row() const			{ return location.row + 1; }
	int Column() const		{ return location.col + 1; }	///< See Row()

	void  SetUserData( void* user )			{ userData = user; }	///< Set a pointer to arbitrary user data.
	void* GetUserData()						{ return userData; }	///< Get a pointer to arbitrary user data.
	const void* GetUserData() const 		{ return userData; }	///< Get a pointer to arbitrary user data.

	// Table that returs, for a given lead byte, the total number of bytes
	// in the UTF-8 sequence.
	static const int utf8ByteTable[256];

	virtual const char* Parse(	const char* p, 
								TiXmlParsingData* data, 
								TiXmlEncoding encoding /*= TIXML_ENCODING_UNKNOWN */ ) = 0;

	/** Expands entities in a string. Note this should not contian the tag's '<', '>', etc, 
		or they will be transformed into entities!
	*/
	static void EncodeString( const TIXML_STRING& str, TIXML_STRING* out );

	enum
	{
		TIXML_NO_ERROR = 0,
		TIXML_ERROR,
		TIXML_ERROR_OPENING_FILE,
		TIXML_ERROR_PARSING_ELEMENT,
		TIXML_ERROR_FAILED_TO_READ_ELEMENT_NAME,
		TIXML_ERROR_READING_ELEMENT_VALUE,
		TIXML_ERROR_READING_ATTRIBUTES,
		TIXML_ERROR_PARSING_EMPTY,
		TIXML_ERROR_READING_END_TAG,
		TIXML_ERROR_PARSING_UNKNOWN,
		TIXML_ERROR_PARSING_COMMENT,
		TIXML_ERROR_PARSING_DECLARATION,
		TIXML_ERROR_DOCUMENT_EMPTY,
		TIXML_ERROR_EMBEDDED_NULL,
		TIXML_ERROR_PARSING_CDATA,
		TIXML_ERROR_DOCUMENT_TOP_ONLY,

		TIXML_ERROR_STRING_COUNT
	};

protected:

	static const char* SkipWhiteSpace( const char*, TiXmlEncoding encoding );

	inline static bool IsWhiteSpace( char c )		
	{ 
		return ( isspace( (unsigned char) c ) || c == '\n' || c == '\r' ); 
	}
	inline static bool IsWhiteSpace( int c )
	{
		if ( c < 256 )
			return IsWhiteSpace( (char) c );
		return false;	// Again, only truly correct for English/Latin...but usually works.
	}

	#ifdef TIXML_USE_STL
	static bool	StreamWhiteSpace( std::istream * in, TIXML_STRING * tag );
	static bool StreamTo( std::istream * in, int character, TIXML_STRING * tag );
	#endif

	/*	Reads an XML name into the string provided. Returns
		a pointer just past the last character of the name,
		or 0 if the function has an error.
	*/
	static const char* ReadName( const char* p, TIXML_STRING* name, TiXmlEncoding encoding );

	/*	Reads text. Returns a pointer past the given end tag.
		Wickedly complex options, but it keeps the (sensitive) code in one place.
	*/
	static const char* ReadText(	const char* in,				// where to start
									TIXML_STRING* text,			// the string read
									bool ignoreWhiteSpace,		// whether to keep the white space
									const char* endTag,			// what ends this text
									bool ignoreCase,			// whether to ignore case in the end tag
									TiXmlEncoding encoding );	// the current encoding

	// If an entity has been found, transform it into a character.
	static const char* GetEntity( const char* in, char* value, int* length, TiXmlEncoding encoding );

	// Get a character, while interpreting entities.
	// The length can be from 0 to 4 bytes.
	inline static const char* GetChar( const char* p, char* _value, int* length, TiXmlEncoding encoding )
	{
		assert( p );
		if ( encoding == TIXML_ENCODING_UTF8 )
		{
			*length = utf8ByteTable[ *((const unsigned char*)p) ];
			assert( *length >= 0 && *length < 5 );
		}
		else
		{
			*length = 1;
		}

		if ( *length == 1 )
		{
			if ( *p == '&' )
				return GetEntity( p, _value, length, encoding );
			*_value = *p;
			return p+1;
		}
		else if ( *length )
		{
			//strncpy( _value, p, *length );	// lots of compilers don't like this function (unsafe),
												// and the null terminator isn't needed
			for( int i=0; p[i] && i<*length; ++i ) {
				_value[i] = p[i];
			}
			return p + (*length);
		}
		else
		{
			// Not valid text.
			return 0;
		}
	}

	// Return true if the next characters in the stream are any of the endTag sequences.
	// Ignore case only works for english, and should only be relied on when comparing
	// to English words: StringEqual( p, "version", true ) is fine.
	static bool StringEqual(	const char* p,
								const char* endTag,
								bool ignoreCase,
								TiXmlEncoding encoding );

	static const char* errorString[ TIXML_ERROR_STRING_COUNT ];

	TiXmlCursor location;

    /// Field containing a generic user pointer
	void*			userData;
	
	// None of these methods are reliable for any language except English.
	// Good for approximation, not great for accuracy.
	static int IsAlpha( unsigned char anyByte, TiXmlEncoding encoding );
	static int IsAlphaNum( unsigned char anyByte, TiXmlEncoding encoding );
	inline static int ToLower( int v, TiXmlEncoding encoding )
	{
		if ( encoding == TIXML_ENCODING_UTF8 )
		{
			if ( v < 128 ) return tolower( v );
			return v;
		}
		else
		{
			return tolower( v );
		}
	}
	static void ConvertUTF32ToUTF8( unsigned long input, char* output, int* length );

private:
	TiXmlBase( const TiXmlBase& );				// not implemented.
	void operator=( const TiXmlBase& base );	// not allowed.

	struct Entity
	{
		const char*     str;
		unsigned int	strLength;
		char		    chr;
	};
	enum
	{
		NUM_ENTITY = 5,
		MAX_ENTITY_LENGTH = 6

	};
	static Entity entity[ NUM_ENTITY ];
	static bool condenseWhiteSpace;
};


/** The parent class for everything in the Document Object Model.
	(Except for attributes).
	Nodes have siblings, a parent, and children. A node can be
	in a document, or stand on its own. The type of a TiXmlNode
	can be queried, and it can be cast to its more defined type.
*/
class TiXmlNode : public TiXmlBase
{
	friend class TiXmlDocument;
	friend class TiXmlElement;

public:
	#ifdef TIXML_USE_STL	

	    /** An input stream operator, for every class. Tolerant of newlines and
		    formatting, but doesn't expect them.
	    */
	    friend std::istream& operator >> (std::istream& in, TiXmlNode& base);

	    /** An output stream operator, for every class. Note that this outputs
		    without any newlines or formatting, as opposed to Print(), which
		    includes tabs and new lines.

		    The operator<< and operator>> are not completely symmetric. Writing
		    a node to a stream is very well defined. You'll get a nice stream
		    of output, without any extra whitespace or newlines.
		    
		    But reading is not as well defined. (As it always is.) If you create
		    a TiXmlElement (for example) and read that from an input stream,
		    the text needs to define an element or junk will result. This is
		    true of all input streams, but it's worth keeping in mind.

		    A TiXmlDocument will read nodes until it reads a root element, and
			all the children of that root element.
	    */	
	    friend std::ostream& operator<< (std::ostream& out, const TiXmlNode& base);

		/// Appends the XML node or attribute to a std::string.
		friend std::string& operator<< (std::string& out, const TiXmlNode& base );

	#endif

	/** The types of XML nodes supported by TinyXml. (All the
			unsupported types are picked up by UNKNOWN.)
	*/
	enum NodeType
	{
		TINYXML_DOCUMENT,
		TINYXML_ELEMENT,
		TINYXML_COMMENT,
		TINYXML_UNKNOWN,
		TINYXML_TEXT,
		TINYXML_DECLARATION,
		TINYXML_TYPECOUNT
	};

	virtual ~TiXmlNode();

	/** The meaning of 'value' changes for the specific type of
		TiXmlNode.
		@verbatim
		Document:	filename of the xml file
		Element:	name of the element
		Comment:	the comment text
		Unknown:	the tag contents
		Text:		the text string
		@endverbatim

		The subclasses will wrap this function.
	*/
	const char *Value() const { return value.c_str (); }

    #ifdef TIXML_USE_STL
	/** Return Value() as a std::string. If you only use STL,
	    this is more efficient than calling Value().
		Only available in STL mode.
	*/
	const std::string& ValueStr() const { return value; }
	#endif

	const TIXML_STRING& ValueTStr() const { return value; }

	/** Changes the value of the node. Defined as:
		@verbatim
		Document:	filename of the xml file
		Element:	name of the element
		Comment:	the comment text
		Unknown:	the tag contents
		Text:		the text string
		@endverbatim
	*/
	void SetValue(const char * _value) { value = _value;}

    #ifdef TIXML_USE_STL
	/// STL std::string form.
	void SetValue( const std::string& _value )	{ value = _value; }
	#endif

	/// Delete all the children of this node. Does not affect 'this'.
	void Clear();

	/// One step up the DOM.
	TiXmlNode* Parent()							{ return parent; }
	const TiXmlNode* Parent() const				{ return parent; }

	const TiXmlNode* FirstChild()	const		{ return firstChild; }	///< The first child of this node. Will be null if there are no children.
	TiXmlNode* FirstChild()						{ return firstChild; }
	const TiXmlNode* FirstChild( const char * value ) const;			///< The first child of this node with the matching 'value'. Will be null if none found.
	/// The first child of this node with the matching 'value'. Will be null if none found.
	TiXmlNode* FirstChild( const char * _value ) {
		// Call through to the const version - safe since nothing is changed. Exiting syntax: cast this to a const (always safe)
		// call the method, cast the return back to non-const.
		return const_cast< TiXmlNode* > ((const_cast< const TiXmlNode* >(this))->FirstChild( _value ));
	}
	const TiXmlNode* LastChild() const	{ return lastChild; }		/// The last child of this node. Will be null if there are no children.
	TiXmlNode* LastChild()	{ return lastChild; }
	
	const TiXmlNode* LastChild( const char * value ) const;			/// The last child of this node matching 'value'. Will be null if there are no children.
	TiXmlNode* LastChild( const char * _value ) {
		return const_cast< TiXmlNode* > ((const_cast< const TiXmlNode* >(this))->LastChild( _value ));
	}

    #ifdef TIXML_USE_STL
	const TiXmlNode* FirstChild( const std::string& _value ) const	{	return FirstChild (_value.c_str ());	}	///< STL std::string form.
	TiXmlNode* FirstChild( const std::string& _value )				{	return FirstChild (_value.c_str ());	}	///< STL std::string form.
	const TiXmlNode* LastChild( const std::string& _value ) const	{	return LastChild (_value.c_str ());	}	///< STL std::string form.
	TiXmlNode* LastChild( const std::string& _value )				{	return LastChild (_value.c_str ());	}	///< STL std::string form.
	#endif

	/** An alternate way to walk the children of a node.
		One way to iterate over nodes is:
		@verbatim
			for( child = parent->FirstChild(); child; child = child->NextSibling() )
		@endverbatim

		IterateChildren does the same thing with the syntax:
		@verbatim
			child = 0;
			while( child = parent->IterateChildren( child ) )
		@endverbatim

		IterateChildren takes the previous child as input and finds
		the next one. If the previous child is null, it returns the
		first. IterateChildren will return null when done.
	*/
	const TiXmlNode* IterateChildren( const TiXmlNode* previous ) const;
	TiXmlNode* IterateChildren( const TiXmlNode* previous ) {
		return const_cast< TiXmlNode* >( (const_cast< const TiXmlNode* >(this))->IterateChildren( previous ) );
	}

	/// This flavor of IterateChildren searches for children with a particular 'value'
	const TiXmlNode* IterateChildren( const char * value, const TiXmlNode* previous ) const;
	TiXmlNode* IterateChildren( const char * _value, const TiXmlNode* previous ) {
		return const_cast< TiXmlNode* >( (const_cast< const TiXmlNode* >(this))->IterateChildren( _value, previous ) );
	}

    #ifdef TIXML_USE_STL
	const TiXmlNode* IterateChildren( const std::string& _value, const TiXmlNode* previous ) const	{	return IterateChildren (_value.c_str (), previous);	}	///< STL std::string form.
	TiXmlNode* IterateChildren( const std::string& _value, const TiXmlNode* previous ) {	return IterateChildren (_value.c_str (), previous);	}	///< STL std::string form.
	#endif

	/** Add a new node related to this. Adds a child past the LastChild.
		Returns a pointer to the new object or NULL if an error occured.
	*/
	TiXmlNode* InsertEndChild( const TiXmlNode& addThis );


	/** Add a new node related to this. Adds a child past the LastChild.

		NOTE: the node to be added is passed by pointer, and will be
		henceforth owned (and deleted) by tinyXml. This method is efficient
		and avoids an extra copy, but should be used with care as it
		uses a different memory model than the other insert functions.

		@sa InsertEndChild
	*/
	TiXmlNode* LinkEndChild( TiXmlNode* addThis );

	/** Add a new node related to this. Adds a child before the specified child.
		Returns a pointer to the new object or NULL if an error occured.
	*/
	TiXmlNode* InsertBeforeChild( TiXmlNode* beforeThis, const TiXmlNode& addThis );

	/** Add a new node related to this. Adds a child after the specified child.
		Returns a pointer to the new object or NULL if an error occured.
	*/
	TiXmlNode* InsertAfterChild(  TiXmlNode* afterThis, const TiXmlNode& addThis );

	/** Replace a child of this node.
		Returns a pointer to the new object or NULL if an error occured.
	*/
	TiXmlNode* ReplaceChild( TiXmlNode* replaceThis, const TiXmlNode& withThis );

	/// Delete a child of this node.
	bool RemoveChild( TiXmlNode* removeThis );

	/// Navigate to a sibling node.
	const TiXmlNode* PreviousSibling() const			{ return prev; }
	TiXmlNode* PreviousSibling()						{ return prev; }

	/// Navigate to a sibling node.
	const TiXmlNode* PreviousSibling( const char * ) const;
	TiXmlNode* PreviousSibling( const char *_prev ) {
		return const_cast< TiXmlNode* >( (const_cast< const TiXmlNode* >(this))->PreviousSibling( _prev ) );
	}

    #ifdef TIXML_USE_STL
	const TiXmlNode* PreviousSibling( const std::string& _value ) const	{	return PreviousSibling (_value.c_str ());	}	///< STL std::string form.
	TiXmlNode* PreviousSibling( const std::string& _value ) 			{	return PreviousSibling (_value.c_str ());	}	///< STL std::string form.
	const TiXmlNode* NextSibling( const std::string& _value) const		{	return NextSibling (_value.c_str ());	}	///< STL std::string form.
	TiXmlNode* NextSibling( const std::string& _value) 					{	return NextSibling (_value.c_str ());	}	///< STL std::string form.
	#endif

	/// Navigate to a sibling node.
	const TiXmlNode* NextSibling() const				{ return next; }
	TiXmlNode* NextSibling()							{ return next; }

	/// Navigate to a sibling node with the given 'value'.
	const TiXmlNode* NextSibling( const char * ) const;
	TiXmlNode* NextSibling( const char* _next ) {
		return const_cast< TiXmlNode* >( (const_cast< const TiXmlNode* >(this))->NextSibling( _next ) );
	}

	/** Convenience function to get through elements.
		Calls NextSibling and ToElement. Will skip all non-Element
		nodes. Returns 0 if there is not another element.
	*/
	const TiXmlElement* NextSiblingElement() const;
	TiXmlElement* NextSiblingElement() {
		return const_cast< TiXmlElement* >( (const_cast< const TiXmlNode* >(this))->NextSiblingElement() );
	}

	/** Convenience function to get through elements.
		Calls NextSibling and ToElement. Will skip all non-Element
		nodes. Returns 0 if there is not another element.
	*/
	const TiXmlElement* NextSiblingElement( const char * ) const;
	TiXmlElement* NextSiblingElement( const char *_next ) {
		return const_cast< TiXmlElement* >( (const_cast< const TiXmlNode* >(this))->NextSiblingElement( _next ) );
	}

    #ifdef TIXML_USE_STL
	const TiXmlElement* NextSiblingElement( const std::string& _value) const	{	return NextSiblingElement (_value.c_str ());	}	///< STL std::string form.
	TiXmlElement* NextSiblingElement( const std::string& _value)				{	return NextSiblingElement (_value.c_str ());	}	///< STL std::string form.
	#endif

	/// Convenience function to get through elements.
	const TiXmlElement* FirstChildElement()	const;
	TiXmlElement* FirstChildElement() {
		return const_cast< TiXmlElement* >( (const_cast< const TiXmlNode* >(this))->FirstChildElement() );
	}

	/// Convenience function to get through elements.
	const TiXmlElement* FirstChildElement( const char * _value ) const;
	TiXmlElement* FirstChildElement( const char * _value ) {
		return const_cast< TiXmlElement* >( (const_cast< const TiXmlNode* >(this))->FirstChildElement( _value ) );
	}

    #ifdef TIXML_USE_STL
	const TiXmlElement* FirstChildElement( const std::string& _value ) const	{	return FirstChildElement (_value.c_str ());	}	///< STL std::string form.
	TiXmlElement* FirstChildElement( const std::string& _value )				{	return FirstChildElement (_value.c_str ());	}	///< STL std::string form.
	#endif

	/** Query the type (as an enumerated value, above) of this node.
		The possible types are: DOCUMENT, ELEMENT, COMMENT,
								UNKNOWN, TEXT, and DECLARATION.
	*/
	int Type() const	{ return type; }

	/** Return a pointer to the Document this node lives in.
		Returns null if not in a document.
	*/
	const TiXmlDocument* GetDocument() const;
	TiXmlDocument* GetDocument() {
		return const_cast< TiXmlDocument* >( (const_cast< const TiXmlNode* >(this))->GetDocument() );
	}

	/// Returns true if this node has no children.
	bool NoChildren() const						{ return !firstChild; }

	virtual const TiXmlDocument*    ToDocument()    const { return 0; } ///< Cast to a more defined type. Will return null if not of the requested type.
	virtual const TiXmlElement*     ToElement()     const { return 0; } ///< Cast to a more defined type. Will return null if not of the requested type.
	virtual const TiXmlComment*     ToComment()     const { return 0; } ///< Cast to a more defined type. Will return null if not of the requested type.
	virtual const TiXmlUnknown*     ToUnknown()     const { return 0; } ///< Cast to a more defined type. Will return null if not of the requested type.
	virtual const TiXmlText*        ToText()        const { return 0; } ///< Cast to a more defined type. Will return null if not of the requested type.
	virtual const TiXmlDeclaration* ToDeclaration() const { return 0; } ///< Cast to a more defined type. Will return null if not of the requested type.

	virtual TiXmlDocument*          ToDocument()    { return 0; } ///< Cast to a more defined type. Will return null if not of the requested type.
	virtual TiXmlElement*           ToElement()	    { return 0; } ///< Cast to a more defined type. Will return null if not of the requested type.
	virtual TiXmlComment*           ToComment()     { return 0; } ///< Cast to a more defined type. Will return null if not of the requested type.
	virtual TiXmlUnknown*           ToUnknown()	    { return 0; } ///< Cast to a more defined type. Will return null if not of the requested type.
	virtual TiXmlText*	            ToText()        { return 0; } ///< Cast to a more defined type. Will return null if not of the requested type.
	virtual TiXmlDeclaration*       ToDeclaration() { return 0; } ///< Cast to a more defined type. Will return null if not of the requested type.

	/** Create an exact duplicate of this node and return it. The memory must be deleted
		by the caller. 
	*/
	virtual TiXmlNode* Clone() const = 0;

	/** Accept a hierchical visit the nodes in the TinyXML DOM. Every node in the 
		XML tree will be conditionally visited and the host will be called back
		via the TiXmlVisitor interface.

		This is essentially a SAX interface for TinyXML. (Note however it doesn't re-parse
		the XML for the callbacks, so the performance of TinyXML is unchanged by using this
		interface versus any other.)

		The interface has been based on ideas from:

		- http://www.saxproject.org/
		- http://c2.com/cgi/wiki?HierarchicalVisitorPattern 

		Which are both good references for "visiting".

		An example of using Accept():
		@verbatim
		TiXmlPrinter printer;
		tinyxmlDoc.Accept( &printer );
		const char* xmlcstr = printer.CStr();
		@endverbatim
	*/
	virtual bool Accept( TiXmlVisitor* visitor ) const = 0;

protected:
	TiXmlNode( NodeType _type );

	// Copy to the allocated object. Shared functionality between Clone, Copy constructor,
	// and the assignment operator.
	void CopyTo( TiXmlNode* target ) const;

	#ifdef TIXML_USE_STL
	    // The real work of the input operator.
	virtual void StreamIn( std::istream* in, TIXML_STRING* tag ) = 0;
	#endif

	// Figure out what is at *p, and parse it. Returns null if it is not an xml node.
	TiXmlNode* Identify( const char* start, TiXmlEncoding encoding );

	TiXmlNode*		parent;
	NodeType		type;

	TiXmlNode*		firstChild;
	TiXmlNode*		lastChild;

	TIXML_STRING	value;

	TiXmlNode*		prev;
	TiXmlNode*		next;

private:
	TiXmlNode( const TiXmlNode& );				// not implemented.
	void operator=( const TiXmlNode& base );	// not allowed.
};


/** An attribute is a name-value pair. Elements have an arbitrary
	number of attributes, each with a unique name.

	@note The attributes are not TiXmlNodes, since they are not
		  part of the tinyXML document object model. There are other
		  suggested ways to look at this problem.
*/
class TiXmlAttribute : public TiXmlBase
{
	friend class TiXmlAttributeSet;

public:
	/// Construct an empty attribute.
	TiXmlAttribute() : TiXmlBase()
	{
		document = 0;
		prev = next = 0;
	}

	#ifdef TIXML_USE_STL
	/// std::string constructor.
	TiXmlAttribute( const std::string& _name, const std::string& _value )
	{
		name = _name;
		value = _value;
		document = 0;
		prev = next = 0;
	}
	#endif

	/// Construct an attribute with a name and value.
	TiXmlAttribute( const char * _name, const char * _value )
	{
		name = _name;
		value = _value;
		document = 0;
		prev = next = 0;
	}

	const char*		Name()  const		{ return name.c_str(); }		///< Return the name of this attribute.
	const char*		Value() const		{ return value.c_str(); }		///< Return the value of this attribute.
	#ifdef TIXML_USE_STL
	const std::string& ValueStr() const	{ return value; }				///< Return the value of this attribute.
	#endif
	int				IntValue() const;									///< Return the value of this attribute, converted to an integer.
	double			DoubleValue() const;								///< Return the value of this attribute, converted to a double.

	// Get the tinyxml string representation
	const TIXML_STRING& NameTStr() const { return name; }

	/** QueryIntValue examines the value string. It is an alternative to the
		IntValue() method with richer error checking.
		If the value is an integer, it is stored in 'value' and 
		the call returns TIXML_SUCCESS. If it is not
		an integer, it returns TIXML_WRONG_TYPE.

		A specialized but useful call. Note that for success it returns 0,
		which is the opposite of almost all other TinyXml calls.
	*/
	int QueryIntValue( int* _value ) const;
	/// QueryDoubleValue examines the value string. See QueryIntValue().
	int QueryDoubleValue( double* _value ) const;

	void SetName( const char* _name )	{ name = _name; }				///< Set the name of this attribute.
	void SetValue( const char* _value )	{ value = _value; }				///< Set the value.

	void SetIntValue( int _value );										///< Set the value from an integer.
	void SetDoubleValue( double _value );								///< Set the value from a double.

    #ifdef TIXML_USE_STL
	/// STL std::string form.
	void SetName( const std::string& _name )	{ name = _name; }	
	/// STL std::string form.	
	void SetValue( const std::string& _value )	{ value = _value; }
	#endif

	/// Get the next sibling attribute in the DOM. Returns null at end.
	const TiXmlAttribute* Next() const;
	TiXmlAttribute* Next() {
		return const_cast< TiXmlAttribute* >( (const_cast< const TiXmlAttribute* >(this))->Next() ); 
	}

	/// Get the previous sibling attribute in the DOM. Returns null at beginning.
	const TiXmlAttribute* Previous() const;
	TiXmlAttribute* Previous() {
		return const_cast< TiXmlAttribute* >( (const_cast< const TiXmlAttribute* >(this))->Previous() ); 
	}

	bool operator==( const TiXmlAttribute& rhs ) const { return rhs.name == name; }
	bool operator<( const TiXmlAttribute& rhs )	 const { return name < rhs.name; }
	bool operator>( const TiXmlAttribute& rhs )  const { return name > rhs.name; }

	/*	Attribute parsing starts: first letter of the name
						 returns: the next char after the value end quote
	*/
	virtual const char* Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding encoding );

	// Prints this Attribute to a FILE stream.
	virtual void Print( FILE* cfile, int depth ) const {
		Print( cfile, depth, 0 );
	}
	void Print( FILE* cfile, int depth, TIXML_STRING* str ) const;

	// [internal use]
	// Set the document pointer so the attribute can report errors.
	void SetDocument( TiXmlDocument* doc )	{ document = doc; }

private:
	TiXmlAttribute( const TiXmlAttribute& );				// not implemented.
	void operator=( const TiXmlAttribute& base );	// not allowed.

	TiXmlDocument*	document;	// A pointer back to a document, for error reporting.
	TIXML_STRING name;
	TIXML_STRING value;
	TiXmlAttribute*	prev;
	TiXmlAttribute*	next;
};


/*	A class used to manage a group of attributes.
	It is only used internally, both by the ELEMENT and the DECLARATION.
	
	The set can be changed transparent to the Element and Declaration
	classes that use it, but NOT transparent to the Attribute
	which has to implement a next() and previous() method. Which makes
	it a bit problematic and prevents the use of STL.

	This version is implemented with circular lists because:
		- I like circular lists
		- it demonstrates some independence from the (typical) doubly linked list.
*/
class TiXmlAttributeSet
{
public:
	TiXmlAttributeSet();
	~TiXmlAttributeSet();

	void Add( TiXmlAttribute* attribute );
	void Remove( TiXmlAttribute* attribute );

	const TiXmlAttribute* First()	const	{ return ( sentinel.next == &sentinel ) ? 0 : sentinel.next; }
	TiXmlAttribute* First()					{ return ( sentinel.next == &sentinel ) ? 0 : sentinel.next; }
	const TiXmlAttribute* Last() const		{ return ( sentinel.prev == &sentinel ) ? 0 : sentinel.prev; }
	TiXmlAttribute* Last()					{ return ( sentinel.prev == &sentinel ) ? 0 : sentinel.prev; }

	TiXmlAttribute*	Find( const char* _name ) const;
	TiXmlAttribute* FindOrCreate( const char* _name );

#	ifdef TIXML_USE_STL
	TiXmlAttribute*	Find( const std::string& _name ) const;
	TiXmlAttribute* FindOrCreate( const std::string& _name );
#	endif


private:
	//*ME:	Because of hidden/disabled copy-construktor in TiXmlAttribute (sentinel-element),
	//*ME:	this class must be also use a hidden/disabled copy-constructor !!!
	TiXmlAttributeSet( const TiXmlAttributeSet& );	// not allowed
	void operator=( const TiXmlAttributeSet& );	// not allowed (as TiXmlAttribute)

	TiXmlAttribute sentinel;
};


/** The element is a container class. It has a value, the element name,
	and can contain other elements, text, comments, and unknowns.
	Elements also contain an arbitrary number of attributes.
*/
class TiXmlElement : public TiXmlNode
{
public:
	/// Construct an element.
	TiXmlElement (const char * in_value);

	#ifdef TIXML_USE_STL
	/// std::string constructor.
	TiXmlElement( const std::string& _value );
	#endif

	TiXmlElement( const TiXmlElement& );

	void operator=( const TiXmlElement& base );

	virtual ~TiXmlElement();

	/** Given an attribute name, Attribute() returns the value
		for the attribute of that name, or null if none exists.
	*/
	const char* Attribute( const char* name ) const;

	/** Given an attribute name, Attribute() returns the value
		for the attribute of that name, or null if none exists.
		If the attribute exists and can be converted to an integer,
		the integer value will be put in the return 'i', if 'i'
		is non-null.
	*/
	const char* Attribute( const char* name, int* i ) const;

	/** Given an attribute name, Attribute() returns the value
		for the attribute of that name, or null if none exists.
		If the attribute exists and can be converted to an double,
		the double value will be put in the return 'd', if 'd'
		is non-null.
	*/
	const char* Attribute( const char* name, double* d ) const;

	/** QueryIntAttribute examines the attribute - it is an alternative to the
		Attribute() method with richer error checking.
		If the attribute is an integer, it is stored in 'value' and 
		the call returns TIXML_SUCCESS. If it is not
		an integer, it returns TIXML_WRONG_TYPE. If the attribute
		does not exist, then TIXML_NO_ATTRIBUTE is returned.
	*/	
	int QueryIntAttribute( const char* name, int* _value ) const;
	/// QueryDoubleAttribute examines the attribute - see QueryIntAttribute().
	int QueryDoubleAttribute( const char* name, double* _value ) const;
	/// QueryFloatAttribute examines the attribute - see QueryIntAttribute().
	int QueryFloatAttribute( const char* name, float* _value ) const {
		double d;
		int result = QueryDoubleAttribute( name, &d );
		if ( result == TIXML_SUCCESS ) {
			*_value = (float)d;
		}
		return result;
	}

    #ifdef TIXML_USE_STL
	/// QueryStringAttribute examines the attribute - see QueryIntAttribute().
	int QueryStringAttribute( const char* name, std::string* _value ) const {
		const char* cstr = Attribute( name );
		if ( cstr ) {
			*_value = std::string( cstr );
			return TIXML_SUCCESS;
		}
		return TIXML_NO_ATTRIBUTE;
	}

	/** Template form of the attribute query which will try to read the
		attribute into the specified type. Very easy, very powerful, but
		be careful to make sure to call this with the correct type.
		
		NOTE: This method doesn't work correctly for 'string' types that contain spaces.

		@return TIXML_SUCCESS, TIXML_WRONG_TYPE, or TIXML_NO_ATTRIBUTE
	*/
	template< typename T > int QueryValueAttribute( const std::string& name, T* outValue ) const
	{
		const TiXmlAttribute* node = attributeSet.Find( name );
		if ( !node )
			return TIXML_NO_ATTRIBUTE;

		std::stringstream sstream( node->ValueStr() );
		sstream >> *outValue;
		if ( !sstream.fail() )
			return TIXML_SUCCESS;
		return TIXML_WRONG_TYPE;
	}

	int QueryValueAttribute( const std::string& name, std::string* outValue ) const
	{
		const TiXmlAttribute* node = attributeSet.Find( name );
		if ( !node )
			return TIXML_NO_ATTRIBUTE;
		*outValue = node->ValueStr();
		return TIXML_SUCCESS;
	}
	#endif

	/** Sets an attribute of name to a given value. The attribute
		will be created if it does not exist, or changed if it does.
	*/
	void SetAttribute( const char* name, const char * _value );

    #ifdef TIXML_USE_STL
	const std::string* Attribute( const std::string& name ) const;
	const std::string* Attribute( const std::string& name, int* i ) const;
	const std::string* Attribute( const std::string& name, double* d ) const;
	int QueryIntAttribute( const std::string& name, int* _value ) const;
	int QueryDoubleAttribute( const std::string& name, double* _value ) const;

	/// STL std::string form.
	void SetAttribute( const std::string& name, const std::string& _value );
	///< STL std::string form.
	void SetAttribute( const std::string& name, int _value );
	///< STL std::string form.
	void SetDoubleAttribute( const std::string& name, double value );
	#endif

	/** Sets an attribute of name to a given value. The attribute
		will be created if it does not exist, or changed if it does.
	*/
	void SetAttribute( const char * name, int value );

	/** Sets an attribute of name to a given value. The attribute
		will be created if it does not exist, or changed if it does.
	*/
	void SetDoubleAttribute( const char * name, double value );

	/** Deletes an attribute with the given name.
	*/
	void RemoveAttribute( const char * name );
    #ifdef TIXML_USE_STL
	void RemoveAttribute( const std::string& name )	{	RemoveAttribute (name.c_str ());	}	///< STL std::string form.
	#endif

	const TiXmlAttribute* FirstAttribute() const	{ return attributeSet.First(); }		///< Access the first attribute in this element.
	TiXmlAttribute* FirstAttribute() 				{ return attributeSet.First(); }
	const TiXmlAttribute* LastAttribute()	const 	{ return attributeSet.Last(); }		///< Access the last attribute in this element.
	TiXmlAttribute* LastAttribute()					{ return attributeSet.Last(); }

	/** Convenience function for easy access to the text inside an element. Although easy
		and concise, GetText() is limited compared to getting the TiXmlText child
		and accessing it directly.
	
		If the first child of 'this' is a TiXmlText, the GetText()
		returns the character string of the Text node, else null is returned.

		This is a convenient method for getting the text of simple contained text:
		@verbatim
		<foo>This is text</foo>
		const char* str = fooElement->GetText();
		@endverbatim

		'str' will be a pointer to "This is text". 
		
		Note that this function can be misleading. If the element foo was created from
		this XML:
		@verbatim
		<foo><b>This is text</b></foo> 
		@endverbatim

		then the value of str would be null. The first child node isn't a text node, it is
		another element. From this XML:
		@verbatim
		<foo>This is <b>text</b></foo> 
		@endverbatim
		GetText() will return "This is ".

		WARNING: GetText() accesses a child node - don't become confused with the 
				 similarly named TiXmlHandle::Text() and TiXmlNode::ToText() which are 
				 safe type casts on the referenced node.
	*/
	const char* GetText() const;

	/// Creates a new Element and returns it - the returned element is a copy.
	virtual TiXmlNode* Clone() const;
	// Print the Element to a FILE stream.
	virtual void Print( FILE* cfile, int depth ) const;

	/*	Attribtue parsing starts: next char past '<'
						 returns: next char past '>'
	*/
	virtual const char* Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding encoding );

	virtual const TiXmlElement*     ToElement()     const { return this; } ///< Cast to a more defined type. Will return null not of the requested type.
	virtual TiXmlElement*           ToElement()	          { return this; } ///< Cast to a more defined type. Will return null not of the requested type.

	/** Walk the XML tree visiting this node and all of its children. 
	*/
	virtual bool Accept( TiXmlVisitor* visitor ) const;

protected:

	void CopyTo( TiXmlElement* target ) const;
	void ClearThis();	// like clear, but initializes 'this' object as well

	// Used to be public [internal use]
	#ifdef TIXML_USE_STL
	virtual void StreamIn( std::istream * in, TIXML_STRING * tag );
	#endif
	/*	[internal use]
		Reads the "value" of the element -- another element, or text.
		This should terminate with the current end tag.
	*/
	const char* ReadValue( const char* in, TiXmlParsingData* prevData, TiXmlEncoding encoding );

private:
	TiXmlAttributeSet attributeSet;
};


/**	An XML comment.
*/
class TiXmlComment : public TiXmlNode
{
public:
	/// Constructs an empty comment.
	TiXmlComment() : TiXmlNode( TiXmlNode::TINYXML_COMMENT ) {}
	/// Construct a comment from text.
	TiXmlComment( const char* _value ) : TiXmlNode( TiXmlNode::TINYXML_COMMENT ) {
		SetValue( _value );
	}
	TiXmlComment( const TiXmlComment& );
	void operator=( const TiXmlComment& base );

	virtual ~TiXmlComment()	{}

	/// Returns a copy of this Comment.
	virtual TiXmlNode* Clone() const;
	// Write this Comment to a FILE stream.
	virtual void Print( FILE* cfile, int depth ) const;

	/*	Attribtue parsing starts: at the ! of the !--
						 returns: next char past '>'
	*/
	virtual const char* Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding encoding );

	virtual const TiXmlComment*  ToComment() const { return this; } ///< Cast to a more defined type. Will return null not of the requested type.
	virtual TiXmlComment*  ToComment() { return this; } ///< Cast to a more defined type. Will return null not of the requested type.

	/** Walk the XML tree visiting this node and all of its children. 
	*/
	virtual bool Accept( TiXmlVisitor* visitor ) const;

protected:
	void CopyTo( TiXmlComment* target ) const;

	// used to be public
	#ifdef TIXML_USE_STL
	virtual void StreamIn( std::istream * in, TIXML_STRING * tag );
	#endif
//	virtual void StreamOut( TIXML_OSTREAM * out ) const;

private:

};


/** XML text. A text node can have 2 ways to output the next. "normal" output 
	and CDATA. It will default to the mode it was parsed from the XML file and
	you generally want to leave it alone, but you can change the output mode with 
	SetCDATA() and query it with CDATA().
*/
class TiXmlText : public TiXmlNode
{
	friend class TiXmlElement;
public:
	/** Constructor for text element. By default, it is treated as 
		normal, encoded text. If you want it be output as a CDATA text
		element, set the parameter _cdata to 'true'
	*/
	TiXmlText (const char * initValue ) : TiXmlNode (TiXmlNode::TINYXML_TEXT)
	{
		SetValue( initValue );
		cdata = false;
	}
	virtual ~TiXmlText() {}

	#ifdef TIXML_USE_STL
	/// Constructor.
	TiXmlText( const std::string& initValue ) : TiXmlNode (TiXmlNode::TINYXML_TEXT)
	{
		SetValue( initValue );
		cdata = false;
	}
	#endif

	TiXmlText( const TiXmlText& copy ) : TiXmlNode( TiXmlNode::TINYXML_TEXT )	{ copy.CopyTo( this ); }
	void operator=( const TiXmlText& base )							 	{ base.CopyTo( this ); }

	// Write this text object to a FILE stream.
	virtual void Print( FILE* cfile, int depth ) const;

	/// Queries whether this represents text using a CDATA section.
	bool CDATA() const				{ return cdata; }
	/// Turns on or off a CDATA representation of text.
	void SetCDATA( bool _cdata )	{ cdata = _cdata; }

	virtual const char* Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding encoding );

	virtual const TiXmlText* ToText() const { return this; } ///< Cast to a more defined type. Will return null not of the requested type.
	virtual TiXmlText*       ToText()       { return this; } ///< Cast to a more defined type. Will return null not of the requested type.

	/** Walk the XML tree visiting this node and all of its children. 
	*/
	virtual bool Accept( TiXmlVisitor* content ) const;

protected :
	///  [internal use] Creates a new Element and returns it.
	virtual TiXmlNode* Clone() const;
	void CopyTo( TiXmlText* target ) const;

	bool Blank() const;	// returns true if all white space and new lines
	// [internal use]
	#ifdef TIXML_USE_STL
	virtual void StreamIn( std::istream * in, TIXML_STRING * tag );
	#endif

private:
	bool cdata;			// true if this should be input and output as a CDATA style text element
};


/** In correct XML the declaration is the first entry in the file.
	@verbatim
		<?xml version="1.0" standalone="yes"?>
	@endverbatim

	TinyXml will happily read or write files without a declaration,
	however. There are 3 possible attributes to the declaration:
	version, encoding, and standalone.

	Note: In this version of the code, the attributes are
	handled as special cases, not generic attributes, simply
	because there can only be at most 3 and they are always the same.
*/
class TiXmlDeclaration : public TiXmlNode
{
public:
	/// Construct an empty declaration.
	TiXmlDeclaration()   : TiXmlNode( TiXmlNode::TINYXML_DECLARATION ) {}

#ifdef TIXML_USE_STL
	/// Constructor.
	TiXmlDeclaration(	const std::string& _version,
						const std::string& _encoding,
						const std::string& _standalone );
#endif

	/// Construct.
	TiXmlDeclaration(	const char* _version,
						const char* _encoding,
						const char* _standalone );

	TiXmlDeclaration( const TiXmlDeclaration& copy );
	void operator=( const TiXmlDeclaration& copy );

	virtual ~TiXmlDeclaration()	{}

	/// Version. Will return an empty string if none was found.
	const char *Version() const			{ return version.c_str (); }
	/// Encoding. Will return an empty string if none was found.
	const char *Encoding() const		{ return encoding.c_str (); }
	/// Is this a standalone document?
	const char *Standalone() const		{ return standalone.c_str (); }

	/// Creates a copy of this Declaration and returns it.
	virtual TiXmlNode* Clone() const;
	// Print this declaration to a FILE stream.
	virtual void Print( FILE* cfile, int depth, TIXML_STRING* str ) const;
	virtual void Print( FILE* cfile, int depth ) const {
		Print( cfile, depth, 0 );
	}

	virtual const char* Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding encoding );

	virtual const TiXmlDeclaration* ToDeclaration() const { return this; } ///< Cast to a more defined type. Will return null not of the requested type.
	virtual TiXmlDeclaration*       ToDeclaration()       { return this; } ///< Cast to a more defined type. Will return null not of the requested type.

	/** Walk the XML tree visiting this node and all of its children. 
	*/
	virtual bool Accept( TiXmlVisitor* visitor ) const;

protected:
	void CopyTo( TiXmlDeclaration* target ) const;
	// used to be public
	#ifdef TIXML_USE_STL
	virtual void StreamIn( std::istream * in, TIXML_STRING * tag );
	#endif

private:

	TIXML_STRING version;
	TIXML_STRING encoding;
	TIXML_STRING standalone;
};


/** Any tag that tinyXml doesn't recognize is saved as an
	unknown. It is a tag of text, but should not be modified.
	It will be written back to the XML, unchanged, when the file
	is saved.

	DTD tags get thrown into TiXmlUnknowns.
*/
class TiXmlUnknown : public TiXmlNode
{
public:
	TiXmlUnknown() : TiXmlNode( TiXmlNode::TINYXML_UNKNOWN )	{}
	virtual ~TiXmlUnknown() {}

	TiXmlUnknown( const TiXmlUnknown& copy ) : TiXmlNode( TiXmlNode::TINYXML_UNKNOWN )		{ copy.CopyTo( this ); }
	void operator=( const TiXmlUnknown& copy )										{ copy.CopyTo( this ); }

	/// Creates a copy of this Unknown and returns it.
	virtual TiXmlNode* Clone() const;
	// Print this Unknown to a FILE stream.
	virtual void Print( FILE* cfile, int depth ) const;

	virtual const char* Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding encoding );

	virtual const TiXmlUnknown*     ToUnknown()     const { return this; } ///< Cast to a more defined type. Will return null not of the requested type.
	virtual TiXmlUnknown*           ToUnknown()	    { return this; } ///< Cast to a more defined type. Will return null not of the requested type.

	/** Walk the XML tree visiting this node and all of its children. 
	*/
	virtual bool Accept( TiXmlVisitor* content ) const;

protected:
	void CopyTo( TiXmlUnknown* target ) const;

	#ifdef TIXML_USE_STL
	virtual void StreamIn( std::istream * in, TIXML_STRING * tag );
	#endif

private:

};


/** Always the top level node. A document binds together all the
	XML pieces. It can be saved, loaded, and printed to the screen.
	The 'value' of a document node is the xml file name.
*/
class TiXmlDocument : public TiXmlNode
{
public:
	/// Create an empty document, that has no name.
	TiXmlDocument();
	/// Create a document with a name. The name of the document is also the filename of the xml.
	TiXmlDocument( const char * documentName );

	#ifdef TIXML_USE_STL
	/// Constructor.
	TiXmlDocument( const std::string& documentName );
	#endif

	TiXmlDocument( const TiXmlDocument& copy );
	void operator=( const TiXmlDocument& copy );

	virtual ~TiXmlDocument() {}

	/** Load a file using the current document value.
		Returns true if successful. Will delete any existing
		document data before loading.
	*/
	bool LoadFile( TiXmlEncoding encoding = TIXML_DEFAULT_ENCODING );
	/// Save a file using the current document value. Returns true if successful.
	bool SaveFile() const;
	/// Load a file using the given filename. Returns true if successful.
	bool LoadFile( const char * filename, TiXmlEncoding encoding = TIXML_DEFAULT_ENCODING );
	/// Save a file using the given filename. Returns true if successful.
	bool SaveFile( const char * filename ) const;
	/** Load a file using the given FILE*. Returns true if successful. Note that this method
		doesn't stream - the entire object pointed at by the FILE*
		will be interpreted as an XML file. TinyXML doesn't stream in XML from the current
		file location. Streaming may be added in the future.
	*/
	bool LoadFile( FILE*, TiXmlEncoding encoding = TIXML_DEFAULT_ENCODING );
	/// Save a file using the given FILE*. Returns true if successful.
	bool SaveFile( FILE* ) const;

	#ifdef TIXML_USE_STL
	bool LoadFile( const std::string& filename, TiXmlEncoding encoding = TIXML_DEFAULT_ENCODING )			///< STL std::string version.
	{
		return LoadFile( filename.c_str(), encoding );
	}
	bool SaveFile( const std::string& filename ) const		///< STL std::string version.
	{
		return SaveFile( filename.c_str() );
	}
	#endif

	/** Parse the given null terminated block of xml data. Passing in an encoding to this
		method (either TIXML_ENCODING_LEGACY or TIXML_ENCODING_UTF8 will force TinyXml
		to use that encoding, regardless of what TinyXml might otherwise try to detect.
	*/
	virtual const char* Parse( const char* p, TiXmlParsingData* data = 0, TiXmlEncoding encoding = TIXML_DEFAULT_ENCODING );

	/** Get the root element -- the only top level element -- of the document.
		In well formed XML, there should only be one. TinyXml is tolerant of
		multiple elements at the document level.
	*/
	const TiXmlElement* RootElement() const		{ return FirstChildElement(); }
	TiXmlElement* RootElement()					{ return FirstChildElement(); }

	/** If an error occurs, Error will be set to true. Also,
		- The ErrorId() will contain the integer identifier of the error (not generally useful)
		- The ErrorDesc() method will return the name of the error. (very useful)
		- The ErrorRow() and ErrorCol() will return the location of the error (if known)
	*/	
	bool Error() const						{ return error; }

	/// Contains a textual (english) description of the error if one occurs.
	const char * ErrorDesc() const	{ return errorDesc.c_str (); }

	/** Generally, you probably want the error string ( ErrorDesc() ). But if you
		prefer the ErrorId, this function will fetch it.
	*/
	int ErrorId()	const				{ return errorId; }

	/** Returns the location (if known) of the error. The first column is column 1, 
		and the first row is row 1. A value of 0 means the row and column wasn't applicable
		(memory errors, for example, have no row/column) or the parser lost the error. (An
		error in the error reporting, in that case.)

		@sa SetTabSize, Row, Column
	*/
	int ErrorRow() const	{ return errorLocation.row+1; }
	int ErrorCol() const	{ return errorLocation.col+1; }	///< The column where the error occured. See ErrorRow()

	/** SetTabSize() allows the error reporting functions (ErrorRow() and ErrorCol())
		to report the correct values for row and column. It does not change the output
		or input in any way.
		
		By calling this method, with a tab size
		greater than 0, the row and column of each node and attribute is stored
		when the file is loaded. Very useful for tracking the DOM back in to
		the source file.

		The tab size is required for calculating the location of nodes. If not
		set, the default of 4 is used. The tabsize is set per document. Setting
		the tabsize to 0 disables row/column tracking.

		Note that row and column tracking is not supported when using operator>>.

		The tab size needs to be enabled before the parse or load. Correct usage:
		@verbatim
		TiXmlDocument doc;
		doc.SetTabSize( 8 );
		doc.Load( "myfile.xml" );
		@endverbatim

		@sa Row, Column
	*/
	void SetTabSize( int _tabsize )		{ tabsize = _tabsize; }

	int TabSize() const	{ return tabsize; }

	/** If you have handled the error, it can be reset with this call. The error
		state is automatically cleared if you Parse a new XML block.
	*/
	void ClearError()						{	error = false; 
												errorId = 0; 
												errorDesc = ""; 
												errorLocation.row = errorLocation.col = 0; 
												//errorLocation.last = 0; 
											}

	/** Write the document to standard out using formatted printing ("pretty print"). */
	void Print() const						{ Print( stdout, 0 ); }

	/* Write the document to a string using formatted printing ("pretty print"). This
		will allocate a character array (new char[]) and return it as a pointer. The
		calling code pust call delete[] on the return char* to avoid a memory leak.
	*/
	//char* PrintToMemory() const; 

	/// Print this Document to a FILE stream.
	virtual void Print( FILE* cfile, int depth = 0 ) const;
	// [internal use]
	void SetError( int err, const char* errorLocation, TiXmlParsingData* prevData, TiXmlEncoding encoding );

	virtual const TiXmlDocument*    ToDocument()    const { return this; } ///< Cast to a more defined type. Will return null not of the requested type.
	virtual TiXmlDocument*          ToDocument()          { return this; } ///< Cast to a more defined type. Will return null not of the requested type.

	/** Walk the XML tree visiting this node and all of its children. 
	*/
	virtual bool Accept( TiXmlVisitor* content ) const;

protected :
	// [internal use]
	virtual TiXmlNode* Clone() const;
	#ifdef TIXML_USE_STL
	virtual void StreamIn( std::istream * in, TIXML_STRING * tag );
	#endif

private:
	void CopyTo( TiXmlDocument* target ) const;

	bool error;
	int  errorId;
	TIXML_STRING errorDesc;
	int tabsize;
	TiXmlCursor errorLocation;
	bool useMicrosoftBOM;		// the UTF-8 BOM were found when read. Note this, and try to write.
};


/**
	A TiXmlHandle is a class that wraps a node pointer with null checks; this is
	an incredibly useful thing. Note that TiXmlHandle is not part of the TinyXml
	DOM structure. It is a separate utility class.

	Take an example:
	@verbatim
	<Document>
		<Element attributeA = "valueA">
			<Child attributeB = "value1" />
			<Child attributeB = "value2" />
		</Element>
	<Document>
	@endverbatim

	Assuming you want the value of "attributeB" in the 2nd "Child" element, it's very 
	easy to write a *lot* of code that looks like:

	@verbatim
	TiXmlElement* root = document.FirstChildElement( "Document" );
	if ( root )
	{
		TiXmlElement* element = root->FirstChildElement( "Element" );
		if ( element )
		{
			TiXmlElement* child = element->FirstChildElement( "Child" );
			if ( child )
			{
				TiXmlElement* child2 = child->NextSiblingElement( "Child" );
				if ( child2 )
				{
					// Finally do something useful.
	@endverbatim

	And that doesn't even cover "else" cases. TiXmlHandle addresses the verbosity
	of such code. A TiXmlHandle checks for null	pointers so it is perfectly safe 
	and correct to use:

	@verbatim
	TiXmlHandle docHandle( &document );
	TiXmlElement* child2 = docHandle.FirstChild( "Document" ).FirstChild( "Element" ).Child( "Child", 1 ).ToElement();
	if ( child2 )
	{
		// do something useful
	@endverbatim

	Which is MUCH more concise and useful.

	It is also safe to copy handles - internally they are nothing more than node pointers.
	@verbatim
	TiXmlHandle handleCopy = handle;
	@endverbatim

	What they should not be used for is iteration:

	@verbatim
	int i=0; 
	while ( true )
	{
		TiXmlElement* child = docHandle.FirstChild( "Document" ).FirstChild( "Element" ).Child( "Child", i ).ToElement();
		if ( !child )
			break;
		// do something
		++i;
	}
	@endverbatim

	It seems reasonable, but it is in fact two embedded while loops. The Child method is 
	a linear walk to find the element, so this code would iterate much more than it needs 
	to. Instead, prefer:

	@verbatim
	TiXmlElement* child = docHandle.FirstChild( "Document" ).FirstChild( "Element" ).FirstChild( "Child" ).ToElement();

	for( child; child; child=child->NextSiblingElement() )
	{
		// do something
	}
	@endverbatim
*/
class TiXmlHandle
{
public:
	/// Create a handle from any node (at any depth of the tree.) This can be a null pointer.
	TiXmlHandle( TiXmlNode* _node )					{ this->node = _node; }
	/// Copy constructor
	TiXmlHandle( const TiXmlHandle& ref )			{ this->node = ref.node; }
	TiXmlHandle operator=( const TiXmlHandle& ref ) { this->node = ref.node; return *this; }

	/// Return a handle to the first child node.
	TiXmlHandle FirstChild() const;
	/// Return a handle to the first child node with the given name.
	TiXmlHandle FirstChild( const char * value ) const;
	/// Return a handle to the first child element.
	TiXmlHandle FirstChildElement() const;
	/// Return a handle to the first child element with the given name.
	TiXmlHandle FirstChildElement( const char * value ) const;

	/** Return a handle to the "index" child with the given name. 
		The first child is 0, the second 1, etc.
	*/
	TiXmlHandle Child( const char* value, int index ) const;
	/** Return a handle to the "index" child. 
		The first child is 0, the second 1, etc.
	*/
	TiXmlHandle Child( int index ) const;
	/** Return a handle to the "index" child element with the given name. 
		The first child element is 0, the second 1, etc. Note that only TiXmlElements
		are indexed: other types are not counted.
	*/
	TiXmlHandle ChildElement( const char* value, int index ) const;
	/** Return a handle to the "index" child element. 
		The first child element is 0, the second 1, etc. Note that only TiXmlElements
		are indexed: other types are not counted.
	*/
	TiXmlHandle ChildElement( int index ) const;

	#ifdef TIXML_USE_STL
	TiXmlHandle FirstChild( const std::string& _value ) const				{ return FirstChild( _value.c_str() ); }
	TiXmlHandle FirstChildElement( const std::string& _value ) const		{ return FirstChildElement( _value.c_str() ); }

	TiXmlHandle Child( const std::string& _value, int index ) const			{ return Child( _value.c_str(), index ); }
	TiXmlHandle ChildElement( const std::string& _value, int index ) const	{ return ChildElement( _value.c_str(), index ); }
	#endif

	/** Return the handle as a TiXmlNode. This may return null.
	*/
	TiXmlNode* ToNode() const			{ return node; } 
	/** Return the handle as a TiXmlElement. This may return null.
	*/
	TiXmlElement* ToElement() const		{ return ( ( node && node->ToElement() ) ? node->ToElement() : 0 ); }
	/**	Return the handle as a TiXmlText. This may return null.
	*/
	TiXmlText* ToText() const			{ return ( ( node && node->ToText() ) ? node->ToText() : 0 ); }
	/** Return the handle as a TiXmlUnknown. This may return null.
	*/
	TiXmlUnknown* ToUnknown() const		{ return ( ( node && node->ToUnknown() ) ? node->ToUnknown() : 0 ); }

	/** @deprecated use ToNode. 
		Return the handle as a TiXmlNode. This may return null.
	*/
	TiXmlNode* Node() const			{ return ToNode(); } 
	/** @deprecated use ToElement. 
		Return the handle as a TiXmlElement. This may return null.
	*/
	TiXmlElement* Element() const	{ return ToElement(); }
	/**	@deprecated use ToText()
		Return the handle as a TiXmlText. This may return null.
	*/
	TiXmlText* Text() const			{ return ToText(); }
	/** @deprecated use ToUnknown()
		Return the handle as a TiXmlUnknown. This may return null.
	*/
	TiXmlUnknown* Unknown() const	{ return ToUnknown(); }

private:
	TiXmlNode* node;
};


/** Print to memory functionality. The TiXmlPrinter is useful when you need to:

	-# Print to memory (especially in non-STL mode)
	-# Control formatting (line endings, etc.)

	When constructed, the TiXmlPrinter is in its default "pretty printing" mode.
	Before calling Accept() you can call methods to control the printing
	of the XML document. After TiXmlNode::Accept() is called, the printed document can
	be accessed via the CStr(), Str(), and Size() methods.

	TiXmlPrinter uses the Visitor API.
	@verbatim
	TiXmlPrinter printer;
	printer.SetIndent( "\t" );

	doc.Accept( &printer );
	fprintf( stdout, "%s", printer.CStr() );
	@endverbatim
*/
class TiXmlPrinter : public TiXmlVisitor
{
public:
	TiXmlPrinter() : depth( 0 ), simpleTextPrint( false ),
					 buffer(), indent( "    " ), lineBreak( "\n" ) {}

	virtual bool VisitEnter( const TiXmlDocument& doc );
	virtual bool VisitExit( const TiXmlDocument& doc );

	virtual bool VisitEnter( const TiXmlElement& element, const TiXmlAttribute* firstAttribute );
	virtual bool VisitExit( const TiXmlElement& element );

	virtual bool Visit( const TiXmlDeclaration& declaration );
	virtual bool Visit( const TiXmlText& text );
	virtual bool Visit( const TiXmlComment& comment );
	virtual bool Visit( const TiXmlUnknown& unknown );

	/** Set the indent characters for printing. By default 4 spaces
		but tab (\t) is also useful, or null/empty string for no indentation.
	*/
	void SetIndent( const char* _indent )			{ indent = _indent ? _indent : "" ; }
	/// Query the indention string.
	const char* Indent()							{ return indent.c_str(); }
	/** Set the line breaking string. By default set to newline (\n). 
		Some operating systems prefer other characters, or can be
		set to the null/empty string for no indenation.
	*/
	void SetLineBreak( const char* _lineBreak )		{ lineBreak = _lineBreak ? _lineBreak : ""; }
	/// Query the current line breaking string.
	const char* LineBreak()							{ return lineBreak.c_str(); }

	/** Switch over to "stream printing" which is the most dense formatting without 
		linebreaks. Common when the XML is needed for network transmission.
	*/
	void SetStreamPrinting()						{ indent = "";
													  lineBreak = "";
													}	
	/// Return the result.
	const char* CStr()								{ return buffer.c_str(); }
	/// Return the length of the result string.
	size_t Size()									{ return buffer.size(); }

	#ifdef TIXML_USE_STL
	/// Return the result.
	const std::string& Str()						{ return buffer; }
	#endif

private:
	void DoIndent()	{
		for( int i=0; i<depth; ++i )
			buffer += indent;
	}
	void DoLineBreak() {
		buffer += lineBreak;
	}

	int depth;
	bool simpleTextPrint;
	TIXML_STRING buffer;
	TIXML_STRING indent;
	TIXML_STRING lineBreak;
};


#ifdef _MSC_VER
#pragma warning( pop )
#endif

#endif

/*
www.sourceforge.net/projects/tinyxml
Original file by Yves Berquin.

This software is provided 'as-is', without any express or implied
warranty. In no event will the authors be held liable for any
damages arising from the use of this software.

Permission is granted to anyone to use this software for any
purpose, including commercial applications, and to alter it and
redistribute it freely, subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must
not claim that you wrote the original software. If you use this
software in a product, an acknowledgment in the product documentation
would be appreciated but is not required.

2. Altered source versions must be plainly marked as such, and
must not be misrepresented as being the original software.

3. This notice may not be removed or altered from any source
distribution.
*/

/*
 * THIS FILE WAS ALTERED BY Tyge L鴙set, 7. April 2005.
 */


#ifndef TIXML_USE_STL


// Error value for find primitive
const TiXmlString::size_type TiXmlString::npos = static_cast< TiXmlString::size_type >(-1);


// Null rep.
TiXmlString::Rep TiXmlString::nullrep_ = { 0, 0, { '\0' } };


void TiXmlString::reserve (size_type cap)
{
	if (cap > capacity())
	{
		TiXmlString tmp;
		tmp.init(length(), cap);
		memcpy(tmp.start(), data(), length());
		swap(tmp);
	}
}


TiXmlString& TiXmlString::assign(const char* str, size_type len)
{
	size_type cap = capacity();
	if (len > cap || cap > 3*(len + 8))
	{
		TiXmlString tmp;
		tmp.init(len);
		memcpy(tmp.start(), str, len);
		swap(tmp);
	}
	else
	{
		memmove(start(), str, len);
		set_size(len);
	}
	return *this;
}


TiXmlString& TiXmlString::append(const char* str, size_type len)
{
	size_type newsize = length() + len;
	if (newsize > capacity())
	{
		reserve (newsize + capacity());
	}
	memmove(finish(), str, len);
	set_size(newsize);
	return *this;
}


TiXmlString operator + (const TiXmlString & a, const TiXmlString & b)
{
	TiXmlString tmp;
	tmp.reserve(a.length() + b.length());
	tmp += a;
	tmp += b;
	return tmp;
}

TiXmlString operator + (const TiXmlString & a, const char* b)
{
	TiXmlString tmp;
	TiXmlString::size_type b_len = static_cast<TiXmlString::size_type>( strlen(b) );
	tmp.reserve(a.length() + b_len);
	tmp += a;
	tmp.append(b, b_len);
	return tmp;
}

TiXmlString operator + (const char* a, const TiXmlString & b)
{
	TiXmlString tmp;
	TiXmlString::size_type a_len = static_cast<TiXmlString::size_type>( strlen(a) );
	tmp.reserve(a_len + b.length());
	tmp.append(a, a_len);
	tmp += b;
	return tmp;
}


#endif	// TIXML_USE_STL
/*
www.sourceforge.net/projects/tinyxml
Original code (2.0 and earlier )copyright (c) 2000-2006 Lee Thomason (www.grinninglizard.com)

This software is provided 'as-is', without any express or implied
warranty. In no event will the authors be held liable for any
damages arising from the use of this software.

Permission is granted to anyone to use this software for any
purpose, including commercial applications, and to alter it and
redistribute it freely, subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must
not claim that you wrote the original software. If you use this
software in a product, an acknowledgment in the product documentation
would be appreciated but is not required.

2. Altered source versions must be plainly marked as such, and
must not be misrepresented as being the original software.

3. This notice may not be removed or altered from any source
distribution.
*/

#include <ctype.h>

#ifdef TIXML_USE_STL
#include <sstream>
#include <iostream>
#endif


FILE* TiXmlFOpen( const char* filename, const char* mode );

bool TiXmlBase::condenseWhiteSpace = true;

// Microsoft compiler security
FILE* TiXmlFOpen( const char* filename, const char* mode )
{
	#if defined(_MSC_VER) && (_MSC_VER >= 1400 )
		FILE* fp = 0;
		errno_t err = fopen_s( &fp, filename, mode );
		if ( !err && fp )
			return fp;
		return 0;
	#else
		return fopen( filename, mode );
	#endif
}

void TiXmlBase::EncodeString( const TIXML_STRING& str, TIXML_STRING* outString )
{
	int i=0;

	while( i<(int)str.length() )
	{
		unsigned char c = (unsigned char) str[i];

		if (    c == '&' 
		     && i < ( (int)str.length() - 2 )
			 && str[i+1] == '#'
			 && str[i+2] == 'x' )
		{
			// Hexadecimal character reference.
			// Pass through unchanged.
			// &#xA9;	-- copyright symbol, for example.
			//
			// The -1 is a bug fix from Rob Laveaux. It keeps
			// an overflow from happening if there is no ';'.
			// There are actually 2 ways to exit this loop -
			// while fails (error case) and break (semicolon found).
			// However, there is no mechanism (currently) for
			// this function to return an error.
			while ( i<(int)str.length()-1 )
			{
				outString->append( str.c_str() + i, 1 );
				++i;
				if ( str[i] == ';' )
					break;
			}
		}
		else if ( c == '&' )
		{
			outString->append( entity[0].str, entity[0].strLength );
			++i;
		}
		else if ( c == '<' )
		{
			outString->append( entity[1].str, entity[1].strLength );
			++i;
		}
		else if ( c == '>' )
		{
			outString->append( entity[2].str, entity[2].strLength );
			++i;
		}
		else if ( c == '\"' )
		{
			outString->append( entity[3].str, entity[3].strLength );
			++i;
		}
		else if ( c == '\'' )
		{
			outString->append( entity[4].str, entity[4].strLength );
			++i;
		}
		else if ( c < 32 )
		{
			// Easy pass at non-alpha/numeric/symbol
			// Below 32 is symbolic.
			char buf[ 32 ];
			
			#if defined(TIXML_SNPRINTF)		
				TIXML_SNPRINTF( buf, sizeof(buf), "&#x%02X;", (unsigned) ( c & 0xff ) );
			#else
				sprintf( buf, "&#x%02X;", (unsigned) ( c & 0xff ) );
			#endif		

			//*ME:	warning C4267: convert 'size_t' to 'int'
			//*ME:	Int-Cast to make compiler happy ...
			outString->append( buf, (int)strlen( buf ) );
			++i;
		}
		else
		{
			//char realc = (char) c;
			//outString->append( &realc, 1 );
			*outString += (char) c;	// somewhat more efficient function call.
			++i;
		}
	}
}


TiXmlNode::TiXmlNode( NodeType _type ) : TiXmlBase()
{
	parent = 0;
	type = _type;
	firstChild = 0;
	lastChild = 0;
	prev = 0;
	next = 0;
}


TiXmlNode::~TiXmlNode()
{
	TiXmlNode* node = firstChild;
	TiXmlNode* temp = 0;

	while ( node )
	{
		temp = node;
		node = node->next;
		delete temp;
	}	
}


void TiXmlNode::CopyTo( TiXmlNode* target ) const
{
	target->SetValue (value.c_str() );
	target->userData = userData; 
	target->location = location;
}


void TiXmlNode::Clear()
{
	TiXmlNode* node = firstChild;
	TiXmlNode* temp = 0;

	while ( node )
	{
		temp = node;
		node = node->next;
		delete temp;
	}	

	firstChild = 0;
	lastChild = 0;
}


TiXmlNode* TiXmlNode::LinkEndChild( TiXmlNode* node )
{
	assert( node->parent == 0 || node->parent == this );
	assert( node->GetDocument() == 0 || node->GetDocument() == this->GetDocument() );

	if ( node->Type() == TiXmlNode::TINYXML_DOCUMENT )
	{
		delete node;
		if ( GetDocument() ) GetDocument()->SetError( TIXML_ERROR_DOCUMENT_TOP_ONLY, 0, 0, TIXML_ENCODING_UNKNOWN );
		return 0;
	}

	node->parent = this;

	node->prev = lastChild;
	node->next = 0;

	if ( lastChild )
		lastChild->next = node;
	else
		firstChild = node;			// it was an empty list.

	lastChild = node;
	return node;
}


TiXmlNode* TiXmlNode::InsertEndChild( const TiXmlNode& addThis )
{
	if ( addThis.Type() == TiXmlNode::TINYXML_DOCUMENT )
	{
		if ( GetDocument() ) GetDocument()->SetError( TIXML_ERROR_DOCUMENT_TOP_ONLY, 0, 0, TIXML_ENCODING_UNKNOWN );
		return 0;
	}
	TiXmlNode* node = addThis.Clone();
	if ( !node )
		return 0;

	return LinkEndChild( node );
}


TiXmlNode* TiXmlNode::InsertBeforeChild( TiXmlNode* beforeThis, const TiXmlNode& addThis )
{	
	if ( !beforeThis || beforeThis->parent != this ) {
		return 0;
	}
	if ( addThis.Type() == TiXmlNode::TINYXML_DOCUMENT )
	{
		if ( GetDocument() ) GetDocument()->SetError( TIXML_ERROR_DOCUMENT_TOP_ONLY, 0, 0, TIXML_ENCODING_UNKNOWN );
		return 0;
	}

	TiXmlNode* node = addThis.Clone();
	if ( !node )
		return 0;
	node->parent = this;

	node->next = beforeThis;
	node->prev = beforeThis->prev;
	if ( beforeThis->prev )
	{
		beforeThis->prev->next = node;
	}
	else
	{
		assert( firstChild == beforeThis );
		firstChild = node;
	}
	beforeThis->prev = node;
	return node;
}


TiXmlNode* TiXmlNode::InsertAfterChild( TiXmlNode* afterThis, const TiXmlNode& addThis )
{
	if ( !afterThis || afterThis->parent != this ) {
		return 0;
	}
	if ( addThis.Type() == TiXmlNode::TINYXML_DOCUMENT )
	{
		if ( GetDocument() ) GetDocument()->SetError( TIXML_ERROR_DOCUMENT_TOP_ONLY, 0, 0, TIXML_ENCODING_UNKNOWN );
		return 0;
	}

	TiXmlNode* node = addThis.Clone();
	if ( !node )
		return 0;
	node->parent = this;

	node->prev = afterThis;
	node->next = afterThis->next;
	if ( afterThis->next )
	{
		afterThis->next->prev = node;
	}
	else
	{
		assert( lastChild == afterThis );
		lastChild = node;
	}
	afterThis->next = node;
	return node;
}


TiXmlNode* TiXmlNode::ReplaceChild( TiXmlNode* replaceThis, const TiXmlNode& withThis )
{
	if ( !replaceThis )
		return 0;

	if ( replaceThis->parent != this )
		return 0;

	if ( withThis.ToDocument() ) {
		// A document can never be a child.	Thanks to Noam.
		TiXmlDocument* document = GetDocument();
		if ( document ) 
			document->SetError( TIXML_ERROR_DOCUMENT_TOP_ONLY, 0, 0, TIXML_ENCODING_UNKNOWN );
		return 0;
	}

	TiXmlNode* node = withThis.Clone();
	if ( !node )
		return 0;

	node->next = replaceThis->next;
	node->prev = replaceThis->prev;

	if ( replaceThis->next )
		replaceThis->next->prev = node;
	else
		lastChild = node;

	if ( replaceThis->prev )
		replaceThis->prev->next = node;
	else
		firstChild = node;

	delete replaceThis;
	node->parent = this;
	return node;
}


bool TiXmlNode::RemoveChild( TiXmlNode* removeThis )
{
	if ( !removeThis ) {
		return false;
	}

	if ( removeThis->parent != this )
	{	
		assert( 0 );
		return false;
	}

	if ( removeThis->next )
		removeThis->next->prev = removeThis->prev;
	else
		lastChild = removeThis->prev;

	if ( removeThis->prev )
		removeThis->prev->next = removeThis->next;
	else
		firstChild = removeThis->next;

	delete removeThis;
	return true;
}

const TiXmlNode* TiXmlNode::FirstChild( const char * _value ) const
{
	const TiXmlNode* node;
	for ( node = firstChild; node; node = node->next )
	{
		if ( strcmp( node->Value(), _value ) == 0 )
			return node;
	}
	return 0;
}


const TiXmlNode* TiXmlNode::LastChild( const char * _value ) const
{
	const TiXmlNode* node;
	for ( node = lastChild; node; node = node->prev )
	{
		if ( strcmp( node->Value(), _value ) == 0 )
			return node;
	}
	return 0;
}


const TiXmlNode* TiXmlNode::IterateChildren( const TiXmlNode* previous ) const
{
	if ( !previous )
	{
		return FirstChild();
	}
	else
	{
		assert( previous->parent == this );
		return previous->NextSibling();
	}
}


const TiXmlNode* TiXmlNode::IterateChildren( const char * val, const TiXmlNode* previous ) const
{
	if ( !previous )
	{
		return FirstChild( val );
	}
	else
	{
		assert( previous->parent == this );
		return previous->NextSibling( val );
	}
}


const TiXmlNode* TiXmlNode::NextSibling( const char * _value ) const 
{
	const TiXmlNode* node;
	for ( node = next; node; node = node->next )
	{
		if ( strcmp( node->Value(), _value ) == 0 )
			return node;
	}
	return 0;
}


const TiXmlNode* TiXmlNode::PreviousSibling( const char * _value ) const
{
	const TiXmlNode* node;
	for ( node = prev; node; node = node->prev )
	{
		if ( strcmp( node->Value(), _value ) == 0 )
			return node;
	}
	return 0;
}


void TiXmlElement::RemoveAttribute( const char * name )
{
    #ifdef TIXML_USE_STL
	TIXML_STRING str( name );
	TiXmlAttribute* node = attributeSet.Find( str );
	#else
	TiXmlAttribute* node = attributeSet.Find( name );
	#endif
	if ( node )
	{
		attributeSet.Remove( node );
		delete node;
	}
}

const TiXmlElement* TiXmlNode::FirstChildElement() const
{
	const TiXmlNode* node;

	for (	node = FirstChild();
			node;
			node = node->NextSibling() )
	{
		if ( node->ToElement() )
			return node->ToElement();
	}
	return 0;
}


const TiXmlElement* TiXmlNode::FirstChildElement( const char * _value ) const
{
	const TiXmlNode* node;

	for (	node = FirstChild( _value );
			node;
			node = node->NextSibling( _value ) )
	{
		if ( node->ToElement() )
			return node->ToElement();
	}
	return 0;
}


const TiXmlElement* TiXmlNode::NextSiblingElement() const
{
	const TiXmlNode* node;

	for (	node = NextSibling();
			node;
			node = node->NextSibling() )
	{
		if ( node->ToElement() )
			return node->ToElement();
	}
	return 0;
}


const TiXmlElement* TiXmlNode::NextSiblingElement( const char * _value ) const
{
	const TiXmlNode* node;

	for (	node = NextSibling( _value );
			node;
			node = node->NextSibling( _value ) )
	{
		if ( node->ToElement() )
			return node->ToElement();
	}
	return 0;
}


const TiXmlDocument* TiXmlNode::GetDocument() const
{
	const TiXmlNode* node;

	for( node = this; node; node = node->parent )
	{
		if ( node->ToDocument() )
			return node->ToDocument();
	}
	return 0;
}


TiXmlElement::TiXmlElement (const char * _value)
	: TiXmlNode( TiXmlNode::TINYXML_ELEMENT )
{
	firstChild = lastChild = 0;
	value = _value;
}


#ifdef TIXML_USE_STL
TiXmlElement::TiXmlElement( const std::string& _value ) 
	: TiXmlNode( TiXmlNode::TINYXML_ELEMENT )
{
	firstChild = lastChild = 0;
	value = _value;
}
#endif


TiXmlElement::TiXmlElement( const TiXmlElement& copy)
	: TiXmlNode( TiXmlNode::TINYXML_ELEMENT )
{
	firstChild = lastChild = 0;
	copy.CopyTo( this );	
}


void TiXmlElement::operator=( const TiXmlElement& base )
{
	ClearThis();
	base.CopyTo( this );
}


TiXmlElement::~TiXmlElement()
{
	ClearThis();
}


void TiXmlElement::ClearThis()
{
	Clear();
	while( attributeSet.First() )
	{
		TiXmlAttribute* node = attributeSet.First();
		attributeSet.Remove( node );
		delete node;
	}
}


const char* TiXmlElement::Attribute( const char* name ) const
{
	const TiXmlAttribute* node = attributeSet.Find( name );
	if ( node )
		return node->Value();
	return 0;
}


#ifdef TIXML_USE_STL
const std::string* TiXmlElement::Attribute( const std::string& name ) const
{
	const TiXmlAttribute* attrib = attributeSet.Find( name );
	if ( attrib )
		return &attrib->ValueStr();
	return 0;
}
#endif


const char* TiXmlElement::Attribute( const char* name, int* i ) const
{
	const TiXmlAttribute* attrib = attributeSet.Find( name );
	const char* result = 0;

	if ( attrib ) {
		result = attrib->Value();
		if ( i ) {
			attrib->QueryIntValue( i );
		}
	}
	return result;
}


#ifdef TIXML_USE_STL
const std::string* TiXmlElement::Attribute( const std::string& name, int* i ) const
{
	const TiXmlAttribute* attrib = attributeSet.Find( name );
	const std::string* result = 0;

	if ( attrib ) {
		result = &attrib->ValueStr();
		if ( i ) {
			attrib->QueryIntValue( i );
		}
	}
	return result;
}
#endif


const char* TiXmlElement::Attribute( const char* name, double* d ) const
{
	const TiXmlAttribute* attrib = attributeSet.Find( name );
	const char* result = 0;

	if ( attrib ) {
		result = attrib->Value();
		if ( d ) {
			attrib->QueryDoubleValue( d );
		}
	}
	return result;
}


#ifdef TIXML_USE_STL
const std::string* TiXmlElement::Attribute( const std::string& name, double* d ) const
{
	const TiXmlAttribute* attrib = attributeSet.Find( name );
	const std::string* result = 0;

	if ( attrib ) {
		result = &attrib->ValueStr();
		if ( d ) {
			attrib->QueryDoubleValue( d );
		}
	}
	return result;
}
#endif


int TiXmlElement::QueryIntAttribute( const char* name, int* ival ) const
{
	const TiXmlAttribute* attrib = attributeSet.Find( name );
	if ( !attrib )
		return TIXML_NO_ATTRIBUTE;
	return attrib->QueryIntValue( ival );
}


#ifdef TIXML_USE_STL
int TiXmlElement::QueryIntAttribute( const std::string& name, int* ival ) const
{
	const TiXmlAttribute* attrib = attributeSet.Find( name );
	if ( !attrib )
		return TIXML_NO_ATTRIBUTE;
	return attrib->QueryIntValue( ival );
}
#endif


int TiXmlElement::QueryDoubleAttribute( const char* name, double* dval ) const
{
	const TiXmlAttribute* attrib = attributeSet.Find( name );
	if ( !attrib )
		return TIXML_NO_ATTRIBUTE;
	return attrib->QueryDoubleValue( dval );
}


#ifdef TIXML_USE_STL
int TiXmlElement::QueryDoubleAttribute( const std::string& name, double* dval ) const
{
	const TiXmlAttribute* attrib = attributeSet.Find( name );
	if ( !attrib )
		return TIXML_NO_ATTRIBUTE;
	return attrib->QueryDoubleValue( dval );
}
#endif


void TiXmlElement::SetAttribute( const char * name, int val )
{	
	TiXmlAttribute* attrib = attributeSet.FindOrCreate( name );
	if ( attrib ) {
		attrib->SetIntValue( val );
	}
}


#ifdef TIXML_USE_STL
void TiXmlElement::SetAttribute( const std::string& name, int val )
{	
	TiXmlAttribute* attrib = attributeSet.FindOrCreate( name );
	if ( attrib ) {
		attrib->SetIntValue( val );
	}
}
#endif


void TiXmlElement::SetDoubleAttribute( const char * name, double val )
{	
	TiXmlAttribute* attrib = attributeSet.FindOrCreate( name );
	if ( attrib ) {
		attrib->SetDoubleValue( val );
	}
}


#ifdef TIXML_USE_STL
void TiXmlElement::SetDoubleAttribute( const std::string& name, double val )
{	
	TiXmlAttribute* attrib = attributeSet.FindOrCreate( name );
	if ( attrib ) {
		attrib->SetDoubleValue( val );
	}
}
#endif 


void TiXmlElement::SetAttribute( const char * cname, const char * cvalue )
{
	TiXmlAttribute* attrib = attributeSet.FindOrCreate( cname );
	if ( attrib ) {
		attrib->SetValue( cvalue );
	}
}


#ifdef TIXML_USE_STL
void TiXmlElement::SetAttribute( const std::string& _name, const std::string& _value )
{
	TiXmlAttribute* attrib = attributeSet.FindOrCreate( _name );
	if ( attrib ) {
		attrib->SetValue( _value );
	}
}
#endif


void TiXmlElement::Print( FILE* cfile, int depth ) const
{
	int i;
	assert( cfile );
	for ( i=0; i<depth; i++ ) {
		fprintf( cfile, "    " );
	}

	fprintf( cfile, "<%s", value.c_str() );

	const TiXmlAttribute* attrib;
	for ( attrib = attributeSet.First(); attrib; attrib = attrib->Next() )
	{
		fprintf( cfile, " " );
		attrib->Print( cfile, depth );
	}

	// There are 3 different formatting approaches:
	// 1) An element without children is printed as a <foo /> node
	// 2) An element with only a text child is printed as <foo> text </foo>
	// 3) An element with children is printed on multiple lines.
	TiXmlNode* node;
	if ( !firstChild )
	{
		fprintf( cfile, " />" );
	}
	else if ( firstChild == lastChild && firstChild->ToText() )
	{
		fprintf( cfile, ">" );
		firstChild->Print( cfile, depth + 1 );
		fprintf( cfile, "</%s>", value.c_str() );
	}
	else
	{
		fprintf( cfile, ">" );

		for ( node = firstChild; node; node=node->NextSibling() )
		{
			if ( !node->ToText() )
			{
				fprintf( cfile, "\n" );
			}
			node->Print( cfile, depth+1 );
		}
		fprintf( cfile, "\n" );
		for( i=0; i<depth; ++i ) {
			fprintf( cfile, "    " );
		}
		fprintf( cfile, "</%s>", value.c_str() );
	}
}


void TiXmlElement::CopyTo( TiXmlElement* target ) const
{
	// superclass:
	TiXmlNode::CopyTo( target );

	// Element class: 
	// Clone the attributes, then clone the children.
	const TiXmlAttribute* attribute = 0;
	for(	attribute = attributeSet.First();
	attribute;
	attribute = attribute->Next() )
	{
		target->SetAttribute( attribute->Name(), attribute->Value() );
	}

	TiXmlNode* node = 0;
	for ( node = firstChild; node; node = node->NextSibling() )
	{
		target->LinkEndChild( node->Clone() );
	}
}

bool TiXmlElement::Accept( TiXmlVisitor* visitor ) const
{
	if ( visitor->VisitEnter( *this, attributeSet.First() ) ) 
	{
		for ( const TiXmlNode* node=FirstChild(); node; node=node->NextSibling() )
		{
			if ( !node->Accept( visitor ) )
				break;
		}
	}
	return visitor->VisitExit( *this );
}


TiXmlNode* TiXmlElement::Clone() const
{
	TiXmlElement* clone = new TiXmlElement( Value() );
	if ( !clone )
		return 0;

	CopyTo( clone );
	return clone;
}


const char* TiXmlElement::GetText() const
{
	const TiXmlNode* child = this->FirstChild();
	if ( child ) {
		const TiXmlText* childText = child->ToText();
		if ( childText ) {
			return childText->Value();
		}
	}
	return 0;
}


TiXmlDocument::TiXmlDocument() : TiXmlNode( TiXmlNode::TINYXML_DOCUMENT )
{
	tabsize = 4;
	useMicrosoftBOM = false;
	ClearError();
}

TiXmlDocument::TiXmlDocument( const char * documentName ) : TiXmlNode( TiXmlNode::TINYXML_DOCUMENT )
{
	tabsize = 4;
	useMicrosoftBOM = false;
	value = documentName;
	ClearError();
}


#ifdef TIXML_USE_STL
TiXmlDocument::TiXmlDocument( const std::string& documentName ) : TiXmlNode( TiXmlNode::TINYXML_DOCUMENT )
{
	tabsize = 4;
	useMicrosoftBOM = false;
    value = documentName;
	ClearError();
}
#endif


TiXmlDocument::TiXmlDocument( const TiXmlDocument& copy ) : TiXmlNode( TiXmlNode::TINYXML_DOCUMENT )
{
	copy.CopyTo( this );
}


void TiXmlDocument::operator=( const TiXmlDocument& copy )
{
	Clear();
	copy.CopyTo( this );
}


bool TiXmlDocument::LoadFile( TiXmlEncoding encoding )
{
	return LoadFile( Value(), encoding );
}


bool TiXmlDocument::SaveFile() const
{
	return SaveFile( Value() );
}

bool TiXmlDocument::LoadFile( const char* _filename, TiXmlEncoding encoding )
{
	TIXML_STRING filename( _filename );
	value = filename;

	// reading in binary mode so that tinyxml can normalize the EOL
	FILE* file = TiXmlFOpen( value.c_str (), "rb" );	

	if ( file )
	{
		bool result = LoadFile( file, encoding );
		fclose( file );
		return result;
	}
	else
	{
		SetError( TIXML_ERROR_OPENING_FILE, 0, 0, TIXML_ENCODING_UNKNOWN );
		return false;
	}
}

bool TiXmlDocument::LoadFile( FILE* file, TiXmlEncoding encoding )
{
	if ( !file ) 
	{
		SetError( TIXML_ERROR_OPENING_FILE, 0, 0, TIXML_ENCODING_UNKNOWN );
		return false;
	}

	// Delete the existing data:
	Clear();
	location.Clear();

	// Get the file size, so we can pre-allocate the string. HUGE speed impact.
	long length = 0;
	fseek( file, 0, SEEK_END );
	length = ftell( file );
	fseek( file, 0, SEEK_SET );

	// Strange case, but good to handle up front.
	if ( length <= 0 )
	{
		SetError( TIXML_ERROR_DOCUMENT_EMPTY, 0, 0, TIXML_ENCODING_UNKNOWN );
		return false;
	}

	// Subtle bug here. TinyXml did use fgets. But from the XML spec:
	// 2.11 End-of-Line Handling
	// <snip>
	// <quote>
	// ...the XML processor MUST behave as if it normalized all line breaks in external 
	// parsed entities (including the document entity) on input, before parsing, by translating 
	// both the two-character sequence #xD #xA and any #xD that is not followed by #xA to 
	// a single #xA character.
	// </quote>
	//
	// It is not clear fgets does that, and certainly isn't clear it works cross platform. 
	// Generally, you expect fgets to translate from the convention of the OS to the c/unix
	// convention, and not work generally.

	/*
	while( fgets( buf, sizeof(buf), file ) )
	{
		data += buf;
	}
	*/

	char* buf = new char[ length+1 ];
	buf[0] = 0;

	if ( fread( buf, length, 1, file ) != 1 ) {
		delete [] buf;
		SetError( TIXML_ERROR_OPENING_FILE, 0, 0, TIXML_ENCODING_UNKNOWN );
		return false;
	}

	// Process the buffer in place to normalize new lines. (See comment above.)
	// Copies from the 'p' to 'q' pointer, where p can advance faster if
	// a newline-carriage return is hit.
	//
	// Wikipedia:
	// Systems based on ASCII or a compatible character set use either LF  (Line feed, '\n', 0x0A, 10 in decimal) or 
	// CR (Carriage return, '\r', 0x0D, 13 in decimal) individually, or CR followed by LF (CR+LF, 0x0D 0x0A)...
	//		* LF:    Multics, Unix and Unix-like systems (GNU/Linux, AIX, Xenix, Mac OS X, FreeBSD, etc.), BeOS, Amiga, RISC OS, and others
    //		* CR+LF: DEC RT-11 and most other early non-Unix, non-IBM OSes, CP/M, MP/M, DOS, OS/2, Microsoft Windows, Symbian OS
    //		* CR:    Commodore 8-bit machines, Apple II family, Mac OS up to version 9 and OS-9

	const char* p = buf;	// the read head
	char* q = buf;			// the write head
	const char CR = 0x0d;
	const char LF = 0x0a;

	buf[length] = 0;
	while( *p ) {
		assert( p < (buf+length) );
		assert( q <= (buf+length) );
		assert( q <= p );

		if ( *p == CR ) {
			*q++ = LF;
			p++;
			if ( *p == LF ) {		// check for CR+LF (and skip LF)
				p++;
			}
		}
		else {
			*q++ = *p++;
		}
	}
	assert( q <= (buf+length) );
	*q = 0;

	Parse( buf, 0, encoding );

	delete [] buf;
	return !Error();
}


bool TiXmlDocument::SaveFile( const char * filename ) const
{
	// The old c stuff lives on...
	FILE* fp = TiXmlFOpen( filename, "w" );
	if ( fp )
	{
		bool result = SaveFile( fp );
		fclose( fp );
		return result;
	}
	return false;
}


bool TiXmlDocument::SaveFile( FILE* fp ) const
{
	if ( useMicrosoftBOM ) 
	{
		const unsigned char TIXML_UTF_LEAD_0 = 0xefU;
		const unsigned char TIXML_UTF_LEAD_1 = 0xbbU;
		const unsigned char TIXML_UTF_LEAD_2 = 0xbfU;

		fputc( TIXML_UTF_LEAD_0, fp );
		fputc( TIXML_UTF_LEAD_1, fp );
		fputc( TIXML_UTF_LEAD_2, fp );
	}
	Print( fp, 0 );
	return (ferror(fp) == 0);
}


void TiXmlDocument::CopyTo( TiXmlDocument* target ) const
{
	TiXmlNode::CopyTo( target );

	target->error = error;
	target->errorId = errorId;
	target->errorDesc = errorDesc;
	target->tabsize = tabsize;
	target->errorLocation = errorLocation;
	target->useMicrosoftBOM = useMicrosoftBOM;

	TiXmlNode* node = 0;
	for ( node = firstChild; node; node = node->NextSibling() )
	{
		target->LinkEndChild( node->Clone() );
	}	
}


TiXmlNode* TiXmlDocument::Clone() const
{
	TiXmlDocument* clone = new TiXmlDocument();
	if ( !clone )
		return 0;

	CopyTo( clone );
	return clone;
}


void TiXmlDocument::Print( FILE* cfile, int depth ) const
{
	assert( cfile );
	for ( const TiXmlNode* node=FirstChild(); node; node=node->NextSibling() )
	{
		node->Print( cfile, depth );
		fprintf( cfile, "\n" );
	}
}


bool TiXmlDocument::Accept( TiXmlVisitor* visitor ) const
{
	if ( visitor->VisitEnter( *this ) )
	{
		for ( const TiXmlNode* node=FirstChild(); node; node=node->NextSibling() )
		{
			if ( !node->Accept( visitor ) )
				break;
		}
	}
	return visitor->VisitExit( *this );
}


const TiXmlAttribute* TiXmlAttribute::Next() const
{
	// We are using knowledge of the sentinel. The sentinel
	// have a value or name.
	if ( next->value.empty() && next->name.empty() )
		return 0;
	return next;
}

/*
TiXmlAttribute* TiXmlAttribute::Next()
{
	// We are using knowledge of the sentinel. The sentinel
	// have a value or name.
	if ( next->value.empty() && next->name.empty() )
		return 0;
	return next;
}
*/

const TiXmlAttribute* TiXmlAttribute::Previous() const
{
	// We are using knowledge of the sentinel. The sentinel
	// have a value or name.
	if ( prev->value.empty() && prev->name.empty() )
		return 0;
	return prev;
}

/*
TiXmlAttribute* TiXmlAttribute::Previous()
{
	// We are using knowledge of the sentinel. The sentinel
	// have a value or name.
	if ( prev->value.empty() && prev->name.empty() )
		return 0;
	return prev;
}
*/

void TiXmlAttribute::Print( FILE* cfile, int /*depth*/, TIXML_STRING* str ) const
{
	TIXML_STRING n, v;

	EncodeString( name, &n );
	EncodeString( value, &v );

	if (value.find ('\"') == TIXML_STRING::npos) {
		if ( cfile ) {
		fprintf (cfile, "%s=\"%s\"", n.c_str(), v.c_str() );
		}
		if ( str ) {
			(*str) += n; (*str) += "=\""; (*str) += v; (*str) += "\"";
		}
	}
	else {
		if ( cfile ) {
		fprintf (cfile, "%s='%s'", n.c_str(), v.c_str() );
		}
		if ( str ) {
			(*str) += n; (*str) += "='"; (*str) += v; (*str) += "'";
		}
	}
}


int TiXmlAttribute::QueryIntValue( int* ival ) const
{
	if ( TIXML_SSCANF( value.c_str(), "%d", ival ) == 1 )
		return TIXML_SUCCESS;
	return TIXML_WRONG_TYPE;
}

int TiXmlAttribute::QueryDoubleValue( double* dval ) const
{
	if ( TIXML_SSCANF( value.c_str(), "%lf", dval ) == 1 )
		return TIXML_SUCCESS;
	return TIXML_WRONG_TYPE;
}

void TiXmlAttribute::SetIntValue( int _value )
{
	char buf [64];
	#if defined(TIXML_SNPRINTF)		
		TIXML_SNPRINTF(buf, sizeof(buf), "%d", _value);
	#else
		sprintf (buf, "%d", _value);
	#endif
	SetValue (buf);
}

void TiXmlAttribute::SetDoubleValue( double _value )
{
	char buf [256];
	#if defined(TIXML_SNPRINTF)		
		TIXML_SNPRINTF( buf, sizeof(buf), "%g", _value);
	#else
		sprintf (buf, "%g", _value);
	#endif
	SetValue (buf);
}

int TiXmlAttribute::IntValue() const
{
	return atoi (value.c_str ());
}

double  TiXmlAttribute::DoubleValue() const
{
	return atof (value.c_str ());
}


TiXmlComment::TiXmlComment( const TiXmlComment& copy ) : TiXmlNode( TiXmlNode::TINYXML_COMMENT )
{
	copy.CopyTo( this );
}


void TiXmlComment::operator=( const TiXmlComment& base )
{
	Clear();
	base.CopyTo( this );
}


void TiXmlComment::Print( FILE* cfile, int depth ) const
{
	assert( cfile );
	for ( int i=0; i<depth; i++ )
	{
		fprintf( cfile,  "    " );
	}
	fprintf( cfile, "<!--%s-->", value.c_str() );
}


void TiXmlComment::CopyTo( TiXmlComment* target ) const
{
	TiXmlNode::CopyTo( target );
}


bool TiXmlComment::Accept( TiXmlVisitor* visitor ) const
{
	return visitor->Visit( *this );
}


TiXmlNode* TiXmlComment::Clone() const
{
	TiXmlComment* clone = new TiXmlComment();

	if ( !clone )
		return 0;

	CopyTo( clone );
	return clone;
}


void TiXmlText::Print( FILE* cfile, int depth ) const
{
	assert( cfile );
	if ( cdata )
	{
		int i;
		fprintf( cfile, "\n" );
		for ( i=0; i<depth; i++ ) {
			fprintf( cfile, "    " );
		}
		fprintf( cfile, "<![CDATA[%s]]>\n", value.c_str() );	// unformatted output
	}
	else
	{
		TIXML_STRING buffer;
		EncodeString( value, &buffer );
		fprintf( cfile, "%s", buffer.c_str() );
	}
}


void TiXmlText::CopyTo( TiXmlText* target ) const
{
	TiXmlNode::CopyTo( target );
	target->cdata = cdata;
}


bool TiXmlText::Accept( TiXmlVisitor* visitor ) const
{
	return visitor->Visit( *this );
}


TiXmlNode* TiXmlText::Clone() const
{	
	TiXmlText* clone = 0;
	clone = new TiXmlText( "" );

	if ( !clone )
		return 0;

	CopyTo( clone );
	return clone;
}


TiXmlDeclaration::TiXmlDeclaration( const char * _version,
									const char * _encoding,
									const char * _standalone )
	: TiXmlNode( TiXmlNode::TINYXML_DECLARATION )
{
	version = _version;
	encoding = _encoding;
	standalone = _standalone;
}


#ifdef TIXML_USE_STL
TiXmlDeclaration::TiXmlDeclaration(	const std::string& _version,
									const std::string& _encoding,
									const std::string& _standalone )
	: TiXmlNode( TiXmlNode::TINYXML_DECLARATION )
{
	version = _version;
	encoding = _encoding;
	standalone = _standalone;
}
#endif


TiXmlDeclaration::TiXmlDeclaration( const TiXmlDeclaration& copy )
	: TiXmlNode( TiXmlNode::TINYXML_DECLARATION )
{
	copy.CopyTo( this );	
}


void TiXmlDeclaration::operator=( const TiXmlDeclaration& copy )
{
	Clear();
	copy.CopyTo( this );
}


void TiXmlDeclaration::Print( FILE* cfile, int /*depth*/, TIXML_STRING* str ) const
{
	if ( cfile ) fprintf( cfile, "<?xml " );
	if ( str )	 (*str) += "<?xml ";

	if ( !version.empty() ) {
		if ( cfile ) fprintf (cfile, "version=\"%s\" ", version.c_str ());
		if ( str ) { (*str) += "version=\""; (*str) += version; (*str) += "\" "; }
	}
	if ( !encoding.empty() ) {
		if ( cfile ) fprintf (cfile, "encoding=\"%s\" ", encoding.c_str ());
		if ( str ) { (*str) += "encoding=\""; (*str) += encoding; (*str) += "\" "; }
	}
	if ( !standalone.empty() ) {
		if ( cfile ) fprintf (cfile, "standalone=\"%s\" ", standalone.c_str ());
		if ( str ) { (*str) += "standalone=\""; (*str) += standalone; (*str) += "\" "; }
	}
	if ( cfile ) fprintf( cfile, "?>" );
	if ( str )	 (*str) += "?>";
}


void TiXmlDeclaration::CopyTo( TiXmlDeclaration* target ) const
{
	TiXmlNode::CopyTo( target );

	target->version = version;
	target->encoding = encoding;
	target->standalone = standalone;
}


bool TiXmlDeclaration::Accept( TiXmlVisitor* visitor ) const
{
	return visitor->Visit( *this );
}


TiXmlNode* TiXmlDeclaration::Clone() const
{	
	TiXmlDeclaration* clone = new TiXmlDeclaration();

	if ( !clone )
		return 0;

	CopyTo( clone );
	return clone;
}


void TiXmlUnknown::Print( FILE* cfile, int depth ) const
{
	for ( int i=0; i<depth; i++ )
		fprintf( cfile, "    " );
	fprintf( cfile, "<%s>", value.c_str() );
}


void TiXmlUnknown::CopyTo( TiXmlUnknown* target ) const
{
	TiXmlNode::CopyTo( target );
}


bool TiXmlUnknown::Accept( TiXmlVisitor* visitor ) const
{
	return visitor->Visit( *this );
}


TiXmlNode* TiXmlUnknown::Clone() const
{
	TiXmlUnknown* clone = new TiXmlUnknown();

	if ( !clone )
		return 0;

	CopyTo( clone );
	return clone;
}


TiXmlAttributeSet::TiXmlAttributeSet()
{
	sentinel.next = &sentinel;
	sentinel.prev = &sentinel;
}


TiXmlAttributeSet::~TiXmlAttributeSet()
{
	assert( sentinel.next == &sentinel );
	assert( sentinel.prev == &sentinel );
}


void TiXmlAttributeSet::Add( TiXmlAttribute* addMe )
{
    #ifdef TIXML_USE_STL
	assert( !Find( TIXML_STRING( addMe->Name() ) ) );	// Shouldn't be multiply adding to the set.
	#else
	assert( !Find( addMe->Name() ) );	// Shouldn't be multiply adding to the set.
	#endif

	addMe->next = &sentinel;
	addMe->prev = sentinel.prev;

	sentinel.prev->next = addMe;
	sentinel.prev      = addMe;
}

void TiXmlAttributeSet::Remove( TiXmlAttribute* removeMe )
{
	TiXmlAttribute* node;

	for( node = sentinel.next; node != &sentinel; node = node->next )
	{
		if ( node == removeMe )
		{
			node->prev->next = node->next;
			node->next->prev = node->prev;
			node->next = 0;
			node->prev = 0;
			return;
		}
	}
	assert( 0 );		// we tried to remove a non-linked attribute.
}


#ifdef TIXML_USE_STL
TiXmlAttribute* TiXmlAttributeSet::Find( const std::string& name ) const
{
	for( TiXmlAttribute* node = sentinel.next; node != &sentinel; node = node->next )
	{
		if ( node->name == name )
			return node;
	}
	return 0;
}

TiXmlAttribute* TiXmlAttributeSet::FindOrCreate( const std::string& _name )
{
	TiXmlAttribute* attrib = Find( _name );
	if ( !attrib ) {
		attrib = new TiXmlAttribute();
		Add( attrib );
		attrib->SetName( _name );
	}
	return attrib;
}
#endif


TiXmlAttribute* TiXmlAttributeSet::Find( const char* name ) const
{
	for( TiXmlAttribute* node = sentinel.next; node != &sentinel; node = node->next )
	{
		if ( strcmp( node->name.c_str(), name ) == 0 )
			return node;
	}
	return 0;
}


TiXmlAttribute* TiXmlAttributeSet::FindOrCreate( const char* _name )
{
	TiXmlAttribute* attrib = Find( _name );
	if ( !attrib ) {
		attrib = new TiXmlAttribute();
		Add( attrib );
		attrib->SetName( _name );
	}
	return attrib;
}


#ifdef TIXML_USE_STL	
std::istream& operator>> (std::istream & in, TiXmlNode & base)
{
	TIXML_STRING tag;
	tag.reserve( 8 * 1000 );
	base.StreamIn( &in, &tag );

	base.Parse( tag.c_str(), 0, TIXML_DEFAULT_ENCODING );
	return in;
}
#endif


#ifdef TIXML_USE_STL	
std::ostream& operator<< (std::ostream & out, const TiXmlNode & base)
{
	TiXmlPrinter printer;
	printer.SetStreamPrinting();
	base.Accept( &printer );
	out << printer.Str();

	return out;
}


std::string& operator<< (std::string& out, const TiXmlNode& base )
{
	TiXmlPrinter printer;
	printer.SetStreamPrinting();
	base.Accept( &printer );
	out.append( printer.Str() );

	return out;
}
#endif


TiXmlHandle TiXmlHandle::FirstChild() const
{
	if ( node )
	{
		TiXmlNode* child = node->FirstChild();
		if ( child )
			return TiXmlHandle( child );
	}
	return TiXmlHandle( 0 );
}


TiXmlHandle TiXmlHandle::FirstChild( const char * value ) const
{
	if ( node )
	{
		TiXmlNode* child = node->FirstChild( value );
		if ( child )
			return TiXmlHandle( child );
	}
	return TiXmlHandle( 0 );
}


TiXmlHandle TiXmlHandle::FirstChildElement() const
{
	if ( node )
	{
		TiXmlElement* child = node->FirstChildElement();
		if ( child )
			return TiXmlHandle( child );
	}
	return TiXmlHandle( 0 );
}


TiXmlHandle TiXmlHandle::FirstChildElement( const char * value ) const
{
	if ( node )
	{
		TiXmlElement* child = node->FirstChildElement( value );
		if ( child )
			return TiXmlHandle( child );
	}
	return TiXmlHandle( 0 );
}


TiXmlHandle TiXmlHandle::Child( int count ) const
{
	if ( node )
	{
		int i;
		TiXmlNode* child = node->FirstChild();
		for (	i=0;
				child && i<count;
				child = child->NextSibling(), ++i )
		{
			// nothing
		}
		if ( child )
			return TiXmlHandle( child );
	}
	return TiXmlHandle( 0 );
}


TiXmlHandle TiXmlHandle::Child( const char* value, int count ) const
{
	if ( node )
	{
		int i;
		TiXmlNode* child = node->FirstChild( value );
		for (	i=0;
				child && i<count;
				child = child->NextSibling( value ), ++i )
		{
			// nothing
		}
		if ( child )
			return TiXmlHandle( child );
	}
	return TiXmlHandle( 0 );
}


TiXmlHandle TiXmlHandle::ChildElement( int count ) const
{
	if ( node )
	{
		int i;
		TiXmlElement* child = node->FirstChildElement();
		for (	i=0;
				child && i<count;
				child = child->NextSiblingElement(), ++i )
		{
			// nothing
		}
		if ( child )
			return TiXmlHandle( child );
	}
	return TiXmlHandle( 0 );
}


TiXmlHandle TiXmlHandle::ChildElement( const char* value, int count ) const
{
	if ( node )
	{
		int i;
		TiXmlElement* child = node->FirstChildElement( value );
		for (	i=0;
				child && i<count;
				child = child->NextSiblingElement( value ), ++i )
		{
			// nothing
		}
		if ( child )
			return TiXmlHandle( child );
	}
	return TiXmlHandle( 0 );
}


bool TiXmlPrinter::VisitEnter( const TiXmlDocument& )
{
	return true;
}

bool TiXmlPrinter::VisitExit( const TiXmlDocument& )
{
	return true;
}

bool TiXmlPrinter::VisitEnter( const TiXmlElement& element, const TiXmlAttribute* firstAttribute )
{
	DoIndent();
	buffer += "<";
	buffer += element.Value();

	for( const TiXmlAttribute* attrib = firstAttribute; attrib; attrib = attrib->Next() )
	{
		buffer += " ";
		attrib->Print( 0, 0, &buffer );
	}

	if ( !element.FirstChild() ) 
	{
		buffer += " />";
		DoLineBreak();
	}
	else 
	{
		buffer += ">";
		if (    element.FirstChild()->ToText()
			  && element.LastChild() == element.FirstChild()
			  && element.FirstChild()->ToText()->CDATA() == false )
		{
			simpleTextPrint = true;
			// no DoLineBreak()!
		}
		else
		{
			DoLineBreak();
		}
	}
	++depth;	
	return true;
}


bool TiXmlPrinter::VisitExit( const TiXmlElement& element )
{
	--depth;
	if ( !element.FirstChild() ) 
	{
		// nothing.
	}
	else 
	{
		if ( simpleTextPrint )
		{
			simpleTextPrint = false;
		}
		else
		{
			DoIndent();
		}
		buffer += "</";
		buffer += element.Value();
		buffer += ">";
		DoLineBreak();
	}
	return true;
}


bool TiXmlPrinter::Visit( const TiXmlText& text )
{
	if ( text.CDATA() )
	{
		DoIndent();
		buffer += "<![CDATA[";
		buffer += text.Value();
		buffer += "]]>";
		DoLineBreak();
	}
	else if ( simpleTextPrint )
	{
		TIXML_STRING str;
		TiXmlBase::EncodeString( text.ValueTStr(), &str );
		buffer += str;
	}
	else
	{
		DoIndent();
		TIXML_STRING str;
		TiXmlBase::EncodeString( text.ValueTStr(), &str );
		buffer += str;
		DoLineBreak();
	}
	return true;
}


bool TiXmlPrinter::Visit( const TiXmlDeclaration& declaration )
{
	DoIndent();
	declaration.Print( 0, 0, &buffer );
	DoLineBreak();
	return true;
}


bool TiXmlPrinter::Visit( const TiXmlComment& comment )
{
	DoIndent();
	buffer += "<!--";
	buffer += comment.Value();
	buffer += "-->";
	DoLineBreak();
	return true;
}


bool TiXmlPrinter::Visit( const TiXmlUnknown& unknown )
{
	DoIndent();
	buffer += "<";
	buffer += unknown.Value();
	buffer += ">";
	DoLineBreak();
	return true;
}

/*
www.sourceforge.net/projects/tinyxml
Original code (2.0 and earlier )copyright (c) 2000-2006 Lee Thomason (www.grinninglizard.com)

This software is provided 'as-is', without any express or implied 
warranty. In no event will the authors be held liable for any 
damages arising from the use of this software.

Permission is granted to anyone to use this software for any 
purpose, including commercial applications, and to alter it and 
redistribute it freely, subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must
not claim that you wrote the original software. If you use this
software in a product, an acknowledgment in the product documentation
would be appreciated but is not required.

2. Altered source versions must be plainly marked as such, and
must not be misrepresented as being the original software.

3. This notice may not be removed or altered from any source
distribution.
*/

// The goal of the seperate error file is to make the first
// step towards localization. tinyxml (currently) only supports
// english error messages, but the could now be translated.
//
// It also cleans up the code a bit.
//

const char* TiXmlBase::errorString[ TIXML_ERROR_STRING_COUNT ] =
{
	"No error",
	"Error",
	"Failed to open file",
	"Error parsing Element.",
	"Failed to read Element name",
	"Error reading Element value.",
	"Error reading Attributes.",
	"Error: empty tag.",
	"Error reading end tag.",
	"Error parsing Unknown.",
	"Error parsing Comment.",
	"Error parsing Declaration.",
	"Error document empty.",
	"Error null (0) or unexpected EOF found in input stream.",
	"Error parsing CDATA.",
	"Error when TiXmlDocument added to document, because TiXmlDocument can only be at the root.",
};
/*
www.sourceforge.net/projects/tinyxml
Original code (2.0 and earlier )copyright (c) 2000-2002 Lee Thomason (www.grinninglizard.com)

This software is provided 'as-is', without any express or implied 
warranty. In no event will the authors be held liable for any 
damages arising from the use of this software.

Permission is granted to anyone to use this software for any 
purpose, including commercial applications, and to alter it and 
redistribute it freely, subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must 
not claim that you wrote the original software. If you use this
software in a product, an acknowledgment in the product documentation
would be appreciated but is not required.

2. Altered source versions must be plainly marked as such, and 
must not be misrepresented as being the original software.

3. This notice may not be removed or altered from any source 
distribution.
*/

#include <ctype.h>
#include <stddef.h>


//#define DEBUG_PARSER
#if defined( DEBUG_PARSER )
#	if defined( DEBUG ) && defined( _MSC_VER )
#		include <windows.h>
#		define TIXML_LOG OutputDebugString
#	else
#		define TIXML_LOG printf
#	endif
#endif

// Note tha "PutString" hardcodes the same list. This
// is less flexible than it appears. Changing the entries
// or order will break putstring.	
TiXmlBase::Entity TiXmlBase::entity[ NUM_ENTITY ] = 
{
	{ "&amp;",  5, '&' },
	{ "&lt;",   4, '<' },
	{ "&gt;",   4, '>' },
	{ "&quot;", 6, '\"' },
	{ "&apos;", 6, '\'' }
};

// Bunch of unicode info at:
//		http://www.unicode.org/faq/utf_bom.html
// Including the basic of this table, which determines the #bytes in the
// sequence from the lead byte. 1 placed for invalid sequences --
// although the result will be junk, pass it through as much as possible.
// Beware of the non-characters in UTF-8:	
//				ef bb bf (Microsoft "lead bytes")
//				ef bf be
//				ef bf bf 

const unsigned char TIXML_UTF_LEAD_0 = 0xefU;
const unsigned char TIXML_UTF_LEAD_1 = 0xbbU;
const unsigned char TIXML_UTF_LEAD_2 = 0xbfU;

const int TiXmlBase::utf8ByteTable[256] = 
{
	//	0	1	2	3	4	5	6	7	8	9	a	b	c	d	e	f
		1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	// 0x00
		1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	// 0x10
		1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	// 0x20
		1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	// 0x30
		1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	// 0x40
		1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	// 0x50
		1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	// 0x60
		1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	// 0x70	End of ASCII range
		1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	// 0x80 0x80 to 0xc1 invalid
		1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	// 0x90 
		1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	// 0xa0 
		1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	// 0xb0 
		1,	1,	2,	2,	2,	2,	2,	2,	2,	2,	2,	2,	2,	2,	2,	2,	// 0xc0 0xc2 to 0xdf 2 byte
		2,	2,	2,	2,	2,	2,	2,	2,	2,	2,	2,	2,	2,	2,	2,	2,	// 0xd0
		3,	3,	3,	3,	3,	3,	3,	3,	3,	3,	3,	3,	3,	3,	3,	3,	// 0xe0 0xe0 to 0xef 3 byte
		4,	4,	4,	4,	4,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1	// 0xf0 0xf0 to 0xf4 4 byte, 0xf5 and higher invalid
};


void TiXmlBase::ConvertUTF32ToUTF8( unsigned long input, char* output, int* length )
{
	const unsigned long BYTE_MASK = 0xBF;
	const unsigned long BYTE_MARK = 0x80;
	const unsigned long FIRST_BYTE_MARK[7] = { 0x00, 0x00, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC };

	if (input < 0x80) 
		*length = 1;
	else if ( input < 0x800 )
		*length = 2;
	else if ( input < 0x10000 )
		*length = 3;
	else if ( input < 0x200000 )
		*length = 4;
	else
		{ *length = 0; return; }	// This code won't covert this correctly anyway.

	output += *length;

	// Scary scary fall throughs.
	switch (*length) 
	{
		case 4:
			--output; 
			*output = (char)((input | BYTE_MARK) & BYTE_MASK); 
			input >>= 6;
		case 3:
			--output; 
			*output = (char)((input | BYTE_MARK) & BYTE_MASK); 
			input >>= 6;
		case 2:
			--output; 
			*output = (char)((input | BYTE_MARK) & BYTE_MASK); 
			input >>= 6;
		case 1:
			--output; 
			*output = (char)(input | FIRST_BYTE_MARK[*length]);
	}
}


/*static*/ int TiXmlBase::IsAlpha( unsigned char anyByte, TiXmlEncoding /*encoding*/ )
{
	// This will only work for low-ascii, everything else is assumed to be a valid
	// letter. I'm not sure this is the best approach, but it is quite tricky trying
	// to figure out alhabetical vs. not across encoding. So take a very 
	// conservative approach.

//	if ( encoding == TIXML_ENCODING_UTF8 )
//	{
		if ( anyByte < 127 )
			return isalpha( anyByte );
		else
			return 1;	// What else to do? The unicode set is huge...get the english ones right.
//	}
//	else
//	{
//		return isalpha( anyByte );
//	}
}


/*static*/ int TiXmlBase::IsAlphaNum( unsigned char anyByte, TiXmlEncoding /*encoding*/ )
{
	// This will only work for low-ascii, everything else is assumed to be a valid
	// letter. I'm not sure this is the best approach, but it is quite tricky trying
	// to figure out alhabetical vs. not across encoding. So take a very 
	// conservative approach.

//	if ( encoding == TIXML_ENCODING_UTF8 )
//	{
		if ( anyByte < 127 )
			return isalnum( anyByte );
		else
			return 1;	// What else to do? The unicode set is huge...get the english ones right.
//	}
//	else
//	{
//		return isalnum( anyByte );
//	}
}


class TiXmlParsingData
{
	friend class TiXmlDocument;
  public:
	void Stamp( const char* now, TiXmlEncoding encoding );

	const TiXmlCursor& Cursor()	{ return cursor; }

  private:
	// Only used by the document!
	TiXmlParsingData( const char* start, int _tabsize, int row, int col )
	{
		assert( start );
		stamp = start;
		tabsize = _tabsize;
		cursor.row = row;
		cursor.col = col;
	}

	TiXmlCursor		cursor;
	const char*		stamp;
	int				tabsize;
};


void TiXmlParsingData::Stamp( const char* now, TiXmlEncoding encoding )
{
	assert( now );

	// Do nothing if the tabsize is 0.
	if ( tabsize < 1 )
	{
		return;
	}

	// Get the current row, column.
	int row = cursor.row;
	int col = cursor.col;
	const char* p = stamp;
	assert( p );

	while ( p < now )
	{
		// Treat p as unsigned, so we have a happy compiler.
		const unsigned char* pU = (const unsigned char*)p;

		// Code contributed by Fletcher Dunn: (modified by lee)
		switch (*pU) {
			case 0:
				// We *should* never get here, but in case we do, don't
				// advance past the terminating null character, ever
				return;

			case '\r':
				// bump down to the next line
				++row;
				col = 0;				
				// Eat the character
				++p;

				// Check for \r\n sequence, and treat this as a single character
				if (*p == '\n') {
					++p;
				}
				break;

			case '\n':
				// bump down to the next line
				++row;
				col = 0;

				// Eat the character
				++p;

				// Check for \n\r sequence, and treat this as a single
				// character.  (Yes, this bizarre thing does occur still
				// on some arcane platforms...)
				if (*p == '\r') {
					++p;
				}
				break;

			case '\t':
				// Eat the character
				++p;

				// Skip to next tab stop
				col = (col / tabsize + 1) * tabsize;
				break;

			case TIXML_UTF_LEAD_0:
				if ( encoding == TIXML_ENCODING_UTF8 )
				{
					if ( *(p+1) && *(p+2) )
					{
						// In these cases, don't advance the column. These are
						// 0-width spaces.
						if ( *(pU+1)==TIXML_UTF_LEAD_1 && *(pU+2)==TIXML_UTF_LEAD_2 )
							p += 3;	
						else if ( *(pU+1)==0xbfU && *(pU+2)==0xbeU )
							p += 3;	
						else if ( *(pU+1)==0xbfU && *(pU+2)==0xbfU )
							p += 3;	
						else
							{ p +=3; ++col; }	// A normal character.
					}
				}
				else
				{
					++p;
					++col;
				}
				break;

			default:
				if ( encoding == TIXML_ENCODING_UTF8 )
				{
					// Eat the 1 to 4 byte utf8 character.
					int step = TiXmlBase::utf8ByteTable[*((const unsigned char*)p)];
					if ( step == 0 )
						step = 1;		// Error case from bad encoding, but handle gracefully.
					p += step;

					// Just advance one column, of course.
					++col;
				}
				else
				{
					++p;
					++col;
				}
				break;
		}
	}
	cursor.row = row;
	cursor.col = col;
	assert( cursor.row >= -1 );
	assert( cursor.col >= -1 );
	stamp = p;
	assert( stamp );
}


const char* TiXmlBase::SkipWhiteSpace( const char* p, TiXmlEncoding encoding )
{
	if ( !p || !*p )
	{
		return 0;
	}
	if ( encoding == TIXML_ENCODING_UTF8 )
	{
		while ( *p )
		{
			const unsigned char* pU = (const unsigned char*)p;
			
			// Skip the stupid Microsoft UTF-8 Byte order marks
			if (	*(pU+0)==TIXML_UTF_LEAD_0
				 && *(pU+1)==TIXML_UTF_LEAD_1 
				 && *(pU+2)==TIXML_UTF_LEAD_2 )
			{
				p += 3;
				continue;
			}
			else if(*(pU+0)==TIXML_UTF_LEAD_0
				 && *(pU+1)==0xbfU
				 && *(pU+2)==0xbeU )
			{
				p += 3;
				continue;
			}
			else if(*(pU+0)==TIXML_UTF_LEAD_0
				 && *(pU+1)==0xbfU
				 && *(pU+2)==0xbfU )
			{
				p += 3;
				continue;
			}

			if ( IsWhiteSpace( *p ) )		// Still using old rules for white space.
				++p;
			else
				break;
		}
	}
	else
	{
		while ( *p && IsWhiteSpace( *p ) )
			++p;
	}

	return p;
}

#ifdef TIXML_USE_STL
/*static*/ bool TiXmlBase::StreamWhiteSpace( std::istream * in, TIXML_STRING * tag )
{
	for( ;; )
	{
		if ( !in->good() ) return false;

		int c = in->peek();
		// At this scope, we can't get to a document. So fail silently.
		if ( !IsWhiteSpace( c ) || c <= 0 )
			return true;

		*tag += (char) in->get();
	}
}

/*static*/ bool TiXmlBase::StreamTo( std::istream * in, int character, TIXML_STRING * tag )
{
	//assert( character > 0 && character < 128 );	// else it won't work in utf-8
	while ( in->good() )
	{
		int c = in->peek();
		if ( c == character )
			return true;
		if ( c <= 0 )		// Silent failure: can't get document at this scope
			return false;

		in->get();
		*tag += (char) c;
	}
	return false;
}
#endif

// One of TinyXML's more performance demanding functions. Try to keep the memory overhead down. The
// "assign" optimization removes over 10% of the execution time.
//
const char* TiXmlBase::ReadName( const char* p, TIXML_STRING * name, TiXmlEncoding encoding )
{
	// Oddly, not supported on some comilers,
	//name->clear();
	// So use this:
	*name = "";
	assert( p );

	// Names start with letters or underscores.
	// Of course, in unicode, tinyxml has no idea what a letter *is*. The
	// algorithm is generous.
	//
	// After that, they can be letters, underscores, numbers,
	// hyphens, or colons. (Colons are valid ony for namespaces,
	// but tinyxml can't tell namespaces from names.)
	if (    p && *p 
		 && ( IsAlpha( (unsigned char) *p, encoding ) || *p == '_' ) )
	{
		const char* start = p;
		while(		p && *p
				&&	(		IsAlphaNum( (unsigned char ) *p, encoding ) 
						 || *p == '_'
						 || *p == '-'
						 || *p == '.'
						 || *p == ':' ) )
		{
			//(*name) += *p; // expensive
			++p;
		}
		if ( p-start > 0 ) {
			name->assign( start, p-start );
		}
		return p;
	}
	return 0;
}

const char* TiXmlBase::GetEntity( const char* p, char* value, int* length, TiXmlEncoding encoding )
{
	// Presume an entity, and pull it out.
    TIXML_STRING ent;
	int i;
	*length = 0;

	if ( *(p+1) && *(p+1) == '#' && *(p+2) )
	{
		unsigned long ucs = 0;
		ptrdiff_t delta = 0;
		unsigned mult = 1;

		if ( *(p+2) == 'x' )
		{
			// Hexadecimal.
			if ( !*(p+3) ) return 0;

			const char* q = p+3;
			q = strchr( q, ';' );

			if ( !q || !*q ) return 0;

			delta = q-p;
			--q;

			while ( *q != 'x' )
			{
				if ( *q >= '0' && *q <= '9' )
					ucs += mult * (*q - '0');
				else if ( *q >= 'a' && *q <= 'f' )
					ucs += mult * (*q - 'a' + 10);
				else if ( *q >= 'A' && *q <= 'F' )
					ucs += mult * (*q - 'A' + 10 );
				else 
					return 0;
				mult *= 16;
				--q;
			}
		}
		else
		{
			// Decimal.
			if ( !*(p+2) ) return 0;

			const char* q = p+2;
			q = strchr( q, ';' );

			if ( !q || !*q ) return 0;

			delta = q-p;
			--q;

			while ( *q != '#' )
			{
				if ( *q >= '0' && *q <= '9' )
					ucs += mult * (*q - '0');
				else 
					return 0;
				mult *= 10;
				--q;
			}
		}
		if ( encoding == TIXML_ENCODING_UTF8 )
		{
			// convert the UCS to UTF-8
			ConvertUTF32ToUTF8( ucs, value, length );
		}
		else
		{
			*value = (char)ucs;
			*length = 1;
		}
		return p + delta + 1;
	}

	// Now try to match it.
	for( i=0; i<NUM_ENTITY; ++i )
	{
		if ( strncmp( entity[i].str, p, entity[i].strLength ) == 0 )
		{
			assert( strlen( entity[i].str ) == entity[i].strLength );
			*value = entity[i].chr;
			*length = 1;
			return ( p + entity[i].strLength );
		}
	}

	// So it wasn't an entity, its unrecognized, or something like that.
	*value = *p;	// Don't put back the last one, since we return it!
	//*length = 1;	// Leave unrecognized entities - this doesn't really work.
					// Just writes strange XML.
	return p+1;
}


bool TiXmlBase::StringEqual( const char* p,
							 const char* tag,
							 bool ignoreCase,
							 TiXmlEncoding encoding )
{
	assert( p );
	assert( tag );
	if ( !p || !*p )
	{
		assert( 0 );
		return false;
	}

	const char* q = p;

	if ( ignoreCase )
	{
		while ( *q && *tag && ToLower( *q, encoding ) == ToLower( *tag, encoding ) )
		{
			++q;
			++tag;
		}

		if ( *tag == 0 )
			return true;
	}
	else
	{
		while ( *q && *tag && *q == *tag )
		{
			++q;
			++tag;
		}

		if ( *tag == 0 )		// Have we found the end of the tag, and everything equal?
			return true;
	}
	return false;
}

const char* TiXmlBase::ReadText(	const char* p, 
									TIXML_STRING * text, 
									bool trimWhiteSpace, 
									const char* endTag, 
									bool caseInsensitive,
									TiXmlEncoding encoding )
{
    *text = "";
	if (    !trimWhiteSpace			// certain tags always keep whitespace
		 || !condenseWhiteSpace )	// if true, whitespace is always kept
	{
		// Keep all the white space.
		while (	   p && *p
				&& !StringEqual( p, endTag, caseInsensitive, encoding )
			  )
		{
			int len;
			char cArr[4] = { 0, 0, 0, 0 };
			p = GetChar( p, cArr, &len, encoding );
			text->append( cArr, len );
		}
	}
	else
	{
		bool whitespace = false;

		// Remove leading white space:
		p = SkipWhiteSpace( p, encoding );
		while (	   p && *p
				&& !StringEqual( p, endTag, caseInsensitive, encoding ) )
		{
			if ( *p == '\r' || *p == '\n' )
			{
				whitespace = true;
				++p;
			}
			else if ( IsWhiteSpace( *p ) )
			{
				whitespace = true;
				++p;
			}
			else
			{
				// If we've found whitespace, add it before the
				// new character. Any whitespace just becomes a space.
				if ( whitespace )
				{
					(*text) += ' ';
					whitespace = false;
				}
				int len;
				char cArr[4] = { 0, 0, 0, 0 };
				p = GetChar( p, cArr, &len, encoding );
				if ( len == 1 )
					(*text) += cArr[0];	// more efficient
				else
					text->append( cArr, len );
			}
		}
	}
	if ( p && *p ) 
		p += strlen( endTag );
	return p;
}

#ifdef TIXML_USE_STL

void TiXmlDocument::StreamIn( std::istream * in, TIXML_STRING * tag )
{
	// The basic issue with a document is that we don't know what we're
	// streaming. Read something presumed to be a tag (and hope), then
	// identify it, and call the appropriate stream method on the tag.
	//
	// This "pre-streaming" will never read the closing ">" so the
	// sub-tag can orient itself.

	if ( !StreamTo( in, '<', tag ) ) 
	{
		SetError( TIXML_ERROR_PARSING_EMPTY, 0, 0, TIXML_ENCODING_UNKNOWN );
		return;
	}

	while ( in->good() )
	{
		int tagIndex = (int) tag->length();
		while ( in->good() && in->peek() != '>' )
		{
			int c = in->get();
			if ( c <= 0 )
			{
				SetError( TIXML_ERROR_EMBEDDED_NULL, 0, 0, TIXML_ENCODING_UNKNOWN );
				break;
			}
			(*tag) += (char) c;
		}

		if ( in->good() )
		{
			// We now have something we presume to be a node of 
			// some sort. Identify it, and call the node to
			// continue streaming.
			TiXmlNode* node = Identify( tag->c_str() + tagIndex, TIXML_DEFAULT_ENCODING );

			if ( node )
			{
				node->StreamIn( in, tag );
				bool isElement = node->ToElement() != 0;
				delete node;
				node = 0;

				// If this is the root element, we're done. Parsing will be
				// done by the >> operator.
				if ( isElement )
				{
					return;
				}
			}
			else
			{
				SetError( TIXML_ERROR, 0, 0, TIXML_ENCODING_UNKNOWN );
				return;
			}
		}
	}
	// We should have returned sooner.
	SetError( TIXML_ERROR, 0, 0, TIXML_ENCODING_UNKNOWN );
}

#endif

const char* TiXmlDocument::Parse( const char* p, TiXmlParsingData* prevData, TiXmlEncoding encoding )
{
	ClearError();

	// Parse away, at the document level. Since a document
	// contains nothing but other tags, most of what happens
	// here is skipping white space.
	if ( !p || !*p )
	{
		SetError( TIXML_ERROR_DOCUMENT_EMPTY, 0, 0, TIXML_ENCODING_UNKNOWN );
		return 0;
	}

	// Note that, for a document, this needs to come
	// before the while space skip, so that parsing
	// starts from the pointer we are given.
	location.Clear();
	if ( prevData )
	{
		location.row = prevData->cursor.row;
		location.col = prevData->cursor.col;
	}
	else
	{
		location.row = 0;
		location.col = 0;
	}
	TiXmlParsingData data( p, TabSize(), location.row, location.col );
	location = data.Cursor();

	if ( encoding == TIXML_ENCODING_UNKNOWN )
	{
		// Check for the Microsoft UTF-8 lead bytes.
		const unsigned char* pU = (const unsigned char*)p;
		if (	*(pU+0) && *(pU+0) == TIXML_UTF_LEAD_0
			 && *(pU+1) && *(pU+1) == TIXML_UTF_LEAD_1
			 && *(pU+2) && *(pU+2) == TIXML_UTF_LEAD_2 )
		{
			encoding = TIXML_ENCODING_UTF8;
			useMicrosoftBOM = true;
		}
	}

    p = SkipWhiteSpace( p, encoding );
	if ( !p )
	{
		SetError( TIXML_ERROR_DOCUMENT_EMPTY, 0, 0, TIXML_ENCODING_UNKNOWN );
		return 0;
	}

	while ( p && *p )
	{
		TiXmlNode* node = Identify( p, encoding );
		if ( node )
		{
			p = node->Parse( p, &data, encoding );
			LinkEndChild( node );
		}
		else
		{
			break;
		}

		// Did we get encoding info?
		if (    encoding == TIXML_ENCODING_UNKNOWN
			 && node->ToDeclaration() )
		{
			TiXmlDeclaration* dec = node->ToDeclaration();
			const char* enc = dec->Encoding();
			assert( enc );

			if ( *enc == 0 )
				encoding = TIXML_ENCODING_UTF8;
			else if ( StringEqual( enc, "UTF-8", true, TIXML_ENCODING_UNKNOWN ) )
				encoding = TIXML_ENCODING_UTF8;
			else if ( StringEqual( enc, "UTF8", true, TIXML_ENCODING_UNKNOWN ) )
				encoding = TIXML_ENCODING_UTF8;	// incorrect, but be nice
			else 
				encoding = TIXML_ENCODING_LEGACY;
		}

		p = SkipWhiteSpace( p, encoding );
	}

	// Was this empty?
	if ( !firstChild ) {
		SetError( TIXML_ERROR_DOCUMENT_EMPTY, 0, 0, encoding );
		return 0;
	}

	// All is well.
	return p;
}

void TiXmlDocument::SetError( int err, const char* pError, TiXmlParsingData* data, TiXmlEncoding encoding )
{	
	// The first error in a chain is more accurate - don't set again!
	if ( error )
		return;

	assert( err > 0 && err < TIXML_ERROR_STRING_COUNT );
	error   = true;
	errorId = err;
	errorDesc = errorString[ errorId ];

	errorLocation.Clear();
	if ( pError && data )
	{
		data->Stamp( pError, encoding );
		errorLocation = data->Cursor();
	}
}


TiXmlNode* TiXmlNode::Identify( const char* p, TiXmlEncoding encoding )
{
	TiXmlNode* returnNode = 0;

	p = SkipWhiteSpace( p, encoding );
	if( !p || !*p || *p != '<' )
	{
		return 0;
	}

	p = SkipWhiteSpace( p, encoding );

	if ( !p || !*p )
	{
		return 0;
	}

	// What is this thing? 
	// - Elements start with a letter or underscore, but xml is reserved.
	// - Comments: <!--
	// - Decleration: <?xml
	// - Everthing else is unknown to tinyxml.
	//

	const char* xmlHeader = { "<?xml" };
	const char* commentHeader = { "<!--" };
	const char* dtdHeader = { "<!" };
	const char* cdataHeader = { "<![CDATA[" };

	if ( StringEqual( p, xmlHeader, true, encoding ) )
	{
		#ifdef DEBUG_PARSER
			TIXML_LOG( "XML parsing Declaration\n" );
		#endif
		returnNode = new TiXmlDeclaration();
	}
	else if ( StringEqual( p, commentHeader, false, encoding ) )
	{
		#ifdef DEBUG_PARSER
			TIXML_LOG( "XML parsing Comment\n" );
		#endif
		returnNode = new TiXmlComment();
	}
	else if ( StringEqual( p, cdataHeader, false, encoding ) )
	{
		#ifdef DEBUG_PARSER
			TIXML_LOG( "XML parsing CDATA\n" );
		#endif
		TiXmlText* text = new TiXmlText( "" );
		text->SetCDATA( true );
		returnNode = text;
	}
	else if ( StringEqual( p, dtdHeader, false, encoding ) )
	{
		#ifdef DEBUG_PARSER
			TIXML_LOG( "XML parsing Unknown(1)\n" );
		#endif
		returnNode = new TiXmlUnknown();
	}
	else if (    IsAlpha( *(p+1), encoding )
			  || *(p+1) == '_' )
	{
		#ifdef DEBUG_PARSER
			TIXML_LOG( "XML parsing Element\n" );
		#endif
		returnNode = new TiXmlElement( "" );
	}
	else
	{
		#ifdef DEBUG_PARSER
			TIXML_LOG( "XML parsing Unknown(2)\n" );
		#endif
		returnNode = new TiXmlUnknown();
	}

	if ( returnNode )
	{
		// Set the parent, so it can report errors
		returnNode->parent = this;
	}
	return returnNode;
}

#ifdef TIXML_USE_STL

void TiXmlElement::StreamIn (std::istream * in, TIXML_STRING * tag)
{
	// We're called with some amount of pre-parsing. That is, some of "this"
	// element is in "tag". Go ahead and stream to the closing ">"
	while( in->good() )
	{
		int c = in->get();
		if ( c <= 0 )
		{
			TiXmlDocument* document = GetDocument();
			if ( document )
				document->SetError( TIXML_ERROR_EMBEDDED_NULL, 0, 0, TIXML_ENCODING_UNKNOWN );
			return;
		}
		(*tag) += (char) c ;
		
		if ( c == '>' )
			break;
	}

	if ( tag->length() < 3 ) return;

	// Okay...if we are a "/>" tag, then we're done. We've read a complete tag.
	// If not, identify and stream.

	if (    tag->at( tag->length() - 1 ) == '>' 
		 && tag->at( tag->length() - 2 ) == '/' )
	{
		// All good!
		return;
	}
	else if ( tag->at( tag->length() - 1 ) == '>' )
	{
		// There is more. Could be:
		//		text
		//		cdata text (which looks like another node)
		//		closing tag
		//		another node.
		for ( ;; )
		{
			StreamWhiteSpace( in, tag );

			// Do we have text?
			if ( in->good() && in->peek() != '<' ) 
			{
				// Yep, text.
				TiXmlText text( "" );
				text.StreamIn( in, tag );

				// What follows text is a closing tag or another node.
				// Go around again and figure it out.
				continue;
			}

			// We now have either a closing tag...or another node.
			// We should be at a "<", regardless.
			if ( !in->good() ) return;
			assert( in->peek() == '<' );
			int tagIndex = (int) tag->length();

			bool closingTag = false;
			bool firstCharFound = false;

			for( ;; )
			{
				if ( !in->good() )
					return;

				int c = in->peek();
				if ( c <= 0 )
				{
					TiXmlDocument* document = GetDocument();
					if ( document )
						document->SetError( TIXML_ERROR_EMBEDDED_NULL, 0, 0, TIXML_ENCODING_UNKNOWN );
					return;
				}
				
				if ( c == '>' )
					break;

				*tag += (char) c;
				in->get();

				// Early out if we find the CDATA id.
				if ( c == '[' && tag->size() >= 9 )
				{
					size_t len = tag->size();
					const char* start = tag->c_str() + len - 9;
					if ( strcmp( start, "<![CDATA[" ) == 0 ) {
						assert( !closingTag );
						break;
					}
				}

				if ( !firstCharFound && c != '<' && !IsWhiteSpace( c ) )
				{
					firstCharFound = true;
					if ( c == '/' )
						closingTag = true;
				}
			}
			// If it was a closing tag, then read in the closing '>' to clean up the input stream.
			// If it was not, the streaming will be done by the tag.
			if ( closingTag )
			{
				if ( !in->good() )
					return;

				int c = in->get();
				if ( c <= 0 )
				{
					TiXmlDocument* document = GetDocument();
					if ( document )
						document->SetError( TIXML_ERROR_EMBEDDED_NULL, 0, 0, TIXML_ENCODING_UNKNOWN );
					return;
				}
				assert( c == '>' );
				*tag += (char) c;

				// We are done, once we've found our closing tag.
				return;
			}
			else
			{
				// If not a closing tag, id it, and stream.
				const char* tagloc = tag->c_str() + tagIndex;
				TiXmlNode* node = Identify( tagloc, TIXML_DEFAULT_ENCODING );
				if ( !node )
					return;
				node->StreamIn( in, tag );
				delete node;
				node = 0;

				// No return: go around from the beginning: text, closing tag, or node.
			}
		}
	}
}
#endif

const char* TiXmlElement::Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding encoding )
{
	p = SkipWhiteSpace( p, encoding );
	TiXmlDocument* document = GetDocument();

	if ( !p || !*p )
	{
		if ( document ) document->SetError( TIXML_ERROR_PARSING_ELEMENT, 0, 0, encoding );
		return 0;
	}

	if ( data )
	{
		data->Stamp( p, encoding );
		location = data->Cursor();
	}

	if ( *p != '<' )
	{
		if ( document ) document->SetError( TIXML_ERROR_PARSING_ELEMENT, p, data, encoding );
		return 0;
	}

	p = SkipWhiteSpace( p+1, encoding );

	// Read the name.
	const char* pErr = p;

    p = ReadName( p, &value, encoding );
	if ( !p || !*p )
	{
		if ( document )	document->SetError( TIXML_ERROR_FAILED_TO_READ_ELEMENT_NAME, pErr, data, encoding );
		return 0;
	}

    TIXML_STRING endTag ("</");
	endTag += value;

	// Check for and read attributes. Also look for an empty
	// tag or an end tag.
	while ( p && *p )
	{
		pErr = p;
		p = SkipWhiteSpace( p, encoding );
		if ( !p || !*p )
		{
			if ( document ) document->SetError( TIXML_ERROR_READING_ATTRIBUTES, pErr, data, encoding );
			return 0;
		}
		if ( *p == '/' )
		{
			++p;
			// Empty tag.
			if ( *p  != '>' )
			{
				if ( document ) document->SetError( TIXML_ERROR_PARSING_EMPTY, p, data, encoding );		
				return 0;
			}
			return (p+1);
		}
		else if ( *p == '>' )
		{
			// Done with attributes (if there were any.)
			// Read the value -- which can include other
			// elements -- read the end tag, and return.
			++p;
			p = ReadValue( p, data, encoding );		// Note this is an Element method, and will set the error if one happens.
			if ( !p || !*p ) {
				// We were looking for the end tag, but found nothing.
				// Fix for [ 1663758 ] Failure to report error on bad XML
				if ( document ) document->SetError( TIXML_ERROR_READING_END_TAG, p, data, encoding );
				return 0;
			}

			// We should find the end tag now
			// note that:
			// </foo > and
			// </foo> 
			// are both valid end tags.
			if ( StringEqual( p, endTag.c_str(), false, encoding ) )
			{
				p += endTag.length();
				p = SkipWhiteSpace( p, encoding );
				if ( p && *p && *p == '>' ) {
					++p;
					return p;
				}
				if ( document ) document->SetError( TIXML_ERROR_READING_END_TAG, p, data, encoding );
				return 0;
			}
			else
			{
				if ( document ) document->SetError( TIXML_ERROR_READING_END_TAG, p, data, encoding );
				return 0;
			}
		}
		else
		{
			// Try to read an attribute:
			TiXmlAttribute* attrib = new TiXmlAttribute();
			if ( !attrib )
			{
				return 0;
			}

			attrib->SetDocument( document );
			pErr = p;
			p = attrib->Parse( p, data, encoding );

			if ( !p || !*p )
			{
				if ( document ) document->SetError( TIXML_ERROR_PARSING_ELEMENT, pErr, data, encoding );
				delete attrib;
				return 0;
			}

			// Handle the strange case of double attributes:
			#ifdef TIXML_USE_STL
			TiXmlAttribute* node = attributeSet.Find( attrib->NameTStr() );
			#else
			TiXmlAttribute* node = attributeSet.Find( attrib->Name() );
			#endif
			if ( node )
			{
				if ( document ) document->SetError( TIXML_ERROR_PARSING_ELEMENT, pErr, data, encoding );
				delete attrib;
				return 0;
			}

			attributeSet.Add( attrib );
		}
	}
	return p;
}


const char* TiXmlElement::ReadValue( const char* p, TiXmlParsingData* data, TiXmlEncoding encoding )
{
	TiXmlDocument* document = GetDocument();

	// Read in text and elements in any order.
	const char* pWithWhiteSpace = p;
	p = SkipWhiteSpace( p, encoding );

	while ( p && *p )
	{
		if ( *p != '<' )
		{
			// Take what we have, make a text element.
			TiXmlText* textNode = new TiXmlText( "" );

			if ( !textNode )
			{
			    return 0;
			}

			if ( TiXmlBase::IsWhiteSpaceCondensed() )
			{
				p = textNode->Parse( p, data, encoding );
			}
			else
			{
				// Special case: we want to keep the white space
				// so that leading spaces aren't removed.
				p = textNode->Parse( pWithWhiteSpace, data, encoding );
			}

			if ( !textNode->Blank() )
				LinkEndChild( textNode );
			else
				delete textNode;
		} 
		else 
		{
			// We hit a '<'
			// Have we hit a new element or an end tag? This could also be
			// a TiXmlText in the "CDATA" style.
			if ( StringEqual( p, "</", false, encoding ) )
			{
				return p;
			}
			else
			{
				TiXmlNode* node = Identify( p, encoding );
				if ( node )
				{
					p = node->Parse( p, data, encoding );
					LinkEndChild( node );
				}				
				else
				{
					return 0;
				}
			}
		}
		pWithWhiteSpace = p;
		p = SkipWhiteSpace( p, encoding );
	}

	if ( !p )
	{
		if ( document ) document->SetError( TIXML_ERROR_READING_ELEMENT_VALUE, 0, 0, encoding );
	}	
	return p;
}


#ifdef TIXML_USE_STL
void TiXmlUnknown::StreamIn( std::istream * in, TIXML_STRING * tag )
{
	while ( in->good() )
	{
		int c = in->get();	
		if ( c <= 0 )
		{
			TiXmlDocument* document = GetDocument();
			if ( document )
				document->SetError( TIXML_ERROR_EMBEDDED_NULL, 0, 0, TIXML_ENCODING_UNKNOWN );
			return;
		}
		(*tag) += (char) c;

		if ( c == '>' )
		{
			// All is well.
			return;		
		}
	}
}
#endif


const char* TiXmlUnknown::Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding encoding )
{
	TiXmlDocument* document = GetDocument();
	p = SkipWhiteSpace( p, encoding );

	if ( data )
	{
		data->Stamp( p, encoding );
		location = data->Cursor();
	}
	if ( !p || !*p || *p != '<' )
	{
		if ( document ) document->SetError( TIXML_ERROR_PARSING_UNKNOWN, p, data, encoding );
		return 0;
	}
	++p;
    value = "";

	while ( p && *p && *p != '>' )
	{
		value += *p;
		++p;
	}

	if ( !p )
	{
		if ( document )	document->SetError( TIXML_ERROR_PARSING_UNKNOWN, 0, 0, encoding );
	}
	if ( *p == '>' )
		return p+1;
	return p;
}

#ifdef TIXML_USE_STL
void TiXmlComment::StreamIn( std::istream * in, TIXML_STRING * tag )
{
	while ( in->good() )
	{
		int c = in->get();	
		if ( c <= 0 )
		{
			TiXmlDocument* document = GetDocument();
			if ( document )
				document->SetError( TIXML_ERROR_EMBEDDED_NULL, 0, 0, TIXML_ENCODING_UNKNOWN );
			return;
		}

		(*tag) += (char) c;

		if ( c == '>' 
			 && tag->at( tag->length() - 2 ) == '-'
			 && tag->at( tag->length() - 3 ) == '-' )
		{
			// All is well.
			return;		
		}
	}
}
#endif


const char* TiXmlComment::Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding encoding )
{
	TiXmlDocument* document = GetDocument();
	value = "";

	p = SkipWhiteSpace( p, encoding );

	if ( data )
	{
		data->Stamp( p, encoding );
		location = data->Cursor();
	}
	const char* startTag = "<!--";
	const char* endTag   = "-->";

	if ( !StringEqual( p, startTag, false, encoding ) )
	{
		document->SetError( TIXML_ERROR_PARSING_COMMENT, p, data, encoding );
		return 0;
	}
	p += strlen( startTag );

	// [ 1475201 ] TinyXML parses entities in comments
	// Oops - ReadText doesn't work, because we don't want to parse the entities.
	// p = ReadText( p, &value, false, endTag, false, encoding );
	//
	// from the XML spec:
	/*
	 [Definition: Comments may appear anywhere in a document outside other markup; in addition, 
	              they may appear within the document type declaration at places allowed by the grammar. 
				  They are not part of the document's character data; an XML processor MAY, but need not, 
				  make it possible for an application to retrieve the text of comments. For compatibility, 
				  the string "--" (double-hyphen) MUST NOT occur within comments.] Parameter entity 
				  references MUST NOT be recognized within comments.

				  An example of a comment:

				  <!-- declarations for <head> & <body> -->
	*/

    value = "";
	// Keep all the white space.
	while (	p && *p && !StringEqual( p, endTag, false, encoding ) )
	{
		value.append( p, 1 );
		++p;
	}
	if ( p && *p ) 
		p += strlen( endTag );

	return p;
}


const char* TiXmlAttribute::Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding encoding )
{
	p = SkipWhiteSpace( p, encoding );
	if ( !p || !*p ) return 0;

	if ( data )
	{
		data->Stamp( p, encoding );
		location = data->Cursor();
	}
	// Read the name, the '=' and the value.
	const char* pErr = p;
	p = ReadName( p, &name, encoding );
	if ( !p || !*p )
	{
		if ( document ) document->SetError( TIXML_ERROR_READING_ATTRIBUTES, pErr, data, encoding );
		return 0;
	}
	p = SkipWhiteSpace( p, encoding );
	if ( !p || !*p || *p != '=' )
	{
		if ( document ) document->SetError( TIXML_ERROR_READING_ATTRIBUTES, p, data, encoding );
		return 0;
	}

	++p;	// skip '='
	p = SkipWhiteSpace( p, encoding );
	if ( !p || !*p )
	{
		if ( document ) document->SetError( TIXML_ERROR_READING_ATTRIBUTES, p, data, encoding );
		return 0;
	}
	
	const char* end;
	const char SINGLE_QUOTE = '\'';
	const char DOUBLE_QUOTE = '\"';

	if ( *p == SINGLE_QUOTE )
	{
		++p;
		end = "\'";		// single quote in string
		p = ReadText( p, &value, false, end, false, encoding );
	}
	else if ( *p == DOUBLE_QUOTE )
	{
		++p;
		end = "\"";		// double quote in string
		p = ReadText( p, &value, false, end, false, encoding );
	}
	else
	{
		// All attribute values should be in single or double quotes.
		// But this is such a common error that the parser will try
		// its best, even without them.
		value = "";
		while (    p && *p											// existence
				&& !IsWhiteSpace( *p )								// whitespace
				&& *p != '/' && *p != '>' )							// tag end
		{
			if ( *p == SINGLE_QUOTE || *p == DOUBLE_QUOTE ) {
				// [ 1451649 ] Attribute values with trailing quotes not handled correctly
				// We did not have an opening quote but seem to have a 
				// closing one. Give up and throw an error.
				if ( document ) document->SetError( TIXML_ERROR_READING_ATTRIBUTES, p, data, encoding );
				return 0;
			}
			value += *p;
			++p;
		}
	}
	return p;
}

#ifdef TIXML_USE_STL
void TiXmlText::StreamIn( std::istream * in, TIXML_STRING * tag )
{
	while ( in->good() )
	{
		int c = in->peek();	
		if ( !cdata && (c == '<' ) ) 
		{
			return;
		}
		if ( c <= 0 )
		{
			TiXmlDocument* document = GetDocument();
			if ( document )
				document->SetError( TIXML_ERROR_EMBEDDED_NULL, 0, 0, TIXML_ENCODING_UNKNOWN );
			return;
		}

		(*tag) += (char) c;
		in->get();	// "commits" the peek made above

		if ( cdata && c == '>' && tag->size() >= 3 ) {
			size_t len = tag->size();
			if ( (*tag)[len-2] == ']' && (*tag)[len-3] == ']' ) {
				// terminator of cdata.
				return;
			}
		}    
	}
}
#endif

const char* TiXmlText::Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding encoding )
{
	value = "";
	TiXmlDocument* document = GetDocument();

	if ( data )
	{
		data->Stamp( p, encoding );
		location = data->Cursor();
	}

	const char* const startTag = "<![CDATA[";
	const char* const endTag   = "]]>";

	if ( cdata || StringEqual( p, startTag, false, encoding ) )
	{
		cdata = true;

		if ( !StringEqual( p, startTag, false, encoding ) )
		{
			document->SetError( TIXML_ERROR_PARSING_CDATA, p, data, encoding );
			return 0;
		}
		p += strlen( startTag );

		// Keep all the white space, ignore the encoding, etc.
		while (	   p && *p
				&& !StringEqual( p, endTag, false, encoding )
			  )
		{
			value += *p;
			++p;
		}

		TIXML_STRING dummy; 
		p = ReadText( p, &dummy, false, endTag, false, encoding );
		return p;
	}
	else
	{
		bool ignoreWhite = true;

		const char* end = "<";
		p = ReadText( p, &value, ignoreWhite, end, false, encoding );
		if ( p )
			return p-1;	// don't truncate the '<'
		return 0;
	}
}

#ifdef TIXML_USE_STL
void TiXmlDeclaration::StreamIn( std::istream * in, TIXML_STRING * tag )
{
	while ( in->good() )
	{
		int c = in->get();
		if ( c <= 0 )
		{
			TiXmlDocument* document = GetDocument();
			if ( document )
				document->SetError( TIXML_ERROR_EMBEDDED_NULL, 0, 0, TIXML_ENCODING_UNKNOWN );
			return;
		}
		(*tag) += (char) c;

		if ( c == '>' )
		{
			// All is well.
			return;
		}
	}
}
#endif

const char* TiXmlDeclaration::Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding _encoding )
{
	p = SkipWhiteSpace( p, _encoding );
	// Find the beginning, find the end, and look for
	// the stuff in-between.
	TiXmlDocument* document = GetDocument();
	if ( !p || !*p || !StringEqual( p, "<?xml", true, _encoding ) )
	{
		if ( document ) document->SetError( TIXML_ERROR_PARSING_DECLARATION, 0, 0, _encoding );
		return 0;
	}
	if ( data )
	{
		data->Stamp( p, _encoding );
		location = data->Cursor();
	}
	p += 5;

	version = "";
	encoding = "";
	standalone = "";

	while ( p && *p )
	{
		if ( *p == '>' )
		{
			++p;
			return p;
		}

		p = SkipWhiteSpace( p, _encoding );
		if ( StringEqual( p, "version", true, _encoding ) )
		{
			TiXmlAttribute attrib;
			p = attrib.Parse( p, data, _encoding );		
			version = attrib.Value();
		}
		else if ( StringEqual( p, "encoding", true, _encoding ) )
		{
			TiXmlAttribute attrib;
			p = attrib.Parse( p, data, _encoding );		
			encoding = attrib.Value();
		}
		else if ( StringEqual( p, "standalone", true, _encoding ) )
		{
			TiXmlAttribute attrib;
			p = attrib.Parse( p, data, _encoding );		
			standalone = attrib.Value();
		}
		else
		{
			// Read over whatever it is.
			while( p && *p && *p != '>' && !IsWhiteSpace( *p ) )
				++p;
		}
	}
	return 0;
}

bool TiXmlText::Blank() const
{
	for ( unsigned i=0; i<value.length(); i++ )
		if ( !IsWhiteSpace( value[i] ) )
			return false;
	return true;
}

/*
   Test program for TinyXML.
*/


#ifdef TIXML_USE_STL
	#include <iostream>
	#include <sstream>
	using namespace std;
#else
	#include <stdio.h>
#endif

#if defined( WIN32 ) && defined( TUNE )
	#include <crtdbg.h>
	_CrtMemState startMemState;
	_CrtMemState endMemState;
#endif

bool XmlTest (const char* testString, const char* expected, const char* found, bool noEcho = false);
bool XmlTest( const char* testString, int expected, int found, bool noEcho = false );

static int gPass = 0;
static int gFail = 0;



bool XmlTest (const char* testString, const char* expected, const char* found, bool noEcho )
{
	bool pass = !strcmp( expected, found );
	if ( pass )
		printf ("[pass]");
	else
		printf ("[fail]");

	if ( noEcho )
		printf (" %s\n", testString);
	else
		printf (" %s [%s][%s]\n", testString, expected, found);

	if ( pass )
		++gPass;
	else
		++gFail;
	return pass;
}


bool XmlTest( const char* testString, int expected, int found, bool noEcho )
{
	bool pass = ( expected == found );
	if ( pass )
		printf ("[pass]");
	else
		printf ("[fail]");

	if ( noEcho )
		printf (" %s\n", testString);
	else
		printf (" %s [%d][%d]\n", testString, expected, found);

	if ( pass )
		++gPass;
	else
		++gFail;
	return pass;
}


//
// This file demonstrates some basic functionality of TinyXml.
// Note that the example is very contrived. It presumes you know
// what is in the XML file. But it does test the basic operations,
// and show how to add and remove nodes.
//

int main()
{

	//
	// We start with the 'demoStart' todo list. Process it. And
	// should hopefully end up with the todo list as illustrated.
	//
	const char* demoStart =
		"<?xml version=\"1.0\"  standalone='no' >\n"
		"<!-- Our to do list data -->"
		"<ToDo>\n"
		"<!-- Do I need a secure PDA? -->\n"
		"<Item priority=\"1\" distance='close'> Go to the <bold>Toy store!</bold></Item>"
		"<Item priority=\"2\" distance='none'> Do bills   </Item>"
		"<Item priority=\"2\" distance='far &amp; back'> Look for Evil Dinosaurs! </Item>"
		"</ToDo>";
		
	{

	#ifdef TIXML_USE_STL
		//	What the todo list should look like after processing.
		// In stream (no formatting) representation.
		const char* demoEnd =
			"<?xml version=\"1.0\" standalone=\"no\" ?>"
			"<!-- Our to do list data -->"
			"<ToDo>"
			"<!-- Do I need a secure PDA? -->"
			"<Item priority=\"2\" distance=\"close\">Go to the"
			"<bold>Toy store!"
			"</bold>"
			"</Item>"
			"<Item priority=\"1\" distance=\"far\">Talk to:"
			"<Meeting where=\"School\">"
			"<Attendee name=\"Marple\" position=\"teacher\" />"
			"<Attendee name=\"Voel\" position=\"counselor\" />"
			"</Meeting>"
			"<Meeting where=\"Lunch\" />"
			"</Item>"
			"<Item priority=\"2\" distance=\"here\">Do bills"
			"</Item>"
			"</ToDo>";
	#endif

		// The example parses from the character string (above):
		#if defined( WIN32 ) && defined( TUNE )
		_CrtMemCheckpoint( &startMemState );
		#endif	

		{
			// Write to a file and read it back, to check file I/O.

			TiXmlDocument doc( "demotest.xml" );
			doc.Parse( demoStart );

			if ( doc.Error() )
			{
				printf( "Error in %s: %s\n", doc.Value(), doc.ErrorDesc() );
				exit( 1 );
			}
			doc.SaveFile();
		}

		TiXmlDocument doc( "demotest.xml" );
		bool loadOkay = doc.LoadFile();

		if ( !loadOkay )
		{
			printf( "Could not load test file 'demotest.xml'. Error='%s'. Exiting.\n", doc.ErrorDesc() );
			exit( 1 );
		}

		printf( "** Demo doc read from disk: ** \n\n" );
		printf( "** Printing via doc.Print **\n" );
		doc.Print( stdout );

		{
			printf( "** Printing via TiXmlPrinter **\n" );
			TiXmlPrinter printer;
			doc.Accept( &printer );
			fprintf( stdout, "%s", printer.CStr() );
		}
		#ifdef TIXML_USE_STL	
		{
			printf( "** Printing via operator<< **\n" );
			std::cout << doc;
		}
		#endif
		TiXmlNode* node = 0;
		TiXmlElement* todoElement = 0;
		TiXmlElement* itemElement = 0;


		// --------------------------------------------------------
		// An example of changing existing attributes, and removing
		// an element from the document.
		// --------------------------------------------------------

		// Get the "ToDo" element.
		// It is a child of the document, and can be selected by name.
		node = doc.FirstChild( "ToDo" );
		assert( node );
		todoElement = node->ToElement();
		assert( todoElement  );

		// Going to the toy store is now our second priority...
		// So set the "priority" attribute of the first item in the list.
		node = todoElement->FirstChildElement();	// This skips the "PDA" comment.
		assert( node );
		itemElement = node->ToElement();
		assert( itemElement  );
		itemElement->SetAttribute( "priority", 2 );

		// Change the distance to "doing bills" from
		// "none" to "here". It's the next sibling element.
		itemElement = itemElement->NextSiblingElement();
		assert( itemElement );
		itemElement->SetAttribute( "distance", "here" );

		// Remove the "Look for Evil Dinosaurs!" item.
		// It is 1 more sibling away. We ask the parent to remove
		// a particular child.
		itemElement = itemElement->NextSiblingElement();
		todoElement->RemoveChild( itemElement );

		itemElement = 0;

		// --------------------------------------------------------
		// What follows is an example of created elements and text
		// nodes and adding them to the document.
		// --------------------------------------------------------

		// Add some meetings.
		TiXmlElement item( "Item" );
		item.SetAttribute( "priority", "1" );
		item.SetAttribute( "distance", "far" );

		TiXmlText text( "Talk to:" );

		TiXmlElement meeting1( "Meeting" );
		meeting1.SetAttribute( "where", "School" );

		TiXmlElement meeting2( "Meeting" );
		meeting2.SetAttribute( "where", "Lunch" );

		TiXmlElement attendee1( "Attendee" );
		attendee1.SetAttribute( "name", "Marple" );
		attendee1.SetAttribute( "position", "teacher" );

		TiXmlElement attendee2( "Attendee" );
		attendee2.SetAttribute( "name", "Voel" );
		attendee2.SetAttribute( "position", "counselor" );

		// Assemble the nodes we've created:
		meeting1.InsertEndChild( attendee1 );
		meeting1.InsertEndChild( attendee2 );

		item.InsertEndChild( text );
		item.InsertEndChild( meeting1 );
		item.InsertEndChild( meeting2 );

		// And add the node to the existing list after the first child.
		node = todoElement->FirstChild( "Item" );
		assert( node );
		itemElement = node->ToElement();
		assert( itemElement );

		todoElement->InsertAfterChild( itemElement, item );

		printf( "\n** Demo doc processed: ** \n\n" );
		doc.Print( stdout );


	#ifdef TIXML_USE_STL
		printf( "** Demo doc processed to stream: ** \n\n" );
		cout << doc << endl << endl;
	#endif

		// --------------------------------------------------------
		// Different tests...do we have what we expect?
		// --------------------------------------------------------

		int count = 0;
		TiXmlElement*	element;

		//////////////////////////////////////////////////////

	#ifdef TIXML_USE_STL
		cout << "** Basic structure. **\n";
		ostringstream outputStream( ostringstream::out );
		outputStream << doc;
		XmlTest( "Output stream correct.",	string( demoEnd ).c_str(),
											outputStream.str().c_str(), true );
	#endif

		node = doc.RootElement();
		assert( node );
		XmlTest( "Root element exists.", true, ( node != 0 && node->ToElement() ) );
		XmlTest ( "Root element value is 'ToDo'.", "ToDo",  node->Value());

		node = node->FirstChild();
		XmlTest( "First child exists & is a comment.", true, ( node != 0 && node->ToComment() ) );
		node = node->NextSibling();
		XmlTest( "Sibling element exists & is an element.", true, ( node != 0 && node->ToElement() ) );
		XmlTest ( "Value is 'Item'.", "Item", node->Value() );

		node = node->FirstChild();
		XmlTest ( "First child exists.", true, ( node != 0 && node->ToText() ) );
		XmlTest ( "Value is 'Go to the'.", "Go to the", node->Value() );


		//////////////////////////////////////////////////////
		printf ("\n** Iterators. **\n");

		// Walk all the top level nodes of the document.
		count = 0;
		for( node = doc.FirstChild();
			 node;
			 node = node->NextSibling() )
		{
			count++;
		}
		XmlTest( "Top level nodes, using First / Next.", 3, count );

		count = 0;
		for( node = doc.LastChild();
			 node;
			 node = node->PreviousSibling() )
		{
			count++;
		}
		XmlTest( "Top level nodes, using Last / Previous.", 3, count );

		// Walk all the top level nodes of the document,
		// using a different syntax.
		count = 0;
		for( node = doc.IterateChildren( 0 );
			 node;
			 node = doc.IterateChildren( node ) )
		{
			count++;
		}
		XmlTest( "Top level nodes, using IterateChildren.", 3, count );

		// Walk all the elements in a node.
		count = 0;
		for( element = todoElement->FirstChildElement();
			 element;
			 element = element->NextSiblingElement() )
		{
			count++;
		}
		XmlTest( "Children of the 'ToDo' element, using First / Next.",
			3, count );

		// Walk all the elements in a node by value.
		count = 0;
		for( node = todoElement->FirstChild( "Item" );
			 node;
			 node = node->NextSibling( "Item" ) )
		{
			count++;
		}
		XmlTest( "'Item' children of the 'ToDo' element, using First/Next.", 3, count );

		count = 0;
		for( node = todoElement->LastChild( "Item" );
			 node;
			 node = node->PreviousSibling( "Item" ) )
		{
			count++;
		}
		XmlTest( "'Item' children of the 'ToDo' element, using Last/Previous.", 3, count );

	#ifdef TIXML_USE_STL
		{
			cout << "\n** Parsing. **\n";
			istringstream parse0( "<Element0 attribute0='foo0' attribute1= noquotes attribute2 = '&gt;' />" );
			TiXmlElement element0( "default" );
			parse0 >> element0;

			XmlTest ( "Element parsed, value is 'Element0'.", "Element0", element0.Value() );
			XmlTest ( "Reads attribute 'attribute0=\"foo0\"'.", "foo0", element0.Attribute( "attribute0" ));
			XmlTest ( "Reads incorrectly formatted 'attribute1=noquotes'.", "noquotes", element0.Attribute( "attribute1" ) );
			XmlTest ( "Read attribute with entity value '>'.", ">", element0.Attribute( "attribute2" ) );
		}
	#endif

		{
			const char* error =	"<?xml version=\"1.0\" standalone=\"no\" ?>\n"
								"<passages count=\"006\" formatversion=\"20020620\">\n"
								"    <wrong error>\n"
								"</passages>";

			TiXmlDocument docTest;
			docTest.Parse( error );
			XmlTest( "Error row", docTest.ErrorRow(), 3 );
			XmlTest( "Error column", docTest.ErrorCol(), 17 );
			//printf( "error=%d id='%s' row %d col%d\n", (int) doc.Error(), doc.ErrorDesc(), doc.ErrorRow()+1, doc.ErrorCol() + 1 );

		}

	#ifdef TIXML_USE_STL
		{
			//////////////////////////////////////////////////////
			cout << "\n** Streaming. **\n";

			// Round trip check: stream in, then stream back out to verify. The stream
			// out has already been checked, above. We use the output

			istringstream inputStringStream( outputStream.str() );
			TiXmlDocument document0;

			inputStringStream >> document0;

			ostringstream outputStream0( ostringstream::out );
			outputStream0 << document0;

			XmlTest( "Stream round trip correct.",	string( demoEnd ).c_str(), 
													outputStream0.str().c_str(), true );

			std::string str;
			str << document0;

			XmlTest( "String printing correct.", string( demoEnd ).c_str(), 
												 str.c_str(), true );
		}
	#endif
	}

	{
		const char* str = "<doc attr0='1' attr1='2.0' attr2='foo' />";

		TiXmlDocument doc;
		doc.Parse( str );

		TiXmlElement* ele = doc.FirstChildElement();

		int iVal, result;
		double dVal;

		result = ele->QueryDoubleAttribute( "attr0", &dVal );
		XmlTest( "Query attribute: int as double", result, TIXML_SUCCESS );
		XmlTest( "Query attribute: int as double", (int)dVal, 1 );
		result = ele->QueryDoubleAttribute( "attr1", &dVal );
		XmlTest( "Query attribute: double as double", (int)dVal, 2 );
		result = ele->QueryIntAttribute( "attr1", &iVal );
		XmlTest( "Query attribute: double as int", result, TIXML_SUCCESS );
		XmlTest( "Query attribute: double as int", iVal, 2 );
		result = ele->QueryIntAttribute( "attr2", &iVal );
		XmlTest( "Query attribute: not a number", result, TIXML_WRONG_TYPE );
		result = ele->QueryIntAttribute( "bar", &iVal );
		XmlTest( "Query attribute: does not exist", result, TIXML_NO_ATTRIBUTE );
	}

	{
		const char* str = "<doc/>";

		TiXmlDocument doc;
		doc.Parse( str );

		TiXmlElement* ele = doc.FirstChildElement();

		int iVal;
		double dVal;

		ele->SetAttribute( "str", "strValue" );
		ele->SetAttribute( "int", 1 );
		ele->SetDoubleAttribute( "double", -1.0 );

		const char* cStr = ele->Attribute( "str" );
		ele->QueryIntAttribute( "int", &iVal );
		ele->QueryDoubleAttribute( "double", &dVal );

		XmlTest( "Attribute round trip. c-string.", "strValue", cStr );
		XmlTest( "Attribute round trip. int.", 1, iVal );
		XmlTest( "Attribute round trip. double.", -1, (int)dVal );
	}
	
	{
		const char* str =	"\t<?xml version=\"1.0\" standalone=\"no\" ?>\t<room doors='2'>\n"
							"</room>";

		TiXmlDocument doc;
		doc.SetTabSize( 8 );
		doc.Parse( str );

		TiXmlHandle docHandle( &doc );
		TiXmlHandle roomHandle = docHandle.FirstChildElement( "room" );

		assert( docHandle.Node() );
		assert( roomHandle.Element() );

		TiXmlElement* room = roomHandle.Element();
		assert( room );
		TiXmlAttribute* doors = room->FirstAttribute();
		assert( doors );

		XmlTest( "Location tracking: Tab 8: room row", room->Row(), 1 );
		XmlTest( "Location tracking: Tab 8: room col", room->Column(), 49 );
		XmlTest( "Location tracking: Tab 8: doors row", doors->Row(), 1 );
		XmlTest( "Location tracking: Tab 8: doors col", doors->Column(), 55 );
	}
	
	{
		const char* str =	"\t<?xml version=\"1.0\" standalone=\"no\" ?>\t<room doors='2'>\n"
							"  <!-- Silly example -->\n"
							"    <door wall='north'>A great door!</door>\n"
							"\t<door wall='east'/>"
							"</room>";

		TiXmlDocument doc;
		doc.Parse( str );

		TiXmlHandle docHandle( &doc );
		TiXmlHandle roomHandle = docHandle.FirstChildElement( "room" );
		TiXmlHandle commentHandle = docHandle.FirstChildElement( "room" ).FirstChild();
		TiXmlHandle textHandle = docHandle.FirstChildElement( "room" ).ChildElement( "door", 0 ).FirstChild();
		TiXmlHandle door0Handle = docHandle.FirstChildElement( "room" ).ChildElement( 0 );
		TiXmlHandle door1Handle = docHandle.FirstChildElement( "room" ).ChildElement( 1 );

		assert( docHandle.Node() );
		assert( roomHandle.Element() );
		assert( commentHandle.Node() );
		assert( textHandle.Text() );
		assert( door0Handle.Element() );
		assert( door1Handle.Element() );

		TiXmlDeclaration* declaration = doc.FirstChild()->ToDeclaration();
		assert( declaration );
		TiXmlElement* room = roomHandle.Element();
		assert( room );
		TiXmlAttribute* doors = room->FirstAttribute();
		assert( doors );
		TiXmlText* text = textHandle.Text();
		TiXmlComment* comment = commentHandle.Node()->ToComment();
		assert( comment );
		TiXmlElement* door0 = door0Handle.Element();
		TiXmlElement* door1 = door1Handle.Element();

		XmlTest( "Location tracking: Declaration row", declaration->Row(), 1 );
		XmlTest( "Location tracking: Declaration col", declaration->Column(), 5 );
		XmlTest( "Location tracking: room row", room->Row(), 1 );
		XmlTest( "Location tracking: room col", room->Column(), 45 );
		XmlTest( "Location tracking: doors row", doors->Row(), 1 );
		XmlTest( "Location tracking: doors col", doors->Column(), 51 );
		XmlTest( "Location tracking: Comment row", comment->Row(), 2 );
		XmlTest( "Location tracking: Comment col", comment->Column(), 3 );
		XmlTest( "Location tracking: text row", text->Row(), 3 ); 
		XmlTest( "Location tracking: text col", text->Column(), 24 );
		XmlTest( "Location tracking: door0 row", door0->Row(), 3 );
		XmlTest( "Location tracking: door0 col", door0->Column(), 5 );
		XmlTest( "Location tracking: door1 row", door1->Row(), 4 );
		XmlTest( "Location tracking: door1 col", door1->Column(), 5 );
	}


	// --------------------------------------------------------
	// UTF-8 testing. It is important to test:
	//	1. Making sure name, value, and text read correctly
	//	2. Row, Col functionality
	//	3. Correct output
	// --------------------------------------------------------
	printf ("\n** UTF-8 **\n");
	{
		TiXmlDocument doc( "utf8test.xml" );
		doc.LoadFile();
		if ( doc.Error() && doc.ErrorId() == TiXmlBase::TIXML_ERROR_OPENING_FILE ) {
			printf( "WARNING: File 'utf8test.xml' not found.\n"
					"(Are you running the test from the wrong directory?)\n"
				    "Could not test UTF-8 functionality.\n" );
		}
		else
		{
			TiXmlHandle docH( &doc );
			// Get the attribute "value" from the "Russian" element and check it.
			TiXmlElement* element = docH.FirstChildElement( "document" ).FirstChildElement( "Russian" ).Element();
			const unsigned char correctValue[] = {	0xd1U, 0x86U, 0xd0U, 0xb5U, 0xd0U, 0xbdU, 0xd0U, 0xbdU, 
													0xd0U, 0xbeU, 0xd1U, 0x81U, 0xd1U, 0x82U, 0xd1U, 0x8cU, 0 };

			XmlTest( "UTF-8: Russian value.", (const char*)correctValue, element->Attribute( "value" ), true );
			XmlTest( "UTF-8: Russian value row.", 4, element->Row() );
			XmlTest( "UTF-8: Russian value column.", 5, element->Column() );

			const unsigned char russianElementName[] = {	0xd0U, 0xa0U, 0xd1U, 0x83U,
															0xd1U, 0x81U, 0xd1U, 0x81U,
															0xd0U, 0xbaU, 0xd0U, 0xb8U,
															0xd0U, 0xb9U, 0 };
			const char russianText[] = "<\xD0\xB8\xD0\xBC\xD0\xB5\xD0\xB5\xD1\x82>";

			TiXmlText* text = docH.FirstChildElement( "document" ).FirstChildElement( (const char*) russianElementName ).Child( 0 ).Text();
			XmlTest( "UTF-8: Browsing russian element name.",
					 russianText,
					 text->Value(),
					 true );
			XmlTest( "UTF-8: Russian element name row.", 7, text->Row() );
			XmlTest( "UTF-8: Russian element name column.", 47, text->Column() );

			TiXmlDeclaration* dec = docH.Child( 0 ).Node()->ToDeclaration();
			XmlTest( "UTF-8: Declaration column.", 1, dec->Column() );
			XmlTest( "UTF-8: Document column.", 1, doc.Column() );

			// Now try for a round trip.
			doc.SaveFile( "utf8testout.xml" );

			// Check the round trip.
			char savedBuf[256];
			char verifyBuf[256];
			int okay = 1;

			FILE* saved  = fopen( "utf8testout.xml", "r" );
			FILE* verify = fopen( "utf8testverify.xml", "r" );
			if ( saved && verify )
			{
				while ( fgets( verifyBuf, 256, verify ) )
				{
					fgets( savedBuf, 256, saved );
					if ( strcmp( verifyBuf, savedBuf ) )
					{
						okay = 0;
						break;
					}
				}
				fclose( saved );
				fclose( verify );
			}
			XmlTest( "UTF-8: Verified multi-language round trip.", 1, okay );

			// On most Western machines, this is an element that contains
			// the word "resume" with the correct accents, in a latin encoding.
			// It will be something else completely on non-wester machines,
			// which is why TinyXml is switching to UTF-8.
			const char latin[] = "<element>r\x82sum\x82</element>";

			TiXmlDocument latinDoc;
			latinDoc.Parse( latin, 0, TIXML_ENCODING_LEGACY );

			text = latinDoc.FirstChildElement()->FirstChild()->ToText();
			XmlTest( "Legacy encoding: Verify text element.", "r\x82sum\x82", text->Value() );
		}
	}		

	//////////////////////
	// Copy and assignment
	//////////////////////
	printf ("\n** Copy and Assignment **\n");
	{
		TiXmlElement element( "foo" );
		element.Parse( "<element name='value' />", 0, TIXML_ENCODING_UNKNOWN );

		TiXmlElement elementCopy( element );
		TiXmlElement elementAssign( "foo" );
		elementAssign.Parse( "<incorrect foo='bar'/>", 0, TIXML_ENCODING_UNKNOWN );
		elementAssign = element;

		XmlTest( "Copy/Assign: element copy #1.", "element", elementCopy.Value() );
		XmlTest( "Copy/Assign: element copy #2.", "value", elementCopy.Attribute( "name" ) );
		XmlTest( "Copy/Assign: element assign #1.", "element", elementAssign.Value() );
		XmlTest( "Copy/Assign: element assign #2.", "value", elementAssign.Attribute( "name" ) );
		XmlTest( "Copy/Assign: element assign #3.", true, ( 0 == elementAssign.Attribute( "foo" )) );

		TiXmlComment comment;
		comment.Parse( "<!--comment-->", 0, TIXML_ENCODING_UNKNOWN );
		TiXmlComment commentCopy( comment );
		TiXmlComment commentAssign;
		commentAssign = commentCopy;
		XmlTest( "Copy/Assign: comment copy.", "comment", commentCopy.Value() );
		XmlTest( "Copy/Assign: comment assign.", "comment", commentAssign.Value() );

		TiXmlUnknown unknown;
		unknown.Parse( "<[unknown]>", 0, TIXML_ENCODING_UNKNOWN );
		TiXmlUnknown unknownCopy( unknown );
		TiXmlUnknown unknownAssign;
		unknownAssign.Parse( "incorrect", 0, TIXML_ENCODING_UNKNOWN );
		unknownAssign = unknownCopy;
		XmlTest( "Copy/Assign: unknown copy.", "[unknown]", unknownCopy.Value() );
		XmlTest( "Copy/Assign: unknown assign.", "[unknown]", unknownAssign.Value() );
		
		TiXmlText text( "TextNode" );
		TiXmlText textCopy( text );
		TiXmlText textAssign( "incorrect" );
		textAssign = text;
		XmlTest( "Copy/Assign: text copy.", "TextNode", textCopy.Value() );
		XmlTest( "Copy/Assign: text assign.", "TextNode", textAssign.Value() );

		TiXmlDeclaration dec;
		dec.Parse( "<?xml version='1.0' encoding='UTF-8'?>", 0, TIXML_ENCODING_UNKNOWN );
		TiXmlDeclaration decCopy( dec );
		TiXmlDeclaration decAssign;
		decAssign = dec;

		XmlTest( "Copy/Assign: declaration copy.", "UTF-8", decCopy.Encoding() );
		XmlTest( "Copy/Assign: text assign.", "UTF-8", decAssign.Encoding() );

		TiXmlDocument doc;
		elementCopy.InsertEndChild( textCopy );
		doc.InsertEndChild( decAssign );
		doc.InsertEndChild( elementCopy );
		doc.InsertEndChild( unknownAssign );

		TiXmlDocument docCopy( doc );
		TiXmlDocument docAssign;
		docAssign = docCopy;

		#ifdef TIXML_USE_STL
		std::string original, copy, assign;
		original << doc;
		copy << docCopy;
		assign << docAssign;
		XmlTest( "Copy/Assign: document copy.", original.c_str(), copy.c_str(), true );
		XmlTest( "Copy/Assign: document assign.", original.c_str(), assign.c_str(), true );

		#endif
	}	

	//////////////////////////////////////////////////////
#ifdef TIXML_USE_STL
	printf ("\n** Parsing, no Condense Whitespace **\n");
	TiXmlBase::SetCondenseWhiteSpace( false );
	{
		istringstream parse1( "<start>This  is    \ntext</start>" );
		TiXmlElement text1( "text" );
		parse1 >> text1;

		XmlTest ( "Condense white space OFF.", "This  is    \ntext",
					text1.FirstChild()->Value(),
					true );
	}
	TiXmlBase::SetCondenseWhiteSpace( true );
#endif

	//////////////////////////////////////////////////////
	// GetText();
	{
		const char* str = "<foo>This is text</foo>";
		TiXmlDocument doc;
		doc.Parse( str );
		const TiXmlElement* element = doc.RootElement();

		XmlTest( "GetText() normal use.", "This is text", element->GetText() );

		str = "<foo><b>This is text</b></foo>";
		doc.Clear();
		doc.Parse( str );
		element = doc.RootElement();

		XmlTest( "GetText() contained element.", element->GetText() == 0, true );

		str = "<foo>This is <b>text</b></foo>";
		doc.Clear();
		TiXmlBase::SetCondenseWhiteSpace( false );
		doc.Parse( str );
		TiXmlBase::SetCondenseWhiteSpace( true );
		element = doc.RootElement();

		XmlTest( "GetText() partial.", "This is ", element->GetText() );
	}


	//////////////////////////////////////////////////////
	// CDATA
	{
		const char* str =	"<xmlElement>"
								"<![CDATA["
									"I am > the rules!\n"
									"...since I make symbolic puns"
								"]]>"
							"</xmlElement>";
		TiXmlDocument doc;
		doc.Parse( str );
		doc.Print();

		XmlTest( "CDATA parse.", doc.FirstChildElement()->FirstChild()->Value(), 
								 "I am > the rules!\n...since I make symbolic puns",
								 true );

		#ifdef TIXML_USE_STL
		//cout << doc << '\n';

		doc.Clear();

		istringstream parse0( str );
		parse0 >> doc;
		//cout << doc << '\n';

		XmlTest( "CDATA stream.", doc.FirstChildElement()->FirstChild()->Value(), 
								 "I am > the rules!\n...since I make symbolic puns",
								 true );
		#endif

		TiXmlDocument doc1 = doc;
		//doc.Print();

		XmlTest( "CDATA copy.", doc1.FirstChildElement()->FirstChild()->Value(), 
								 "I am > the rules!\n...since I make symbolic puns",
								 true );
	}
	{
		// [ 1482728 ] Wrong wide char parsing
		char buf[256];
		buf[255] = 0;
		for( int i=0; i<255; ++i ) {
			buf[i] = (char)((i>=32) ? i : 32);
		}
		TIXML_STRING str( "<xmlElement><![CDATA[" );
		str += buf;
		str += "]]></xmlElement>";

		TiXmlDocument doc;
		doc.Parse( str.c_str() );

		TiXmlPrinter printer;
		printer.SetStreamPrinting();
		doc.Accept( &printer );

		XmlTest( "CDATA with all bytes #1.", str.c_str(), printer.CStr(), true );

		#ifdef TIXML_USE_STL
		doc.Clear();
		istringstream iss( printer.Str() );
		iss >> doc;
		std::string out;
		out << doc;
		XmlTest( "CDATA with all bytes #2.", out.c_str(), printer.CStr(), true );
		#endif
	}
	{
		// [ 1480107 ] Bug-fix for STL-streaming of CDATA that contains tags
		// CDATA streaming had a couple of bugs, that this tests for.
		const char* str =	"<xmlElement>"
								"<![CDATA["
									"<b>I am > the rules!</b>\n"
									"...since I make symbolic puns"
								"]]>"
							"</xmlElement>";
		TiXmlDocument doc;
		doc.Parse( str );
		doc.Print();

		XmlTest( "CDATA parse. [ 1480107 ]", doc.FirstChildElement()->FirstChild()->Value(), 
								 "<b>I am > the rules!</b>\n...since I make symbolic puns",
								 true );

		#ifdef TIXML_USE_STL

		doc.Clear();

		istringstream parse0( str );
		parse0 >> doc;

		XmlTest( "CDATA stream. [ 1480107 ]", doc.FirstChildElement()->FirstChild()->Value(), 
								 "<b>I am > the rules!</b>\n...since I make symbolic puns",
								 true );
		#endif

		TiXmlDocument doc1 = doc;
		//doc.Print();

		XmlTest( "CDATA copy. [ 1480107 ]", doc1.FirstChildElement()->FirstChild()->Value(), 
								 "<b>I am > the rules!</b>\n...since I make symbolic puns",
								 true );
	}
	//////////////////////////////////////////////////////
	// Visit()



	//////////////////////////////////////////////////////
	printf( "\n** Fuzzing... **\n" );

	const int FUZZ_ITERATION = 300;

	// The only goal is not to crash on bad input.
	int len = (int) strlen( demoStart );
	for( int i=0; i<FUZZ_ITERATION; ++i ) 
	{
		char* demoCopy = new char[ len+1 ];
		strcpy( demoCopy, demoStart );

		demoCopy[ i%len ] = (char)((i+1)*3);
		demoCopy[ (i*7)%len ] = '>';
		demoCopy[ (i*11)%len ] = '<';

		TiXmlDocument xml;
		xml.Parse( demoCopy );

		delete [] demoCopy;
	}
	printf( "** Fuzzing Complete. **\n" );
	
	//////////////////////////////////////////////////////
	printf ("\n** Bug regression tests **\n");

	// InsertBeforeChild and InsertAfterChild causes crash.
	{
		TiXmlElement parent( "Parent" );
		TiXmlElement childText0( "childText0" );
		TiXmlElement childText1( "childText1" );
		TiXmlNode* childNode0 = parent.InsertEndChild( childText0 );
		TiXmlNode* childNode1 = parent.InsertBeforeChild( childNode0, childText1 );

		XmlTest( "Test InsertBeforeChild on empty node.", ( childNode1 == parent.FirstChild() ), true );
	}

	{
		// InsertBeforeChild and InsertAfterChild causes crash.
		TiXmlElement parent( "Parent" );
		TiXmlElement childText0( "childText0" );
		TiXmlElement childText1( "childText1" );
		TiXmlNode* childNode0 = parent.InsertEndChild( childText0 );
		TiXmlNode* childNode1 = parent.InsertAfterChild( childNode0, childText1 );

		XmlTest( "Test InsertAfterChild on empty node. ", ( childNode1 == parent.LastChild() ), true );
	}

	// Reports of missing constructors, irregular string problems.
	{
		// Missing constructor implementation. No test -- just compiles.
		TiXmlText text( "Missing" );

		#ifdef TIXML_USE_STL
			// Missing implementation:
			TiXmlDocument doc;
			string name = "missing";
			doc.LoadFile( name );

			TiXmlText textSTL( name );
		#else
			// verifying some basic string functions:
			TiXmlString a;
			TiXmlString b( "Hello" );
			TiXmlString c( "ooga" );

			c = " World!";
			a = b;
			a += c;
			a = a;

			XmlTest( "Basic TiXmlString test. ", "Hello World!", a.c_str() );
		#endif
 	}

	// Long filenames crashing STL version
	{
		TiXmlDocument doc( "midsummerNightsDreamWithAVeryLongFilenameToConfuseTheStringHandlingRoutines.xml" );
		bool loadOkay = doc.LoadFile();
		loadOkay = true;	// get rid of compiler warning.
		// Won't pass on non-dev systems. Just a "no crash" check.
		//XmlTest( "Long filename. ", true, loadOkay );
	}

	{
		// Entities not being written correctly.
		// From Lynn Allen

		const char* passages =
			"<?xml version=\"1.0\" standalone=\"no\" ?>"
			"<passages count=\"006\" formatversion=\"20020620\">"
				"<psg context=\"Line 5 has &quot;quotation marks&quot; and &apos;apostrophe marks&apos;."
				" It also has &lt;, &gt;, and &amp;, as well as a fake copyright &#xA9;.\"> </psg>"
			"</passages>";

		TiXmlDocument doc( "passages.xml" );
		doc.Parse( passages );
		TiXmlElement* psg = doc.RootElement()->FirstChildElement();
		const char* context = psg->Attribute( "context" );
		const char* expected = "Line 5 has \"quotation marks\" and 'apostrophe marks'. It also has <, >, and &, as well as a fake copyright \xC2\xA9.";

		XmlTest( "Entity transformation: read. ", expected, context, true );

		FILE* textfile = fopen( "textfile.txt", "w" );
		if ( textfile )
		{
			psg->Print( textfile, 0 );
			fclose( textfile );
		}
		textfile = fopen( "textfile.txt", "r" );
		assert( textfile );
		if ( textfile )
		{
			char buf[ 1024 ];
			fgets( buf, 1024, textfile );
			XmlTest( "Entity transformation: write. ",
					 "<psg context=\'Line 5 has &quot;quotation marks&quot; and &apos;apostrophe marks&apos;."
					 " It also has &lt;, &gt;, and &amp;, as well as a fake copyright \xC2\xA9.' />",
					 buf,
					 true );
		}
		fclose( textfile );
	}

    {
		FILE* textfile = fopen( "test5.xml", "w" );
		if ( textfile )
		{
            fputs("<?xml version='1.0'?><a.elem xmi.version='2.0'/>", textfile);
            fclose(textfile);

			TiXmlDocument doc;
            doc.LoadFile( "test5.xml" );
            XmlTest( "dot in element attributes and names", doc.Error(), 0);
		}
    }

	{
		FILE* textfile = fopen( "test6.xml", "w" );
		if ( textfile )
		{
            fputs("<element><Name>1.1 Start easy ignore fin thickness&#xA;</Name></element>", textfile );
            fclose(textfile);

            TiXmlDocument doc;
            bool result = doc.LoadFile( "test6.xml" );
            XmlTest( "Entity with one digit.", result, true );

			TiXmlText* text = doc.FirstChildElement()->FirstChildElement()->FirstChild()->ToText();
			XmlTest( "Entity with one digit.",
						text->Value(), "1.1 Start easy ignore fin thickness\n" );
		}
    }

	{
		// DOCTYPE not preserved (950171)
		// 
		const char* doctype =
			"<?xml version=\"1.0\" ?>"
			"<!DOCTYPE PLAY SYSTEM 'play.dtd'>"
			"<!ELEMENT title (#PCDATA)>"
			"<!ELEMENT books (title,authors)>"
			"<element />";

		TiXmlDocument doc;
		doc.Parse( doctype );
		doc.SaveFile( "test7.xml" );
		doc.Clear();
		doc.LoadFile( "test7.xml" );
		
		TiXmlHandle docH( &doc );
		TiXmlUnknown* unknown = docH.Child( 1 ).Unknown();
		XmlTest( "Correct value of unknown.", "!DOCTYPE PLAY SYSTEM 'play.dtd'", unknown->Value() );
		#ifdef TIXML_USE_STL
		TiXmlNode* node = docH.Child( 2 ).Node();
		std::string str;
		str << (*node);
		XmlTest( "Correct streaming of unknown.", "<!ELEMENT title (#PCDATA)>", str.c_str() );
		#endif
	}

	{
		// [ 791411 ] Formatting bug
		// Comments do not stream out correctly.
		const char* doctype = 
			"<!-- Somewhat<evil> -->";
		TiXmlDocument doc;
		doc.Parse( doctype );

		TiXmlHandle docH( &doc );
		TiXmlComment* comment = docH.Child( 0 ).Node()->ToComment();

		XmlTest( "Comment formatting.", " Somewhat<evil> ", comment->Value() );
		#ifdef TIXML_USE_STL
		std::string str;
		str << (*comment);
		XmlTest( "Comment streaming.", "<!-- Somewhat<evil> -->", str.c_str() );
		#endif
	}

	{
		// [ 870502 ] White space issues
		TiXmlDocument doc;
		TiXmlText* text;
		TiXmlHandle docH( &doc );
	
		const char* doctype0 = "<element> This has leading and trailing space </element>";
		const char* doctype1 = "<element>This has  internal space</element>";
		const char* doctype2 = "<element> This has leading, trailing, and  internal space </element>";

		TiXmlBase::SetCondenseWhiteSpace( false );
		doc.Clear();
		doc.Parse( doctype0 );
		text = docH.FirstChildElement( "element" ).Child( 0 ).Text();
		XmlTest( "White space kept.", " This has leading and trailing space ", text->Value() );

		doc.Clear();
		doc.Parse( doctype1 );
		text = docH.FirstChildElement( "element" ).Child( 0 ).Text();
		XmlTest( "White space kept.", "This has  internal space", text->Value() );

		doc.Clear();
		doc.Parse( doctype2 );
		text = docH.FirstChildElement( "element" ).Child( 0 ).Text();
		XmlTest( "White space kept.", " This has leading, trailing, and  internal space ", text->Value() );

		TiXmlBase::SetCondenseWhiteSpace( true );
		doc.Clear();
		doc.Parse( doctype0 );
		text = docH.FirstChildElement( "element" ).Child( 0 ).Text();
		XmlTest( "White space condensed.", "This has leading and trailing space", text->Value() );

		doc.Clear();
		doc.Parse( doctype1 );
		text = docH.FirstChildElement( "element" ).Child( 0 ).Text();
		XmlTest( "White space condensed.", "This has internal space", text->Value() );

		doc.Clear();
		doc.Parse( doctype2 );
		text = docH.FirstChildElement( "element" ).Child( 0 ).Text();
		XmlTest( "White space condensed.", "This has leading, trailing, and internal space", text->Value() );
	}

	{
		// Double attributes
		const char* doctype = "<element attr='red' attr='blue' />";

		TiXmlDocument doc;
		doc.Parse( doctype );
		
		XmlTest( "Parsing repeated attributes.", true, doc.Error() );	// is an  error to tinyxml (didn't use to be, but caused issues)
		//XmlTest( "Parsing repeated attributes.", "blue", doc.FirstChildElement( "element" )->Attribute( "attr" ) );
	}

	{
		// Embedded null in stream.
		const char* doctype = "<element att\0r='red' attr='blue' />";

		TiXmlDocument doc;
		doc.Parse( doctype );
		XmlTest( "Embedded null throws error.", true, doc.Error() );

		#ifdef TIXML_USE_STL
		istringstream strm( doctype );
		doc.Clear();
		doc.ClearError();
		strm >> doc;
		XmlTest( "Embedded null throws error.", true, doc.Error() );
		#endif
	}

    {
            // Legacy mode test. (This test may only pass on a western system)
            const char* str =
                        "<?xml version=\"1.0\" encoding=\"ISO-8859-1\"?>"
                        "<?"
                        "C鰊t鋘t咪鳇闹?
                        "</?";

            TiXmlDocument doc;
            doc.Parse( str );

            TiXmlHandle docHandle( &doc );
            TiXmlHandle aHandle = docHandle.FirstChildElement( "? );
            TiXmlHandle tHandle = aHandle.Child( 0 );
            assert( aHandle.Element() );
            assert( tHandle.Text() );
            XmlTest( "ISO-8859-1 Parsing.", "C鰊t鋘t咪鳇闹?, tHandle.Text()->Value() );
    }

	{
		// Empty documents should return TIXML_ERROR_PARSING_EMPTY, bug 1070717
		const char* str = "    ";
		TiXmlDocument doc;
		doc.Parse( str );
		XmlTest( "Empty document error TIXML_ERROR_DOCUMENT_EMPTY", TiXmlBase::TIXML_ERROR_DOCUMENT_EMPTY, doc.ErrorId() );
	}
	#ifndef TIXML_USE_STL
	{
		// String equality. [ 1006409 ] string operator==/!= no worky in all cases
		TiXmlString temp;
		XmlTest( "Empty tinyxml string compare equal", ( temp == "" ), true );

		TiXmlString    foo;
		TiXmlString    bar( "" );
		XmlTest( "Empty tinyxml string compare equal", ( foo == bar ), true );
	}

	#endif
	{
		// Bug [ 1195696 ] from marlonism
		TiXmlBase::SetCondenseWhiteSpace(false); 
		TiXmlDocument xml; 
		xml.Parse("<text><break/>This hangs</text>"); 
		XmlTest( "Test safe error return.", xml.Error(), false );
	}

	{
		// Bug [ 1243992 ] - another infinite loop
		TiXmlDocument doc;
		doc.SetCondenseWhiteSpace(false);
		doc.Parse("<p><pb></pb>test</p>");
	} 
	{
		// Low entities
		TiXmlDocument xml;
		xml.Parse( "<test>&#x0e;</test>" );
		const char result[] = { 0x0e, 0 };
		XmlTest( "Low entities.", xml.FirstChildElement()->GetText(), result );
		xml.Print();
	}
	{
		// Bug [ 1451649 ] Attribute values with trailing quotes not handled correctly
		TiXmlDocument xml;
		xml.Parse( "<foo attribute=bar\" />" );
		XmlTest( "Throw error with bad end quotes.", xml.Error(), true );
	}
	#ifdef TIXML_USE_STL
	{
		// Bug [ 1449463 ] Consider generic query
		TiXmlDocument xml;
		xml.Parse( "<foo bar='3' barStr='a string'/>" );

		TiXmlElement* ele = xml.FirstChildElement();
		double d;
		int i;
		float f;
		bool b;
		std::string str;

		XmlTest( "QueryValueAttribute", ele->QueryValueAttribute( "bar", &d ), TIXML_SUCCESS );
		XmlTest( "QueryValueAttribute", ele->QueryValueAttribute( "bar", &i ), TIXML_SUCCESS );
		XmlTest( "QueryValueAttribute", ele->QueryValueAttribute( "bar", &f ), TIXML_SUCCESS );
		XmlTest( "QueryValueAttribute", ele->QueryValueAttribute( "bar", &b ), TIXML_WRONG_TYPE );
		XmlTest( "QueryValueAttribute", ele->QueryValueAttribute( "nobar", &b ), TIXML_NO_ATTRIBUTE );
		XmlTest( "QueryValueAttribute", ele->QueryValueAttribute( "barStr", &str ), TIXML_SUCCESS );

		XmlTest( "QueryValueAttribute", (d==3.0), true );
		XmlTest( "QueryValueAttribute", (i==3), true );
		XmlTest( "QueryValueAttribute", (f==3.0f), true );
		XmlTest( "QueryValueAttribute", (str==std::string( "a string" )), true );
	}
	#endif

	#ifdef TIXML_USE_STL
	{
		// [ 1505267 ] redundant malloc in TiXmlElement::Attribute
		TiXmlDocument xml;
		xml.Parse( "<foo bar='3' />" );
		TiXmlElement* ele = xml.FirstChildElement();
		double d;
		int i;

		std::string bar = "bar";

		const std::string* atrrib = ele->Attribute( bar );
		ele->Attribute( bar, &d );
		ele->Attribute( bar, &i );

		XmlTest( "Attribute", atrrib->empty(), false );
		XmlTest( "Attribute", (d==3.0), true );
		XmlTest( "Attribute", (i==3), true );
	}
	#endif

	{
		// [ 1356059 ] Allow TiXMLDocument to only be at the top level
		TiXmlDocument xml, xml2;
		xml.InsertEndChild( xml2 );
		XmlTest( "Document only at top level.", xml.Error(), true );
		XmlTest( "Document only at top level.", xml.ErrorId(), TiXmlBase::TIXML_ERROR_DOCUMENT_TOP_ONLY );
	}

	{
		// [ 1663758 ] Failure to report error on bad XML
		TiXmlDocument xml;
		xml.Parse("<x>");
		XmlTest("Missing end tag at end of input", xml.Error(), true);
		xml.Parse("<x> ");
		XmlTest("Missing end tag with trailing whitespace", xml.Error(), true);
	} 

	{
		// [ 1635701 ] fail to parse files with a tag separated into two lines
		// I'm not sure this is a bug. Marked 'pending' for feedback.
		TiXmlDocument xml;
		xml.Parse( "<title><p>text</p\n><title>" );
		//xml.Print();
		//XmlTest( "Tag split by newline", xml.Error(), false );
	}

	#ifdef TIXML_USE_STL
	{
		// [ 1475201 ] TinyXML parses entities in comments
		TiXmlDocument xml;
		istringstream parse1( "<!-- declarations for <head> & <body> -->"
						      "<!-- far &amp; away -->" );
		parse1 >> xml;

		TiXmlNode* e0 = xml.FirstChild();
		TiXmlNode* e1 = e0->NextSibling();
		TiXmlComment* c0 = e0->ToComment();
		TiXmlComment* c1 = e1->ToComment();

		XmlTest( "Comments ignore entities.", " declarations for <head> & <body> ", c0->Value(), true );
		XmlTest( "Comments ignore entities.", " far &amp; away ", c1->Value(), true );
	}
	#endif

	{
		// [ 1475201 ] TinyXML parses entities in comments
		TiXmlDocument xml;
		xml.Parse("<!-- declarations for <head> & <body> -->"
				  "<!-- far &amp; away -->" );

		TiXmlNode* e0 = xml.FirstChild();
		TiXmlNode* e1 = e0->NextSibling();
		TiXmlComment* c0 = e0->ToComment();
		TiXmlComment* c1 = e1->ToComment();

		XmlTest( "Comments ignore entities.", " declarations for <head> & <body> ", c0->Value(), true );
		XmlTest( "Comments ignore entities.", " far &amp; away ", c1->Value(), true );
	}

	{
		TiXmlDocument xml;
		xml.Parse( "<Parent>"
						"<child1 att=''/>"
						"<!-- With this comment, child2 will not be parsed! -->"
						"<child2 att=''/>"
					"</Parent>" );
		int count = 0;

		TiXmlNode* ele = 0;
		while ( (ele = xml.FirstChildElement( "Parent" )->IterateChildren( ele ) ) != 0 ) {
			++count;
		}
		XmlTest( "Comments iterate correctly.", 3, count );
	}

	{
		// trying to repro ]1874301]. If it doesn't go into an infinite loop, all is well.
		unsigned char buf[] = "<?xml version=\"1.0\" encoding=\"utf-8\"?><feed><![CDATA[Test XMLblablablalblbl";
		buf[60] = 239;
		buf[61] = 0;

		TiXmlDocument doc;
		doc.Parse( (const char*)buf);
	} 


	{
		// bug 1827248 Error while parsing a little bit malformed file
		// Actually not malformed - should work.
		TiXmlDocument xml;
		xml.Parse( "<attributelist> </attributelist >" );
		XmlTest( "Handle end tag whitespace", false, xml.Error() );
	}

	{
		// 1709904 - can not repro the crash
		{
			TiXmlDocument xml;
			xml.Parse( "<tag>/</tag>" );
			XmlTest( "Odd XML parsing.", xml.FirstChild()->Value(), "tag" );
		}
		/* Could not repro. {
			TiXmlDocument xml;
			xml.LoadFile( "EQUI_Inventory.xml" );
			//XmlTest( "Odd XML parsing.", xml.FirstChildElement()->Value(), "XML" );
			TiXmlPrinter printer;
			xml.Accept( &printer );
			fprintf( stdout, "%s", printer.CStr() );
		}*/
	}

	/*  1417717 experiment
	{
		TiXmlDocument xml;
		xml.Parse("<text>Dan & Tracie</text>");
		xml.Print(stdout);
	}
	{
		TiXmlDocument xml;
		xml.Parse("<text>Dan &foo; Tracie</text>");
		xml.Print(stdout);
	}
	*/
	#if defined( WIN32 ) && defined( TUNE )
	_CrtMemCheckpoint( &endMemState );
	//_CrtMemDumpStatistics( &endMemState );

	_CrtMemState diffMemState;
	_CrtMemDifference( &diffMemState, &startMemState, &endMemState );
	_CrtMemDumpStatistics( &diffMemState );
	#endif

	printf ("\nPass %d, Fail %d\n", gPass, gFail);
	return gFail;
}


37.读取XML数据库

38.写入XML数据库

39.ZIP压缩文件

40.ZIP解压缩

41.获得应用程序完整路径

42.ZIP压缩文件夹

43.递归删除目录下的文件

43.递归删除目录下的文件

44..IDEA加密算法
#include<stdio.h>
#include<process.h>
#include<conio.h>
#include<stdlib.h>
#define maxim 65537
#define fuyi 65536
#define one 65536
#define round 8

unsigned int inv(unsigned int xin);
unsigned int mul(unsigned int a,unsigned int b);
void cip(unsigned int IN[4],unsigned int OUT[4],unsigned int Z[7][10]);
void key(unsigned int uskey[9],unsigned int Z[7][10]);
void de_key(unsigned int Z[7][10],unsigned int DK[7][10]);

void main()
{ 
 int i,j,k,x;
    unsigned int Z[7][10],DK[7][10],XX[5],TT[5],YY[5];
    unsigned int uskey[9];
FILE *fpout,*fpin;
printf("\n Input Key");
for(i=1;i<=8;i++)
    scanf("%6u",&uskey[i]);
for(i=0;i<9;i++)
    uskey[i]=100+i*3;
    key(uskey,Z);/*产生加密子密钥*/
    de_key(Z,DK);/*计算解密子密钥*/
    if((fpin=fopen("ekey.txt","w"))==NULL)
    {
    printf("cannot open file!");
    exit(EXIT_FAILURE);
    }
    for(i=0;i<7;i++)
    {
    for(j=0;j<10;j++)
    fprintf(fpin,"%6u",Z[i][j]);
    fprintf(fpin,"\n");
    }
    fclose(fpin);
    
    /*XX[1..5]中为明文*/
    for(i=0;i<4;i++) XX[i]=2*i+101;
    clrscr();
    printf("Ming wen %6u %6u %6u %6u \n",XX[0],XX[1],XX[2],XX[3]);
    if((fpin=(fopen("ideaming.txt","w")))==NULL)
    {printf("cannot open file!");
    exit(EXIT_FAILURE);
    }
    fprintf(fpin,"%6u,%6u,%6u,%6u \n",XX[0],XX[1],XX[2],XX[3]);
    fclose(fpin);
    for(i=1;i<=30000;i++)
    cip(XX,YY,Z);/*用密钥Z加密XX中的明文并存在YY中*/
    printf("\n\n Mingwen %6u %6u %6u %6u \n",YY[0],YY[1],YY[2],YY[3]);
 if((fpin=fopen("ideamiwn.txt","w"))==NULL)
 {
 printf("cannot open file!");
    exit(EXIT_FAILURE);
    }
    fprintf(fpout,"%6u %6u %6u %6u\n",YY[0],YY[1],YY[2],YY[3]);
    {
    printf("cannot open file!");
    exit(EXIT_FAILURE);
    }
    fprintf(fpout,"%6u %6u %6u %6u \n",YY[0],YY[1],YY[2],YY[3]);
    fclose(fpout);
    for(i=1;i<=30000;i++)
    cip(YY,TT,DK);/*encipher YY to TT with Key DK*/
    printf("\n Jie Mi %6u %6u %6u %6u \n",TT[0],TT[1],TT[2],TT[3]);
    if((fpout=fopen("dideaout.txt","w"))==NULL)
    {
    printf("cannot open file!");
    exit(EXIT_FAILURE);
    }
    fprintf(fpout,"%6u %6u %6u %6u \n",TT[0],TT[1],TT[2],TT[3]);
    fclose(fpout);
    }
    /* 此函数执行IDEA算法中的加密过程*/
    
    void cip(unsigned int IN[4],unsigned int OUT[4],unsigned int Z[7][10])
    {
    unsigned int r,x1,x2,x3,x4,kk,t1,t2,a;
    x1=IN[0];x2=IN[1];x3=IN[2];x4=IN[3];
    for(r=1;r<=8;r++)
    {
    /* 对64位的块进行分组运算*/
    x1=mul(x1,Z[1][r]);x4=mul(x4,Z[4][r]);
    x2=x2+Z[2][r]&one;x3=(x3+Z[3][r])&one;
    /* MA结构的函数 */
    kk=mul(Z[5][r],(x1^x3));
    t1=mul(Z[6][r],(kk+(x2^x4))&one;
    /* 随机变换PI*/
    x1=x1^t1;x4=x4^t2;a=x2^t2;x2=x3^t1;x3=a;
    }
    /* 输出转换*/
    OUT[0]=mul(x1,Z[1][round+1]);
    OUT[3]=mul(x4,Z[1][round+1]);
    OUT[1]=(x3+Z[2][round+1])&one;
    OUT[2]=(x2+Z[3][round+1])&one;
    }
    
    /* 用高低算法上实现乘法运算*/
    unsigned int mul(unsigned int a,unsigned int b)
    {
    long int p;
    long unsigned q;
    if(a==0) p=maxim-b;
    else if(b==0) p=maxim-a;
    else
    {
    q=(unsigned long)a*(unsigned long)b;
    p=(q&one)-(q>>16);
    if(p<=0) p=p+maxim;
    {
    return (unsigned) (p&one);
    }
    
    /*通过Euclidean gcd算法计算xin的倒数*/
    unsigned int inv(unsigned int xin)
    {
    long n1,n2,q,r,b1,b2,t;
    if(xin==0)
    b2=0;
    else
    {n1=maxim;n2=xin;b2=1;b1=0;
    do{
    r=(n1%n2);q=(n1-r)/n2;
    if(r==0)
    if(b2<0) b2=maxim+b2;
    else
    {n1=n2;n2=r;
    t=b2;
    b2=b1-q*b2;b1=t;
    }
    }while(r!=0);
    }
    return (unsigned long int)b2;
    }
    
    
    /*产生加密子密钥Z*/
    void key(unsigned int uskey[9],unsigned int Z[7][10])
    {
    unsigned int S[54];
    int i,j,r;
    for(i=1;i<9;i++)
    S[i-1]=uskey[i];
    /* shifts */
    for(i=8;i<54;i++)
    {
    if(i+2)%8==0)/* 对于S[14],S[22],...进行计算 */
    S[i]=((S[i-7]<<0)^(S[i-14]>>7)&one;
    else if((i+1)%8==0)/* 对于S[15],S[23],...进行计算 */
    S[i]=((S[i-15]<<9)^(S[i-14]>>7)&one;
    else
    S[i]=((S[i-7]<<9)^(S[i-6]>>7)&one;
    }
    /*取得子密钥*/
    for(r=1;r<=round+1;r++)
      for(j=1;j<7;j++)
      Z[j][r]=S[6*(r-1)+j-1];
    }
    
    /* 计算解子密钥DK */
    void de_key(unsigned int Z[7][10],unsigned int DK[7][10])
    {
    int j;
    for(j=1;j<=round+1;j++)
    {DK[1][round-j+2]=inv(Z[1][j]);
    DK[4][round-j+2]=inv(Z[4][j]);
    if(i==1|j==round+1)
    {
    DK[2][round-j+2]=(fuyi-Z[2][j])&one;
    DK[3][round-j+2]=(fuyi-Z[3][j])&one;
    }
    else
    {
    DK[2][round-j+2]=inv(Z[3][j]);
    DK[3][round-j+2]=inv(Z[2][j]);
    }
    }
    for(j=1;j<=round+1;j++)
    {
    DK[5][round-j+2]=inv(Z[5][j]);
    DK[6][round-j+2]=inv(Z[6][j]);
    }
}

45.RC6算法
/* rc6 (TM) 
 * Unoptimized sample implementation of Ron Rivest's submission to the 
 * AES bakeoff. 
 * 
 * Salvo Salasio, 19 June 1998 
 * 
 * Intellectual property notes:  The name of the algorithm (RC6) is 
 * trademarked; any property rights to the algorithm or the trademark 
 * should be discussed with discussed with the authors of the defining 
 * paper "The RC6(TM) Block Cipher": Ronald L. Rivest (MIT), 
 * M.J.B. Robshaw (RSA Labs), R. Sidney (RSA Labs), and Y.L. Yin (RSA Labs), 
 * distributed 18 June 1998 and available from the lead author's web site. 
 * 
 * This sample implementation is placed in the public domain by the author, 
 * Salvo Salasio.  The ROTL and ROTR definitions were cribbed from RSA Labs' 
 * RC5 reference implementation. 
 */  
  
#include <stdio.h>  
  
/* RC6 is parameterized for w-bit words, b bytes of key, and 
 * r rounds.  The AES version of RC6 specifies b=16, 24, or 32; 
 * w=32; and r=20. 
 */  
    
#define w 32    /* word size in bits */  
#define r 20    /* based on security estimates */  
  
#define P32 0xB7E15163  /* Magic constants for key setup */  
#define Q32 0x9E3779B9  
  
/* derived constants */  
#define bytes   (w / 8)             /* bytes per word */  
#define c       ((b + bytes - 1) / bytes)   /* key in words, rounded up */  
#define R24     (2 * r + 4)  
#define lgw     5                           /* log2(w) -- wussed out */  
  
/* Rotations */  
#define ROTL(x,y) (((x)<<(y&(w-1))) | ((x)>>(w-(y&(w-1)))))  
#define ROTR(x,y) (((x)>>(y&(w-1))) | ((x)<<(w-(y&(w-1)))))  
  
unsigned int S[R24 - 1];        /* Key schedule */  
  
void rc6_key_setup(unsigned char *K, int b)  
{  
    int i, j, s, v;  
    unsigned int L[(32 + bytes - 1) / bytes]; /* Big enough for max b */  
    unsigned int A, B;  
  
    L[c - 1] = 0;  
    for (i = b - 1; i >= 0; i--)  
        L[i / bytes] = (L[i / bytes] << 8) + K[i];  
  
    S[0] = P32;  
    for (i = 1; i <= 2 * r + 3; i++)  
        S[i] = S[i - 1] + Q32;  
  
    A = B = i = j = 0;  
    v = R24;  
    if (c > v) v = c;  
    v *= 3;  
  
    for (s = 1; s <= v; s++)  
    {  
        A = S[i] = ROTL(S[i] + A + B, 3);  
        B = L[j] = ROTL(L[j] + A + B, A + B);  
        i = (i + 1) % R24;  
        j = (j + 1) % c;  
    }  
}  
  
void rc6_block_encrypt(unsigned int *pt, unsigned int *ct)  
{  
    unsigned int A, B, C, D, t, u, x;  
    int i, j;  
  
    A = pt[0];  
    B = pt[1];  
    C = pt[2];  
    D = pt[3];  
    B += S[0];  
    D += S[1];  
    for (i = 2; i <= 2 * r; i += 2)  
    {  
        t = ROTL(B * (2 * B + 1), lgw);  
        u = ROTL(D * (2 * D + 1), lgw);  
        A = ROTL(A ^ t, u) + S[i];  
        C = ROTL(C ^ u, t) + S[i + 1];  
        x = A;  
        A = B;  
        B = C;  
        C = D;  
        D = x;  
    }  
    A += S[2 * r + 2];  
    C += S[2 * r + 3];  
    ct[0] = A;  
    ct[1] = B;  
    ct[2] = C;  
    ct[3] = D;  
}  
  
void rc6_block_decrypt(unsigned int *ct, unsigned int *pt)  
{  
    unsigned int A, B, C, D, t, u, x;  
    int i, j;  
  
    A = ct[0];  
    B = ct[1];  
    C = ct[2];  
    D = ct[3];  
    C -= S[2 * r + 3];  
    A -= S[2 * r + 2];  
    for (i = 2 * r; i >= 2; i -= 2)  
    {  
        x = D;  
        D = C;  
        C = B;  
        B = A;  
        A = x;  
        u = ROTL(D * (2 * D + 1), lgw);  
        t = ROTL(B * (2 * B + 1), lgw);  
        C = ROTR(C - S[i + 1], t) ^ u;  
        A = ROTR(A - S[i], u) ^ t;  
    }  
    D -= S[1];  
    B -= S[0];  
    pt[0] = A;  
    pt[1] = B;  
    pt[2] = C;  
    pt[3] = D;    
}  
  
struct test_struct  
{  
    int keylen;  
    unsigned char key[32];  
    unsigned int pt[4];  
    unsigned int ct[4];  
} tests[] =  
{  
    { 16,   {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},  
        {0x00000000, 0x00000000, 0x00000000, 0x00000000},  
        {0x36a5c38f, 0x78f7b156, 0x4edf29c1, 0x1ea44898},  
    },  
  
    { 16,   {0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,  
         0x01, 0x12, 0x23, 0x34, 0x45, 0x56, 0x67, 0x78},  
        {0x35241302, 0x79685746, 0xbdac9b8a, 0xf1e0dfce},  
        {0x2f194e52, 0x23c61547, 0x36f6511f, 0x183fa47e},  
    },  
  
    { 24,   {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},  
        {0x00000000, 0x00000000, 0x00000000, 0x00000000},  
        {0xcb1bd66c, 0x38300b19, 0x163f8a4e, 0x82ae9086},  
    },  
  
    { 24,   {0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,  
         0x01, 0x12, 0x23, 0x34, 0x45, 0x56, 0x67, 0x78,  
         0x89, 0x9a, 0xab, 0xbc, 0xcd, 0xde, 0xef, 0xf0},  
        {0x35241302, 0x79685746, 0xbdac9b8a, 0xf1e0dfce},  
        {0xd0298368, 0x0405e519, 0x2ae9521e, 0xd49152f9},  
    },  
  
    { 32,   {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},  
        {0x00000000, 0x00000000, 0x00000000, 0x00000000},  
        {0x05bd5f8f, 0xa85fd110, 0xda3ffa93, 0xc27e856e},  
    },  
  
    { 32,   {0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,  
         0x01, 0x12, 0x23, 0x34, 0x45, 0x56, 0x67, 0x78,  
         0x89, 0x9a, 0xab, 0xbc, 0xcd, 0xde, 0xef, 0xf0,  
         0x10, 0x32, 0x54, 0x76, 0x98, 0xba, 0xdc, 0xfe},  
        {0x35241302, 0x79685746, 0xbdac9b8a, 0xf1e0dfce},  
        {0x161824c8, 0x89e4d7f0, 0xa116ad20, 0x485d4e67},  
    },  
  
    {       0,  
    }  
};
    unsigned int ct[4], pt[4];  
    int i;  
    struct test_struct *p;
    for (p = tests, i = 1; p->keylen; p++, i++)  
    {  
  
        rc6_key_setup(p->key, p->keylen);  
        rc6_block_encrypt(p->pt, ct);  
        printf("Test   %d:  %08x %08x %08x %08x\n",  
            i, ct[0], ct[1], ct[2], ct[3]);  
        printf("Should be: %08x %08x %08x %08x\n",  
            p->ct[0], p->ct[1], p->ct[2], p->ct[3]);  
        rc6_block_decrypt(ct, pt);  
        printf("Plain:     %08x %08x %08x %08x\n",  
            pt[0], pt[1], pt[2], pt[3]);  
        printf("Should be: %08x %08x %08x %08x\n\n",  
            p->pt[0], p->pt[1], p->pt[2], p->pt[3]);  
    }

46.Grep
/*
#include <memory.h>
#include <ctype.h>
#include <limits.h>
#include <string.h>
#include <stdlib.h>
*/
extern "C" {
	typedef int (*POSIX_FUNC)(int);
	int isblank(int c);
}

//
// Data Reference
//
template <class ELT> class CBufferRefT
{
public:
	CBufferRefT(const ELT * pcsz, int length);
	CBufferRefT(const ELT * pcsz);

public:
	int nCompare      (const ELT * pcsz) const;
	int nCompareNoCase(const ELT * pcsz) const;
	int  Compare      (const ELT * pcsz) const;
	int  CompareNoCase(const ELT * pcsz) const;
	int  Compare      (const CBufferRefT <ELT> &) const;
	int  CompareNoCase(const CBufferRefT <ELT> &) const;

	ELT At          (int nIndex, ELT def = 0) const;
	ELT operator [] (int nIndex) const;

	const ELT * GetBuffer() const;
	int GetSize() const;

public:
	virtual ~CBufferRefT();

// Content
protected:
	const ELT * m_pRef;
	int         m_nSize;
};

//
// Implemenation
//
template <class ELT> CBufferRefT <ELT> :: CBufferRefT(const ELT * pcsz, int length)
{
	m_pRef  = pcsz;
	m_nSize = length;
}

template <class ELT> CBufferRefT <ELT> :: CBufferRefT(const ELT * pcsz)
{
	m_pRef  = pcsz;
	m_nSize = 0;

	if(pcsz != 0) while(m_pRef[m_nSize] != 0) m_nSize ++;
}

template <class ELT> int CBufferRefT <ELT> :: nCompare(const ELT * pcsz) const
{
	for(int i=0; i<m_nSize; i++)
	{
		if(m_pRef[i] != pcsz[i])
			return m_pRef[i] - pcsz[i];
	}

	return 0;
}

template <class ELT> int CBufferRefT <ELT> :: nCompareNoCase(const ELT * pcsz) const
{
	for(int i=0; i<m_nSize; i++)
	{
		if(m_pRef[i] != pcsz[i])
		{
			if(toupper((int)m_pRef[i]) != toupper((int)pcsz[i]))
				return m_pRef[i] - pcsz[i];
		}
	}

	return 0;
}

template <class ELT> inline int CBufferRefT <ELT> :: Compare(const ELT * pcsz) const
{
	return nCompare(pcsz) ? 1 : (int)pcsz[m_nSize];
}

template <class ELT> inline int CBufferRefT <ELT> :: CompareNoCase(const ELT * pcsz) const
{
	return nCompareNoCase(pcsz) ? 1 : (int)pcsz[m_nSize];
}

template <class ELT> inline int CBufferRefT <ELT> :: Compare(const CBufferRefT <ELT> & cref) const
{
	return m_nSize == cref.m_nSize ? nCompare(cref.GetBuffer()) : 1;
}

template <class ELT> inline int CBufferRefT <ELT> :: CompareNoCase(const CBufferRefT <ELT> & cref) const
{
	return m_nSize == cref.m_nSize ? nCompareNoCase(cref.GetBuffer()) : 1;
}

template <class ELT> inline ELT CBufferRefT <ELT> :: At(int nIndex, ELT def) const
{
	return nIndex >= m_nSize ? def : m_pRef[nIndex];
}

template <class ELT> inline ELT CBufferRefT <ELT> :: operator [] (int nIndex) const
{
	return nIndex >= m_nSize ? 0 : m_pRef[nIndex];
}

template <class ELT> const ELT * CBufferRefT <ELT> :: GetBuffer() const
{
	static const ELT _def[] = {0}; return m_pRef ? m_pRef : _def;
}

template <class ELT> inline int CBufferRefT <ELT> :: GetSize() const
{
	return m_nSize;
}

template <class ELT> CBufferRefT <ELT> :: ~CBufferRefT()
{
}

//
// Data Buffer
//
template <class ELT> class CBufferT : public CBufferRefT <ELT>
{
public:
	CBufferT(const ELT * pcsz, int length);
	CBufferT(const ELT * pcsz);
	CBufferT();

public:
	ELT & operator [] (int nIndex);
	const ELT & operator [] (int nIndex) const;
	void  Append(const ELT * pcsz, int length, int eol = 0);
	void  Append(ELT el, int eol = 0);

public:
	void  Push(ELT   el);
	int   Pop (ELT & el);
	int   Peek(ELT & el) const;

public:
	const ELT * GetBuffer() const;
	ELT * GetBuffer();
	ELT * Detach();
	void  Release();
	void  Prepare(int index, int fill = 0);
	void  Restore(int size);

public:
	virtual ~CBufferT();

// Content
protected:
	ELT * m_pBuffer;
	int   m_nMaxLength;
};

//
// Implemenation
//
template <class ELT> CBufferT <ELT> :: CBufferT(const ELT * pcsz, int length) : CBufferRefT <ELT> (0, length)
{
	m_nMaxLength = CBufferRefT <ELT> :: m_nSize + 1;

	CBufferRefT <ELT> :: m_pRef = m_pBuffer = (ELT *) malloc(sizeof(ELT) * m_nMaxLength);
	memcpy(m_pBuffer, pcsz, sizeof(ELT) * CBufferRefT <ELT> :: m_nSize);
	m_pBuffer[CBufferRefT <ELT> :: m_nSize] = 0;
}

template <class ELT> CBufferT <ELT> :: CBufferT(const ELT * pcsz) : CBufferRefT <ELT> (pcsz)
{
	m_nMaxLength = CBufferRefT <ELT> :: m_nSize + 1;

	CBufferRefT <ELT> :: m_pRef = m_pBuffer = (ELT *) malloc(sizeof(ELT) * m_nMaxLength);
	memcpy(m_pBuffer, pcsz, sizeof(ELT) * CBufferRefT <ELT> :: m_nSize);
	m_pBuffer[CBufferRefT <ELT> :: m_nSize] = 0;
}

template <class ELT> CBufferT <ELT> :: CBufferT() : CBufferRefT <ELT> (0, 0)
{
	m_nMaxLength = 0;
	m_pBuffer    = 0;
}

template <class ELT> inline ELT & CBufferT <ELT> :: operator [] (int nIndex)
{
	return m_pBuffer[nIndex];
}

template <class ELT> inline const ELT & CBufferT <ELT> :: operator [] (int nIndex) const
{
	return m_pBuffer[nIndex];
}

template <class ELT> void CBufferT <ELT> :: Append(const ELT * pcsz, int length, int eol)
{
	int nNewLength = m_nMaxLength;

	// Check length
	if(nNewLength < 8)
		nNewLength = 8;

	if(CBufferRefT <ELT> :: m_nSize + length + eol > nNewLength)
		nNewLength *= 2;

	if(CBufferRefT <ELT> :: m_nSize + length + eol > nNewLength)
	{
		nNewLength  = CBufferRefT <ELT> :: m_nSize + length + eol + 11;
		nNewLength -= nNewLength % 8;
	}

	// Realloc
	if(nNewLength > m_nMaxLength)
	{
		CBufferRefT <ELT> :: m_pRef = m_pBuffer = (ELT *) realloc(m_pBuffer, sizeof(ELT) * nNewLength);
		m_nMaxLength = nNewLength;
	}

	// Append
	memcpy(m_pBuffer + CBufferRefT <ELT> :: m_nSize, pcsz, sizeof(ELT) * length);
	CBufferRefT <ELT> :: m_nSize += length;

	if(eol > 0) m_pBuffer[CBufferRefT <ELT> :: m_nSize] = 0;
}

template <class ELT> inline void CBufferT <ELT> :: Append(ELT el, int eol)
{
	Append(&el, 1, eol);
}

template <class ELT> void CBufferT <ELT> :: Push(ELT el)
{
	// Realloc
	if(CBufferRefT <ELT> :: m_nSize >= m_nMaxLength)
	{
		int nNewLength = m_nMaxLength * 2;
		if( nNewLength < 8 ) nNewLength = 8;

		CBufferRefT <ELT> :: m_pRef = m_pBuffer = (ELT *) realloc(m_pBuffer, sizeof(ELT) * nNewLength);
		m_nMaxLength = nNewLength;
	}

	// Append
	m_pBuffer[CBufferRefT <ELT> :: m_nSize++] = el;
}

template <class ELT> inline int CBufferT <ELT> :: Pop(ELT & el)
{
	if(CBufferRefT <ELT> :: m_nSize > 0)
	{
		el = m_pBuffer[--CBufferRefT <ELT> :: m_nSize];
		return 1;
	}
	else
	{
		return 0;
	}
}

template <class ELT> inline int CBufferT <ELT> :: Peek(ELT & el) const
{
	if(CBufferRefT <ELT> :: m_nSize > 0)
	{
		el = m_pBuffer[CBufferRefT <ELT> :: m_nSize - 1];
		return 1;
	}
	else
	{
		return 0;
	}
}

template <class ELT> const ELT * CBufferT <ELT> :: GetBuffer() const
{
	static const ELT _def[] = {0}; return m_pBuffer ? m_pBuffer : _def;
}

template <class ELT> ELT * CBufferT <ELT> :: GetBuffer()
{
	static const ELT _def[] = {0}; return m_pBuffer ? m_pBuffer : (ELT *)_def;
}

template <class ELT> ELT * CBufferT <ELT> :: Detach()
{
	ELT * pBuffer = m_pBuffer;

	CBufferRefT <ELT> :: m_pRef  = m_pBuffer    = 0;
	CBufferRefT <ELT> :: m_nSize = m_nMaxLength = 0;

	return pBuffer;
}

template <class ELT> void CBufferT <ELT> :: Release()
{
	ELT * pBuffer = Detach();

	if(pBuffer != 0) free(pBuffer);
}

template <class ELT> void CBufferT <ELT> :: Prepare(int index, int fill)
{
	int nNewSize = index + 1;

	// Realloc
	if(nNewSize > m_nMaxLength)
	{
		int nNewLength = m_nMaxLength;

		if( nNewLength < 8 )
			nNewLength = 8;

		if( nNewSize > nNewLength )
			nNewLength *= 2;

		if( nNewSize > nNewLength )
		{
			nNewLength  = nNewSize + 11;
			nNewLength -= nNewLength % 8;
		}

		CBufferRefT <ELT> :: m_pRef = m_pBuffer = (ELT *) realloc(m_pBuffer, sizeof(ELT) * nNewLength);
		m_nMaxLength = nNewLength;
	}

	// size
	if( CBufferRefT <ELT> :: m_nSize < nNewSize )
	{
		memset(m_pBuffer + CBufferRefT <ELT> :: m_nSize, fill, sizeof(ELT) * (nNewSize - CBufferRefT <ELT> :: m_nSize));
		CBufferRefT <ELT> :: m_nSize = nNewSize;
	}
}

template <class ELT> inline void CBufferT <ELT> :: Restore(int size)
{
	CBufferRefT <ELT> :: m_nSize = size;
}

template <class ELT> CBufferT <ELT> :: ~CBufferT()
{
	if(m_pBuffer != 0) free(m_pBuffer);
}

//
// Context
//
class CContext
{
public:
	CBufferT <int> m_stack;
	CBufferT <int> m_capturestack, m_captureindex;

public:
	int    m_nCurrentPos;
	int    m_nBeginPos;
	int    m_nLastBeginPos;
	int    m_nParenZindex;

	void * m_pMatchString;
	int    m_pMatchStringLength;
};

//
// Interface
//
class ElxInterface
{
public:
	virtual int Match    (CContext * pContext) const = 0;
	virtual int MatchNext(CContext * pContext) const = 0;

public:
	virtual ~ElxInterface() {};
};

//
// Alternative
//
template <int x> class CAlternativeElxT : public ElxInterface
{
public:
	int Match    (CContext * pContext) const;
	int MatchNext(CContext * pContext) const;

public:
	CAlternativeElxT();

public:
	CBufferT <ElxInterface *> m_elxlist;
};

typedef CAlternativeElxT <0> CAlternativeElx;

//
// Assert
//
template <int x> class CAssertElxT : public ElxInterface
{
public:
	int Match    (CContext * pContext) const;
	int MatchNext(CContext * pContext) const;

public:
	CAssertElxT(ElxInterface * pelx, int byes = 1);

public:
	ElxInterface * m_pelx;
	int m_byes;
};

typedef CAssertElxT <0> CAssertElx;

//
// Back reference elx
//
template <class CHART> class CBackrefElxT : public ElxInterface
{
public:
	int Match    (CContext * pContext) const;
	int MatchNext(CContext * pContext) const;

public:
	CBackrefElxT(int nnumber, int brightleft, int bignorecase);

public:
	int m_nnumber;
	int m_brightleft;
	int m_bignorecase;

	CBufferT <CHART> m_szNamed;
};

//
// Implementation
//
template <class CHART> CBackrefElxT <CHART> :: CBackrefElxT(int nnumber, int brightleft, int bignorecase)
{
	m_nnumber     = nnumber;
	m_brightleft  = brightleft;
	m_bignorecase = bignorecase;
}

template <class CHART> int CBackrefElxT <CHART> :: Match(CContext * pContext) const
{
	// check number, for named
	if( m_nnumber < 0 || m_nnumber >= pContext->m_captureindex.GetSize() ) return 0;

	int index = pContext->m_captureindex[m_nnumber];
	if( index < 0 ) return 0;

	// check enclosed
	int pos1 = pContext->m_capturestack[index + 1];
	int pos2 = pContext->m_capturestack[index + 2];

	if( pos2 < 0 ) pos2 = pContext->m_nCurrentPos;

	// info
	int lpos = pos1 < pos2 ? pos1 : pos2;
	int rpos = pos1 < pos2 ? pos2 : pos1;
	int slen = rpos - lpos;

	const CHART * pcsz = (const CHART *)pContext->m_pMatchString;
	int npos = pContext->m_nCurrentPos;
	int tlen = pContext->m_pMatchStringLength;

	// compare
	int bsucc;
	CBufferRefT <CHART> refstr(pcsz + lpos, slen);

	if( m_brightleft )
	{
		if(npos < slen)
			return 0;

		if(m_bignorecase)
			bsucc = ! refstr.nCompareNoCase(pcsz + (npos - slen));
		else
			bsucc = ! refstr.nCompare      (pcsz + (npos - slen));

		if( bsucc )
		{
			pContext->m_stack.Push(npos);
			pContext->m_nCurrentPos -= slen;
		}
	}
	else
	{
		if(npos + slen > tlen)
			return 0;

		if(m_bignorecase)
			bsucc = ! refstr.nCompareNoCase(pcsz + npos);
		else
			bsucc = ! refstr.nCompare      (pcsz + npos);

		if( bsucc )
		{
			pContext->m_stack.Push(npos);
			pContext->m_nCurrentPos += slen;
		}
	}

	return bsucc;
}

template <class CHART> int CBackrefElxT <CHART> :: MatchNext(CContext * pContext) const
{
	int npos = 0;

	pContext->m_stack.Pop(npos);
	pContext->m_nCurrentPos = npos;

	return 0;
}

// RCHART
#ifndef RCHART
	#define RCHART(ch) ((CHART)ch)
#endif

// BOUNDARY_TYPE
enum BOUNDARY_TYPE
{
	BOUNDARY_FILE_BEGIN, // begin of whole text
	BOUNDARY_FILE_END  , // end of whole text
	BOUNDARY_FILE_END_N, // end of whole text, or before newline at the end
	BOUNDARY_LINE_BEGIN, // begin of line
	BOUNDARY_LINE_END  , // end of line
	BOUNDARY_WORD_BEGIN, // begin of word
	BOUNDARY_WORD_END  , // end of word
	BOUNDARY_WORD_EDGE
};

//
// Boundary Elx
//
template <class CHART> class CBoundaryElxT : public ElxInterface
{
public:
	int Match    (CContext * pContext) const;
	int MatchNext(CContext * pContext) const;

public:
	CBoundaryElxT(int ntype, int byes = 1);

protected:
	static int IsWordChar(CHART ch);

public:
	int m_ntype;
	int m_byes;
};

//
// Implementation
//
template <class CHART> CBoundaryElxT <CHART> :: CBoundaryElxT(int ntype, int byes)
{
	m_ntype = ntype;
	m_byes  = byes;
}

template <class CHART> int CBoundaryElxT <CHART> :: Match(CContext * pContext) const
{
	const CHART * pcsz  = (const CHART *)pContext->m_pMatchString;
	int npos = pContext->m_nCurrentPos;
	int tlen = pContext->m_pMatchStringLength;

	CHART chL = npos > 0    ? pcsz[npos - 1] : 0;
	CHART chR = npos < tlen ? pcsz[npos    ] : 0;

	int bsucc = 0;

	switch(m_ntype)
	{
	case BOUNDARY_FILE_BEGIN:
		bsucc = (npos <= 0);
		break;

	case BOUNDARY_FILE_END:
		bsucc = (npos >= tlen);
		break;

	case BOUNDARY_FILE_END_N:
		bsucc = (npos >= tlen) || (pcsz[tlen-1] == RCHART('\n') && (npos == tlen-1 || (pcsz[tlen-2] == RCHART('\r') && npos == tlen-2)));
		break;

	case BOUNDARY_LINE_BEGIN:
		bsucc = (npos <= 0   ) || (chL == RCHART('\n')) || ((chL == RCHART('\r')) && (chR != RCHART('\n')));
		break;

	case BOUNDARY_LINE_END:
		bsucc = (npos >= tlen) || (chR == RCHART('\r')) || ((chR == RCHART('\n')) && (chL != RCHART('\r')));
		break;

	case BOUNDARY_WORD_BEGIN:
		bsucc = ! IsWordChar(chL) &&   IsWordChar(chR);
		break;

	case BOUNDARY_WORD_END:
		bsucc =   IsWordChar(chL) && ! IsWordChar(chR);
		break;

	case BOUNDARY_WORD_EDGE:
		bsucc =   IsWordChar(chL) ?  ! IsWordChar(chR) : IsWordChar(chR);
		break;
	}

	return m_byes ? bsucc : ! bsucc;
}

template <class CHART> int CBoundaryElxT <CHART> :: MatchNext(CContext *) const
{
	return 0;
}

template <class CHART> inline int CBoundaryElxT <CHART> :: IsWordChar(CHART ch)
{
	return (ch >= RCHART('A') && ch <= RCHART('Z')) || (ch >= RCHART('a') && ch <= RCHART('z')) || (ch >= RCHART('0') && ch <= RCHART('9')) || (ch == RCHART('_'));
}

//
// Bracket
//
template <class CHART> class CBracketElxT : public ElxInterface  
{
public:
	int Match    (CContext * pContext) const;
	int MatchNext(CContext * pContext) const;

public:
	CBracketElxT(int nnumber, int bright);
	int CheckCaptureIndex(int & index, CContext * pContext) const;

public:
	int m_nnumber;
	int m_bright;

	CBufferT <CHART> m_szNamed;
};

template <class CHART> CBracketElxT <CHART> :: CBracketElxT(int nnumber, int bright)
{
	m_nnumber = nnumber;
	m_bright  = bright;
}

template <class CHART> inline int CBracketElxT <CHART> :: CheckCaptureIndex(int & index, CContext * pContext) const
{
	if( index >= pContext->m_capturestack.GetSize() )
		index  = pContext->m_capturestack.GetSize() - 4;

	while(index >= 0)
	{
		if(pContext->m_capturestack[index] == m_nnumber)
		{
			return 1;
		}

		index -= 4;
	}


	return 0;
}

//
// capturestack[index+0] => Group number
// capturestack[index+1] => Capture start pos
// capturestack[index+2] => Capture end pos
// capturestack[index+3] => Capture enclose z-index, zindex<0 means inner group with same name
//
template <class CHART> int CBracketElxT <CHART> :: Match(CContext * pContext) const
{
	// check, for named
	if(m_nnumber < 0) return 0;

	if( ! m_bright )
	{
		pContext->m_captureindex.Prepare(m_nnumber, -1);
		int index = pContext->m_captureindex[m_nnumber];

		// check
		if(CheckCaptureIndex(index, pContext) && pContext->m_capturestack[index+2] < 0)
		{
			pContext->m_capturestack[index+3] --;
			return 1;
		}

		// save
		pContext->m_captureindex[m_nnumber] = pContext->m_capturestack.GetSize();

		pContext->m_capturestack.Push(m_nnumber);
		pContext->m_capturestack.Push(pContext->m_nCurrentPos);
		pContext->m_capturestack.Push(-1);
		pContext->m_capturestack.Push( 0); // z-index
	}
	else
	{
		// check
		int index = pContext->m_captureindex[m_nnumber];

		if(CheckCaptureIndex(index, pContext))
		{
			if(pContext->m_capturestack[index + 3] < 0) // check inner group with same name
			{
				pContext->m_capturestack[index + 3] ++;
				return 1;
			}

			// save
			pContext->m_capturestack[index + 2] = pContext->m_nCurrentPos;
			pContext->m_capturestack[index + 3] = pContext->m_nParenZindex ++;
		}
	}

	return 1;
}

template <class CHART> int CBracketElxT <CHART> :: MatchNext(CContext * pContext) const
{
	int index = pContext->m_captureindex[m_nnumber];
	if( ! CheckCaptureIndex(index, pContext) )
	{
		return 0;
	}

	if( ! m_bright )
	{
		if(pContext->m_capturestack[index + 3] < 0)
		{
			pContext->m_capturestack[index + 3] ++;
			return 0;
		}

		pContext->m_capturestack.Restore(pContext->m_capturestack.GetSize() - 4);

		// to find
		CheckCaptureIndex(index, pContext);

		// new index
		pContext->m_captureindex[m_nnumber] = index;
	}
	else
	{
		if( pContext->m_capturestack[index + 2] >= 0 )
		{
			pContext->m_capturestack[index + 2] = -1;
			pContext->m_capturestack[index + 3] =  0;
		}
		else
		{
			pContext->m_capturestack[index + 3] --;
		}
	}

	return 0;
}

//
// Deletage
//
template <class CHART> class CDelegateElxT : public ElxInterface  
{
public:
	int Match    (CContext * pContext) const;
	int MatchNext(CContext * pContext) const;

public:
	CDelegateElxT(int ndata = 0);

public:
	ElxInterface * m_pelx;
	int m_ndata; // +0 : recursive to
	             // -3 : named recursive

	CBufferT <CHART> m_szNamed;
};

template <class CHART> CDelegateElxT <CHART> :: CDelegateElxT(int ndata)
{
	m_pelx  = 0;
	m_ndata = ndata;
}

template <class CHART> int CDelegateElxT <CHART> :: Match(CContext * pContext) const
{
	if(m_pelx != 0)
		return m_pelx->Match(pContext);
	else
		return 1;
}

template <class CHART> int CDelegateElxT <CHART> :: MatchNext(CContext * pContext) const
{
	if(m_pelx != 0)
		return m_pelx->MatchNext(pContext);
	else
		return 0;
}

//
// Empty
//
template <int x> class CEmptyElxT : public ElxInterface
{
public:
	int Match    (CContext * pContext) const;
	int MatchNext(CContext * pContext) const;

public:
	CEmptyElxT();
};

typedef CEmptyElxT <0> CEmptyElx;

//
// Global
//
template <int x> class CGlobalElxT : public ElxInterface
{
public:
	int Match    (CContext * pContext) const;
	int MatchNext(CContext * pContext) const;

public:
	CGlobalElxT();
};

typedef CGlobalElxT <0> CGlobalElx;

//
// Repeat
//
template <int x> class CRepeatElxT : public ElxInterface
{
public:
	int Match    (CContext * pContext) const;
	int MatchNext(CContext * pContext) const;

public:
	CRepeatElxT(ElxInterface * pelx, int ntimes);

protected:
	int MatchFixed    (CContext * pContext) const;
	int MatchNextFixed(CContext * pContext) const;

public:
	ElxInterface * m_pelx;
	int m_nfixed;
};

typedef CRepeatElxT <0> CRepeatElx;

//
// Greedy
//
template <int x> class CGreedyElxT : public CRepeatElxT <x>
{
public:
	int Match    (CContext * pContext) const;
	int MatchNext(CContext * pContext) const;

public:
	CGreedyElxT(ElxInterface * pelx, int nmin = 0, int nmax = INT_MAX);

protected:
	int MatchVart    (CContext * pContext) const;
	int MatchNextVart(CContext * pContext) const;

public:
	int m_nvart;
};

typedef CGreedyElxT <0> CGreedyElx;

//
// Independent
//
template <int x> class CIndependentElxT : public ElxInterface
{
public:
	int Match    (CContext * pContext) const;
	int MatchNext(CContext * pContext) const;

public:
	CIndependentElxT(ElxInterface * pelx);

public:
	ElxInterface * m_pelx;
};

typedef CIndependentElxT <0> CIndependentElx;

//
// List
//
template <int x> class CListElxT : public ElxInterface
{
public:
	int Match    (CContext * pContext) const;
	int MatchNext(CContext * pContext) const;

public:
	CListElxT(int brightleft);

public:
	CBufferT <ElxInterface *> m_elxlist;
	int m_brightleft;
};

typedef CListElxT <0> CListElx;

//
// Posix Elx
//
template <class CHART> class CPosixElxT : public ElxInterface
{
public:
	int Match    (CContext * pContext) const;
	int MatchNext(CContext * pContext) const;

public:
	CPosixElxT(const char * posix, int brightleft);

public:
	POSIX_FUNC m_posixfun;
	int m_brightleft;
	int m_byes;
};

//
// Implementation
//
template <class CHART> CPosixElxT <CHART> :: CPosixElxT(const char * posix, int brightleft)
{
	m_brightleft = brightleft;

	if(posix[1] == '^')
	{
		m_byes = 0;
		posix += 2;
	}
	else
	{
		m_byes = 1;
		posix += 1;
	}

	if     (!strncmp(posix, "alnum:", 6)) m_posixfun = ::isalnum ;
	else if(!strncmp(posix, "alpha:", 6)) m_posixfun = ::isalpha ;
	else if(!strncmp(posix, "ascii:", 6)) m_posixfun = ::isascii ;
	else if(!strncmp(posix, "cntrl:", 6)) m_posixfun = ::iscntrl ;
	else if(!strncmp(posix, "digit:", 6)) m_posixfun = ::isdigit ;
	else if(!strncmp(posix, "graph:", 6)) m_posixfun = ::isgraph ;
	else if(!strncmp(posix, "lower:", 6)) m_posixfun = ::islower ;
	else if(!strncmp(posix, "print:", 6)) m_posixfun = ::isprint ;
	else if(!strncmp(posix, "punct:", 6)) m_posixfun = ::ispunct ;
	else if(!strncmp(posix, "space:", 6)) m_posixfun = ::isspace ;
	else if(!strncmp(posix, "upper:", 6)) m_posixfun = ::isupper ;
	else if(!strncmp(posix, "xdigit:",7)) m_posixfun = ::isxdigit;
	else if(!strncmp(posix, "blank:", 6)) m_posixfun =   isblank ;
	else                                  m_posixfun = 0         ;
}

inline int isblank(int c)
{
	return c == 0x20 || c == '\t';
}

template <class CHART> int CPosixElxT <CHART> :: Match(CContext * pContext) const
{
	if(m_posixfun == 0) return 0;

	int tlen = pContext->m_pMatchStringLength;
	int npos = pContext->m_nCurrentPos;

	// check
	int at   = m_brightleft ? npos - 1 : npos;
	if( at < 0 || at >= tlen )
		return 0;

	CHART ch = ((const CHART *)pContext->m_pMatchString)[at];

	int bsucc = (*m_posixfun)(ch);

	if( ! m_byes )
		bsucc = ! bsucc;

	if( bsucc )
		pContext->m_nCurrentPos += m_brightleft ? -1 : 1;

	return bsucc;
}

template <class CHART> int CPosixElxT <CHART> :: MatchNext(CContext * pContext) const
{
	pContext->m_nCurrentPos -= m_brightleft ? -1 : 1;
	return 0;
}

//
// Possessive
//
template <int x> class CPossessiveElxT : public CGreedyElxT <x>
{
public:
	int Match    (CContext * pContext) const;
	int MatchNext(CContext * pContext) const;

public:
	CPossessiveElxT(ElxInterface * pelx, int nmin = 0, int nmax = INT_MAX);
};

typedef CPossessiveElxT <0> CPossessiveElx;

//
// Range Elx
//
template <class CHART> class CRangeElxT : public ElxInterface
{
public:
	int Match    (CContext * pContext) const;
	int MatchNext(CContext * pContext) const;

public:
	CRangeElxT(int brightleft, int byes);

public:
	int IsContainChar(CHART ch) const;

public:
	CBufferT <CHART> m_ranges;
	CBufferT <CHART> m_chars;
	CBufferT <ElxInterface *> m_embeds;

public:
	int m_brightleft;
	int m_byes;
};

//
// Implementation
//
template <class CHART> CRangeElxT <CHART> :: CRangeElxT(int brightleft, int byes)
{
	m_brightleft = brightleft;
	m_byes       = byes;
}

template <class CHART> int CRangeElxT <CHART> :: Match(CContext * pContext) const
{
	int tlen = pContext->m_pMatchStringLength;
	int npos = pContext->m_nCurrentPos;

	// check
	int at   = m_brightleft ? npos - 1 : npos;
	if( at < 0 || at >= tlen )
		return 0;

	CHART ch = ((const CHART *)pContext->m_pMatchString)[at];
	int bsucc = 0, i;

	// compare
	for(i=0; !bsucc && i<m_ranges.GetSize(); i+=2)
	{
		if(m_ranges[i] <= ch && ch <= m_ranges[i+1]) bsucc = 1;
	}

	for(i=0; !bsucc && i<m_chars.GetSize(); i++)
	{
		if(m_chars[i] == ch) bsucc = 1;
	}

	for(i=0; !bsucc && i<m_embeds.GetSize(); i++)
	{
		if(m_embeds[i]->Match(pContext))
		{
			pContext->m_nCurrentPos = npos;
			bsucc = 1;
		}
	}

	if( ! m_byes )
		bsucc = ! bsucc;

	if( bsucc )
		pContext->m_nCurrentPos += m_brightleft ? -1 : 1;

	return bsucc;
}

template <class CHART> int CRangeElxT <CHART> :: IsContainChar(CHART ch) const
{
	int bsucc = 0, i;

	// compare
	for(i=0; !bsucc && i<m_ranges.GetSize(); i+=2)
	{
		if(m_ranges[i] <= ch && ch <= m_ranges[i+1]) bsucc = 1;
	}

	for(i=0; !bsucc && i<m_chars.GetSize(); i++)
	{
		if(m_chars[i] == ch) bsucc = 1;
	}

	return bsucc;
}

template <class CHART> int CRangeElxT <CHART> :: MatchNext(CContext * pContext) const
{
	pContext->m_nCurrentPos -= m_brightleft ? -1 : 1;
	return 0;
}

//
// Reluctant
//
template <int x> class CReluctantElxT : public CRepeatElxT <x>
{
public:
	int Match    (CContext * pContext) const;
	int MatchNext(CContext * pContext) const;

public:
	CReluctantElxT(ElxInterface * pelx, int nmin = 0, int nmax = INT_MAX);

protected:
	int MatchVart    (CContext * pContext) const;
	int MatchNextVart(CContext * pContext) const;

public:
	int m_nvart;
};

typedef CReluctantElxT <0> CReluctantElx;

//
// String Elx
//
template <class CHART> class CStringElxT : public ElxInterface
{
public:
	int Match    (CContext * pContext) const;
	int MatchNext(CContext * pContext) const;

public:
	CStringElxT(const CHART * fixed, int nlength, int brightleft, int bignorecase);

public:
	CBufferT <CHART> m_szPattern;
	int m_brightleft;
	int m_bignorecase;
};

//
// Implementation
//
template <class CHART> CStringElxT <CHART> :: CStringElxT(const CHART * fixed, int nlength, int brightleft, int bignorecase) : m_szPattern(fixed, nlength)
{
	m_brightleft  = brightleft;
	m_bignorecase = bignorecase;
}

template <class CHART> int CStringElxT <CHART> :: Match(CContext * pContext) const
{
	const CHART * pcsz  = (const CHART *)pContext->m_pMatchString;
	int npos = pContext->m_nCurrentPos;
	int tlen = pContext->m_pMatchStringLength;
	int slen = m_szPattern.GetSize();

	int bsucc;

	if(m_brightleft)
	{
		if(npos < slen)
			return 0;

		if(m_bignorecase)
			bsucc = ! m_szPattern.nCompareNoCase(pcsz + (npos - slen));
		else
			bsucc = ! m_szPattern.nCompare      (pcsz + (npos - slen));

		if( bsucc )
			pContext->m_nCurrentPos -= slen;
	}
	else
	{
		if(npos + slen > tlen)
			return 0;

		if(m_bignorecase)
			bsucc = ! m_szPattern.nCompareNoCase(pcsz + npos);
		else
			bsucc = ! m_szPattern.nCompare      (pcsz + npos);

		if( bsucc )
			pContext->m_nCurrentPos += slen;
	}

	return bsucc;
}

template <class CHART> int CStringElxT <CHART> :: MatchNext(CContext * pContext) const
{
	int slen = m_szPattern.GetSize();

	if(m_brightleft)
		pContext->m_nCurrentPos += slen;
	else
		pContext->m_nCurrentPos -= slen;

	return 0;
}

//
// CConditionElx
//
template <class CHART> class CConditionElxT : public ElxInterface
{
public:
	int Match    (CContext * pContext) const;
	int MatchNext(CContext * pContext) const;

public:
	CConditionElxT();

public:
	// backref condition
	int m_nnumber;
	CBufferT <CHART> m_szNamed;

	// elx condition
	ElxInterface * m_pelxask;

	// selection
	ElxInterface * m_pelxyes, * m_pelxno;
};

template <class CHART> CConditionElxT <CHART> :: CConditionElxT()
{
	m_nnumber = -1;
}

template <class CHART> int CConditionElxT <CHART> :: Match(CContext * pContext) const
{
	// status
	int nbegin = pContext->m_nCurrentPos;
	int nsize  = pContext->m_stack.GetSize();
	int ncsize = pContext->m_capturestack.GetSize();

	// condition result
	int condition_yes = 0;

	// backref type
	if( m_nnumber >= 0 )
	{
		do
		{
			if(m_nnumber >= pContext->m_captureindex.GetSize()) break;

			int index = pContext->m_captureindex[m_nnumber];
			if( index < 0) break;

			// else valid
			condition_yes = 1;
		}
		while(0);
	}
	else
	{
		if( m_pelxask == 0 )
			condition_yes = 1;
		else
			condition_yes = m_pelxask->Match(pContext);

		pContext->m_stack.Restore(nsize);
		pContext->m_nCurrentPos = nbegin;
	}

	// elx result
	int bsucc;
	if( condition_yes )
		bsucc = m_pelxyes == 0 ? 1 : m_pelxyes->Match(pContext);
	else
		bsucc = m_pelxno  == 0 ? 1 : m_pelxno ->Match(pContext);

	if( bsucc )
	{
		pContext->m_stack.Push(ncsize);
		pContext->m_stack.Push(condition_yes);
	}
	else
	{
		pContext->m_capturestack.Restore(ncsize);
	}

	return bsucc;
}

template <class CHART> int CConditionElxT <CHART> :: MatchNext(CContext * pContext) const
{
	// pop
	int ncsize, condition_yes;

	pContext->m_stack.Pop(condition_yes);
	pContext->m_stack.Pop(ncsize);

	// elx result
	int bsucc;
	if( condition_yes )
		bsucc = m_pelxyes == 0 ? 0 : m_pelxyes->MatchNext(pContext);
	else
		bsucc = m_pelxno  == 0 ? 0 : m_pelxno ->MatchNext(pContext);

	if( bsucc )
	{
		pContext->m_stack.Push(ncsize);
		pContext->m_stack.Push(condition_yes);
	}
	else
	{
		pContext->m_capturestack.Restore(ncsize);
	}

	return bsucc;
}

//
// MatchResult
//
template <int x> class MatchResultT
{
public:
	int IsMatched() const;

public:
	int GetStart() const;
	int GetEnd  () const;

public:
	int MaxGroupNumber() const;
	int GetGroupStart(int nGroupNumber) const;
	int GetGroupEnd  (int nGroupNumber) const;

public:
	MatchResultT(const MatchResultT <x> & from) { *this = from; }
	MatchResultT(CContext * pContext = 0, int nMaxNumber = -1);
	MatchResultT <x> & operator = (const MatchResultT <x> &);
	inline operator int() const { return IsMatched(); }

public:
	CBufferT <int> m_result;
};

typedef MatchResultT <0> MatchResult;

// Stocked Elx IDs
enum STOCKELX_ID_DEFINES
{
	STOCKELX_EMPTY = 0,

	///////////////////////

	STOCKELX_DOT_ALL,
	STOCKELX_DOT_NOT_ALL,

	STOCKELX_WORD,
	STOCKELX_WORD_NOT,

	STOCKELX_SPACE,
	STOCKELX_SPACE_NOT,

	STOCKELX_DIGITAL,
	STOCKELX_DIGITAL_NOT,

	//////////////////////

	STOCKELX_DOT_ALL_RIGHTLEFT,
	STOCKELX_DOT_NOT_ALL_RIGHTLEFT,

	STOCKELX_WORD_RIGHTLEFT,
	STOCKELX_WORD_RIGHTLEFT_NOT,

	STOCKELX_SPACE_RIGHTLEFT,
	STOCKELX_SPACE_RIGHTLEFT_NOT,

	STOCKELX_DIGITAL_RIGHTLEFT,
	STOCKELX_DIGITAL_RIGHTLEFT_NOT,

	/////////////////////

	STOCKELX_COUNT
};

// REGEX_FLAGS
#ifndef _REGEX_FLAGS_DEFINED
	enum REGEX_FLAGS
	{
		NO_FLAG        = 0,
		SINGLELINE     = 0x01,
		MULTILINE      = 0x02,
		GLOBAL         = 0x04,
		IGNORECASE     = 0x08,
		RIGHTTOLEFT    = 0x10,
		EXTENDED       = 0x20
	};
	#define _REGEX_FLAGS_DEFINED
#endif

//
// Builder T
//
template <class CHART> class CBuilderT
{
public:
	typedef CDelegateElxT  <CHART> CDelegateElx;
	typedef CBracketElxT   <CHART> CBracketElx;
	typedef CBackrefElxT   <CHART> CBackrefElx;
	typedef CConditionElxT <CHART> CConditionElx;

// Methods
public:
	ElxInterface * Build(const CBufferRefT <CHART> & pattern, int flags);
	int GetNamedNumber(const CBufferRefT <CHART> & named) const;
	void Clear();

public:
	 CBuilderT();
	~CBuilderT();

// Public Attributes
public:
	ElxInterface * m_pTopElx;
	int            m_nFlags;
	int            m_nMaxNumber;
	int            m_nNextNamed;
	int            m_nGroupCount;

	CBufferT <ElxInterface  *> m_objlist;
	CBufferT <ElxInterface  *> m_grouplist;
	CBufferT <CDelegateElx  *> m_recursivelist;
	CBufferT <CListElx      *> m_namedlist;
	CBufferT <CBackrefElx   *> m_namedbackreflist;
	CBufferT <CConditionElx *> m_namedconditionlist;

// CHART_INFO
protected:
	struct CHART_INFO
	{
	public:
		CHART ch;
		int   type;
		int   pos;
		int   len;

	public:
		CHART_INFO(CHART c, int t, int p = 0, int l = 0) { ch = c; type = t; pos = p; len = l;    }
		inline int operator == (const CHART_INFO & ci)   { return ch == ci.ch && type == ci.type; }
		inline int operator != (const CHART_INFO & ci)   { return ! operator == (ci);             }
	};

protected:
	static unsigned int Hex2Int(const CHART * pcsz, int length, int & used);
	static int ReadDec(char * & str, unsigned int & dec);
	void MoveNext();
	int  GetNext2();

	ElxInterface * BuildAlternative(int vaflags);
	ElxInterface * BuildList       (int & flags);
	ElxInterface * BuildRepeat     (int & flags);
	ElxInterface * BuildSimple     (int & flags);
	ElxInterface * BuildCharset    (int & flags);
	ElxInterface * BuildRecursive  (int & flags);
	ElxInterface * BuildBoundary   (int & flags);
	ElxInterface * BuildBackref    (int & flags);

	ElxInterface * GetStockElx     (int nStockId);
	ElxInterface * Keep(ElxInterface * pElx);

// Private Attributes
protected:
	CBufferRefT <CHART> m_pattern;
	CHART_INFO prev, curr, next, nex2;
	int m_nNextPos;
	int m_nCharsetDepth;
	int m_bQuoted;
	POSIX_FUNC m_quote_fun;

	ElxInterface * m_pStockElxs[STOCKELX_COUNT];
};

//
// Implementation
//
template <class CHART> CBuilderT <CHART> :: CBuilderT() : m_pattern(0, 0), prev(0, 0), curr(0, 0), next(0, 0), nex2(0, 0)
{
	Clear();
}

template <class CHART> CBuilderT <CHART> :: ~CBuilderT()
{
	Clear();
}

template <class CHART> int CBuilderT <CHART> :: GetNamedNumber(const CBufferRefT <CHART> & named) const
{
	for(int i=0; i<m_namedlist.GetSize(); i++)
	{
		if( ! ((CBracketElx *)m_namedlist[i]->m_elxlist[0])->m_szNamed.CompareNoCase(named) )
			return ((CBracketElx *)m_namedlist[i]->m_elxlist[0])->m_nnumber;
	}

	return -3;
}

template <class CHART> ElxInterface * CBuilderT <CHART> :: Build(const CBufferRefT <CHART> & pattern, int flags)
{
	// init
	m_pattern       = pattern;
	m_nNextPos      = 0;
	m_nCharsetDepth = 0;
	m_nMaxNumber    = 0;
	m_nNextNamed    = 0;
	m_nFlags        = flags;
	m_bQuoted       = 0;
	m_quote_fun     = 0;

	m_grouplist         .Restore(0);
	m_recursivelist     .Restore(0);
	m_namedlist         .Restore(0);
	m_namedbackreflist  .Restore(0);
	m_namedconditionlist.Restore(0);

	int i;
	for(i=0; i<3; i++) MoveNext();

	// build
	m_pTopElx = BuildAlternative(flags);

	// group 0
	m_grouplist.Prepare(0);
	m_grouplist[0] = m_pTopElx;

	// append named to unnamed
	m_nGroupCount = m_grouplist.GetSize();

	m_grouplist.Prepare(m_nMaxNumber + m_namedlist.GetSize());

	for(i=0; i<m_namedlist.GetSize(); i++)
	{
		CBracketElx * pleft  = (CBracketElx *)m_namedlist[i]->m_elxlist[0];
		CBracketElx * pright = (CBracketElx *)m_namedlist[i]->m_elxlist[2];

		// append
		m_grouplist[m_nGroupCount ++] = m_namedlist[i];

		if( pleft->m_nnumber > 0 )
			continue;

		// same name
		int find_same_name = GetNamedNumber(pleft->m_szNamed);
		if( find_same_name >= 0 )
		{
			pleft ->m_nnumber = find_same_name;
			pright->m_nnumber = find_same_name;
		}
		else
		{
			m_nMaxNumber ++;

			pleft ->m_nnumber = m_nMaxNumber;
			pright->m_nnumber = m_nMaxNumber;
		}
	}

	for(i=1; i<m_nGroupCount; i++)
	{
		CBracketElx * pleft = (CBracketElx *)((CListElx*)m_grouplist[i])->m_elxlist[0];

		if( pleft->m_nnumber > m_nMaxNumber )
			m_nMaxNumber = pleft->m_nnumber;
	}

	// connect recursive
	for(i=0; i<m_recursivelist.GetSize(); i++)
	{
		if( m_recursivelist[i]->m_ndata == -3 )
			m_recursivelist[i]->m_ndata = GetNamedNumber(m_recursivelist[i]->m_szNamed);

		if( m_recursivelist[i]->m_ndata >= 0 && m_recursivelist[i]->m_ndata <= m_nMaxNumber )
		{
			if( m_recursivelist[i]->m_ndata == 0 )
				m_recursivelist[i]->m_pelx = m_pTopElx;
			else for(int j=1; j<m_grouplist.GetSize(); j++)
			{
				if(m_recursivelist[i]->m_ndata == ((CBracketElx *)((CListElx*)m_grouplist[j])->m_elxlist[0])->m_nnumber)
				{
					m_recursivelist[i]->m_pelx = m_grouplist[j];
					break;
				}
			}
		}
	}

	// named backref
	for(i=0; i<m_namedbackreflist.GetSize(); i++)
	{
		m_namedbackreflist[i]->m_nnumber = GetNamedNumber(m_namedbackreflist[i]->m_szNamed);
	}

	// named condition
	for(i=0; i<m_namedconditionlist.GetSize(); i++)
	{
		int nn = GetNamedNumber(m_namedconditionlist[i]->m_szNamed);
		if( nn >= 0 )
		{
			m_namedconditionlist[i]->m_nnumber = nn;
			m_namedconditionlist[i]->m_pelxask = 0;
		}
	}

	return m_pTopElx;
}

template <class CHART> void CBuilderT <CHART> :: Clear()
{
	for(int i=0; i<m_objlist.GetSize(); i++)
	{
		delete m_objlist[i];
	}

	m_objlist.Restore(0);
	m_pTopElx = 0;
	m_nMaxNumber = 0;

	memset(m_pStockElxs, 0, sizeof(m_pStockElxs));
}

//
// hex to int
//
template <class CHART> unsigned int CBuilderT <CHART> :: Hex2Int(const CHART * pcsz, int length, int & used)
{
	unsigned int result = 0;
	int & i = used;

	for(i=0; i<length; i++)
	{
		if(pcsz[i] >= RCHART('0') && pcsz[i] <= RCHART('9'))
			result = (result << 4) + (pcsz[i] - RCHART('0'));
		else if(pcsz[i] >= RCHART('A') && pcsz[i] <= RCHART('F'))
			result = (result << 4) + (0x0A + (pcsz[i] - RCHART('A')));
		else if(pcsz[i] >= RCHART('a') && pcsz[i] <= RCHART('f'))
			result = (result << 4) + (0x0A + (pcsz[i] - RCHART('a')));
		else
			break;
	}

	return result;
}

template <class CHART> inline ElxInterface * CBuilderT <CHART> :: Keep(ElxInterface * pelx)
{
	m_objlist.Push(pelx);
	return pelx;
}

template <class CHART> void CBuilderT <CHART> :: MoveNext()
{
	// forwards
	prev = curr;
	curr = next;
	next = nex2;

	// get nex2
	while( ! GetNext2() ) {};
}

template <class CHART> int CBuilderT <CHART> :: GetNext2()
{
	// check length
	if(m_nNextPos >= m_pattern.GetSize())
	{
		nex2 = CHART_INFO(0, 1, m_nNextPos, 0);
		return 1;
	}

	int   delta = 1;
	CHART ch    = m_pattern[m_nNextPos];

	// if quoted
	if(m_bQuoted)
	{
		if(ch == RCHART('\\'))
		{
			if(m_pattern[m_nNextPos + 1] == RCHART('E'))
			{
				m_quote_fun = 0;
				m_bQuoted   = 0;
				m_nNextPos += 2;
				return 0;
			}
		}

		if(m_quote_fun != 0)
			nex2 = CHART_INFO((CHART)(*m_quote_fun)((int)ch), 0, m_nNextPos, delta);
		else
			nex2 = CHART_INFO(ch, 0, m_nNextPos, delta);

		m_nNextPos += delta;

		return 1;
	}

	// common
	switch(ch)
	{
	case RCHART('\\'):
		{
			CHART ch1 = m_pattern[m_nNextPos+1];

			// backref
			if(ch1 >= RCHART('0') && ch1 <= RCHART('9'))
			{
				nex2 = CHART_INFO(ch, 1, m_nNextPos, delta);
				break;
			}

			// escape
			delta     = 2;

			switch(ch1)
			{
			case RCHART('A'):
			case RCHART('Z'):
			case RCHART('z'):
			case RCHART('w'):
			case RCHART('W'):
			case RCHART('s'):
			case RCHART('S'):
			case RCHART('B'):
			case RCHART('d'):
			case RCHART('D'):
			case RCHART('k'):
			case RCHART('g'):
				nex2 = CHART_INFO(ch1, 1, m_nNextPos, delta);
				break;

			case RCHART('b'):
				if(m_nCharsetDepth > 0)
					nex2 = CHART_INFO('\b', 0, m_nNextPos, delta);
				else
					nex2 = CHART_INFO(ch1, 1, m_nNextPos, delta);
				break;

			/*
			case RCHART('<'):
			case RCHART('>'):
				if(m_nCharsetDepth > 0)
					nex2 = CHART_INFO(ch1, 0, m_nNextPos, delta);
				else
					nex2 = CHART_INFO(ch1, 1, m_nNextPos, delta);
				break;
			*/

			case RCHART('x'):
				if(m_pattern[m_nNextPos+2] != '{')
				{
					int red = 0;
					unsigned int ch2 = Hex2Int(m_pattern.GetBuffer() + m_nNextPos + 2, 2, red);

					delta += red;

					if(red > 0)
						nex2 = CHART_INFO(RCHART(ch2), 0, m_nNextPos, delta);
					else
						nex2 = CHART_INFO(ch1, 0, m_nNextPos, delta);

					break;
				}

			case RCHART('u'):
				if(m_pattern[m_nNextPos+2] != '{')
				{
					int red = 0;
					unsigned int ch2 = Hex2Int(m_pattern.GetBuffer() + m_nNextPos + 2, 4, red);

					delta += red;

					if(red > 0)
						nex2 = CHART_INFO(RCHART(ch2), 0, m_nNextPos, delta);
					else
						nex2 = CHART_INFO(ch1, 0, m_nNextPos, delta);
				}
				else
				{
					int red = 0;
					unsigned int ch2 = Hex2Int(m_pattern.GetBuffer() + m_nNextPos + 3, sizeof(int) * 2, red);

					delta += red;

					while(m_nNextPos + delta < m_pattern.GetSize() && m_pattern.At(m_nNextPos + delta) != RCHART('}'))
						delta ++;

					delta ++; // skip '}'

					nex2 = CHART_INFO(RCHART(ch2), 0, m_nNextPos, delta);
				}
				break;

			case RCHART('a'): nex2 = CHART_INFO(RCHART('\a'), 0, m_nNextPos, delta); break;
			case RCHART('f'): nex2 = CHART_INFO(RCHART('\f'), 0, m_nNextPos, delta); break;
			case RCHART('n'): nex2 = CHART_INFO(RCHART('\n'), 0, m_nNextPos, delta); break;
			case RCHART('r'): nex2 = CHART_INFO(RCHART('\r'), 0, m_nNextPos, delta); break;
			case RCHART('t'): nex2 = CHART_INFO(RCHART('\t'), 0, m_nNextPos, delta); break;
			case RCHART('v'): nex2 = CHART_INFO(RCHART('\v'), 0, m_nNextPos, delta); break;
			case RCHART('e'): nex2 = CHART_INFO(RCHART( 27 ), 0, m_nNextPos, delta); break;

			case RCHART('G'):  // skip '\G'
				if(m_nCharsetDepth > 0)
				{
					m_nNextPos += 2;
					return 0;
				}
				else
				{
					nex2 = CHART_INFO(ch1, 1, m_nNextPos, delta);
					break;
				}

			case RCHART('L'):
				if( ! m_quote_fun ) m_quote_fun = ::tolower;

			case RCHART('U'):
				if( ! m_quote_fun ) m_quote_fun = ::toupper;

			case RCHART('Q'):
				{
					m_bQuoted   = 1;
					m_nNextPos += 2;
					return 0;
				}

			case RCHART('E'):
				{
					m_quote_fun = 0;
					m_bQuoted   = 0;
					m_nNextPos += 2;
					return 0;
				}

			case 0:
				if(m_nNextPos+1 >= m_pattern.GetSize())
				{
					delta = 1;
					nex2 = CHART_INFO(ch , 0, m_nNextPos, delta);
				}
				else
					nex2 = CHART_INFO(ch1, 0, m_nNextPos, delta); // common '\0' char
				break;

			default:
				nex2 = CHART_INFO(ch1, 0, m_nNextPos, delta);
				break;
			}
		}
		break;

	case RCHART('*'):
	case RCHART('+'):
	case RCHART('?'):
	case RCHART('.'):
	case RCHART('{'):
	case RCHART('}'):
	case RCHART(')'):
	case RCHART('|'):
	case RCHART('$'):
		if(m_nCharsetDepth > 0)
			nex2 = CHART_INFO(ch, 0, m_nNextPos, delta);
		else
			nex2 = CHART_INFO(ch, 1, m_nNextPos, delta);
		break;

	case RCHART('-'):
		if(m_nCharsetDepth > 0)
			nex2 = CHART_INFO(ch, 1, m_nNextPos, delta);
		else
			nex2 = CHART_INFO(ch, 0, m_nNextPos, delta);
		break;

	case RCHART('('):
		{
			CHART ch1 = m_pattern[m_nNextPos+1];
			CHART ch2 = m_pattern[m_nNextPos+2];

			// skip remark
			if(ch1 == RCHART('?') && ch2 == RCHART('#'))
			{
				m_nNextPos += 2;
				while(m_nNextPos < m_pattern.GetSize())
				{
					if(m_pattern[m_nNextPos] == RCHART(')'))
						break;

					m_nNextPos ++;
				}

				if(m_pattern[m_nNextPos] == RCHART(')'))
				{
					m_nNextPos ++;

					// get next nex2
					return 0;
				}
			}
			else
			{
				if(m_nCharsetDepth > 0)
					nex2 = CHART_INFO(ch, 0, m_nNextPos, delta);
				else
					nex2 = CHART_INFO(ch, 1, m_nNextPos, delta);
			}
		}
		break;

	case RCHART('#'):
		if(m_nFlags & EXTENDED)
		{
			// skip remark
			m_nNextPos ++;

			while(m_nNextPos < m_pattern.GetSize())
			{
				if(m_pattern[m_nNextPos] == RCHART('\n') || m_pattern[m_nNextPos] == RCHART('\r'))
					break;

				m_nNextPos ++;
			}

			// get next nex2
			return 0;
		}
		else
		{
			nex2 = CHART_INFO(ch, 0, m_nNextPos, delta);
		}
		break;

	case RCHART(' '):
	case RCHART('\f'):
	case RCHART('\n'):
	case RCHART('\r'):
	case RCHART('\t'):
	case RCHART('\v'):
		if(m_nFlags & EXTENDED)
		{
			m_nNextPos ++;

			// get next nex2
			return 0;
		}
		else
		{
			nex2 = CHART_INFO(ch, 0, m_nNextPos, delta);
		}
		break;

	case RCHART('['):
		if( m_nCharsetDepth == 0 || m_pattern.At(m_nNextPos + 1, 0) == RCHART(':') )
		{
			m_nCharsetDepth ++;
			nex2 = CHART_INFO(ch, 1, m_nNextPos, delta);
		}
		else
		{
			nex2 = CHART_INFO(ch, 0, m_nNextPos, delta);
		}
		break;

	case RCHART(']'):
		if(m_nCharsetDepth > 0)
		{
			m_nCharsetDepth --;
			nex2 = CHART_INFO(ch, 1, m_nNextPos, delta);
		}
		else
		{
			nex2 = CHART_INFO(ch, 0, m_nNextPos, delta);
		}
		break;

	case RCHART(':'):
		if(next == CHART_INFO(RCHART('['), 1))
			nex2 = CHART_INFO(ch, 1, m_nNextPos, delta);
		else
			nex2 = CHART_INFO(ch, 0, m_nNextPos, delta);
		break;

	case RCHART('^'):
		if(m_nCharsetDepth == 0 || next == CHART_INFO(RCHART('['), 1) || (curr == CHART_INFO(RCHART('['), 1) && next == CHART_INFO(RCHART(':'), 1)))
			nex2 = CHART_INFO(ch, 1, m_nNextPos, delta);
		else
			nex2 = CHART_INFO(ch, 0, m_nNextPos, delta);
		break;

	case 0:
		if(m_nNextPos >= m_pattern.GetSize())
			nex2 = CHART_INFO(ch, 1, m_nNextPos, delta); // end of string
		else
			nex2 = CHART_INFO(ch, 0, m_nNextPos, delta); // common '\0' char
		break;

	default:
		nex2 = CHART_INFO(ch, 0, m_nNextPos, delta);
		break;
	}

	m_nNextPos += delta;

	return 1;
}

template <class CHART> ElxInterface * CBuilderT <CHART> :: GetStockElx(int nStockId)
{
	ElxInterface ** pStockElxs = m_pStockElxs;

	// check
	if(nStockId < 0 || nStockId >= STOCKELX_COUNT)
		return GetStockElx(0);

	// create if no
	if(pStockElxs[nStockId] == 0)
	{
		switch(nStockId)
		{
		case STOCKELX_EMPTY:
			pStockElxs[nStockId] = Keep(new CEmptyElx());
			break;

		case STOCKELX_WORD:
			{
				CRangeElxT <CHART> * pRange = (CRangeElxT <CHART> *)Keep(new CRangeElxT <CHART> (0, 1));

				pRange->m_ranges.Push(RCHART('A')); pRange->m_ranges.Push(RCHART('Z'));
				pRange->m_ranges.Push(RCHART('a')); pRange->m_ranges.Push(RCHART('z'));
				pRange->m_ranges.Push(RCHART('0')); pRange->m_ranges.Push(RCHART('9'));
				pRange->m_chars .Push(RCHART('_'));

				pStockElxs[nStockId] = pRange;
			}
			break;

		case STOCKELX_WORD_NOT:
			{
				CRangeElxT <CHART> * pRange = (CRangeElxT <CHART> *)Keep(new CRangeElxT <CHART> (0, 0));

				pRange->m_ranges.Push(RCHART('A')); pRange->m_ranges.Push(RCHART('Z'));
				pRange->m_ranges.Push(RCHART('a')); pRange->m_ranges.Push(RCHART('z'));
				pRange->m_ranges.Push(RCHART('0')); pRange->m_ranges.Push(RCHART('9'));
				pRange->m_chars .Push(RCHART('_'));

				pStockElxs[nStockId] = pRange;
			}
			break;

		case STOCKELX_DOT_ALL:
			pStockElxs[nStockId] = Keep(new CRangeElxT <CHART> (0, 0));
			break;

		case STOCKELX_DOT_NOT_ALL:
			{
				CRangeElxT <CHART> * pRange = (CRangeElxT <CHART> *)Keep(new CRangeElxT <CHART> (0, 0));

				pRange->m_chars .Push(RCHART('\n'));

				pStockElxs[nStockId] = pRange;
			}
			break;

		case STOCKELX_SPACE:
			{
				CRangeElxT <CHART> * pRange = (CRangeElxT <CHART> *)Keep(new CRangeElxT <CHART> (0, 1));

				pRange->m_chars .Push(RCHART(' '));
				pRange->m_chars .Push(RCHART('\t'));
				pRange->m_chars .Push(RCHART('\r'));
				pRange->m_chars .Push(RCHART('\n'));

				pStockElxs[nStockId] = pRange;
			}
			break;

		case STOCKELX_SPACE_NOT:
			{
				CRangeElxT <CHART> * pRange = (CRangeElxT <CHART> *)Keep(new CRangeElxT <CHART> (0, 0));

				pRange->m_chars .Push(RCHART(' '));
				pRange->m_chars .Push(RCHART('\t'));
				pRange->m_chars .Push(RCHART('\r'));
				pRange->m_chars .Push(RCHART('\n'));

				pStockElxs[nStockId] = pRange;
			}
			break;

		case STOCKELX_DIGITAL:
			{
				CRangeElxT <CHART> * pRange = (CRangeElxT <CHART> *)Keep(new CRangeElxT <CHART> (0, 1));

				pRange->m_ranges.Push(RCHART('0')); pRange->m_ranges.Push(RCHART('9'));

				pStockElxs[nStockId] = pRange;
			}
			break;

		case STOCKELX_DIGITAL_NOT:
			{
				CRangeElxT <CHART> * pRange = (CRangeElxT <CHART> *)Keep(new CRangeElxT <CHART> (0, 0));

				pRange->m_ranges.Push(RCHART('0')); pRange->m_ranges.Push(RCHART('9'));

				pStockElxs[nStockId] = pRange;
			}
			break;

		case STOCKELX_WORD_RIGHTLEFT:
			{
				CRangeElxT <CHART> * pRange = (CRangeElxT <CHART> *)Keep(new CRangeElxT <CHART> (1, 1));

				pRange->m_ranges.Push(RCHART('A')); pRange->m_ranges.Push(RCHART('Z'));
				pRange->m_ranges.Push(RCHART('a')); pRange->m_ranges.Push(RCHART('z'));
				pRange->m_ranges.Push(RCHART('0')); pRange->m_ranges.Push(RCHART('9'));
				pRange->m_chars .Push(RCHART('_'));

				pStockElxs[nStockId] = pRange;
			}
			break;

		case STOCKELX_WORD_RIGHTLEFT_NOT:
			{
				CRangeElxT <CHART> * pRange = (CRangeElxT <CHART> *)Keep(new CRangeElxT <CHART> (1, 0));

				pRange->m_ranges.Push(RCHART('A')); pRange->m_ranges.Push(RCHART('Z'));
				pRange->m_ranges.Push(RCHART('a')); pRange->m_ranges.Push(RCHART('z'));
				pRange->m_ranges.Push(RCHART('0')); pRange->m_ranges.Push(RCHART('9'));
				pRange->m_chars .Push(RCHART('_'));

				pStockElxs[nStockId] = pRange;
			}
			break;

		case STOCKELX_DOT_ALL_RIGHTLEFT:
			pStockElxs[nStockId] = Keep(new CRangeElxT <CHART> (1, 0));
			break;

		case STOCKELX_DOT_NOT_ALL_RIGHTLEFT:
			{
				CRangeElxT <CHART> * pRange = (CRangeElxT <CHART> *)Keep(new CRangeElxT <CHART> (1, 0));

				pRange->m_chars .Push(RCHART('\n'));

				pStockElxs[nStockId] = pRange;
			}
			break;

		case STOCKELX_SPACE_RIGHTLEFT:
			{
				CRangeElxT <CHART> * pRange = (CRangeElxT <CHART> *)Keep(new CRangeElxT <CHART> (1, 1));

				pRange->m_chars .Push(RCHART(' '));
				pRange->m_chars .Push(RCHART('\t'));
				pRange->m_chars .Push(RCHART('\r'));
				pRange->m_chars .Push(RCHART('\n'));
				pRange->m_chars .Push(RCHART('\f'));
				pRange->m_chars .Push(RCHART('\v'));

				pStockElxs[nStockId] = pRange;
			}
			break;

		case STOCKELX_SPACE_RIGHTLEFT_NOT:
			{
				CRangeElxT <CHART> * pRange = (CRangeElxT <CHART> *)Keep(new CRangeElxT <CHART> (1, 0));

				pRange->m_chars .Push(RCHART(' '));
				pRange->m_chars .Push(RCHART('\t'));
				pRange->m_chars .Push(RCHART('\r'));
				pRange->m_chars .Push(RCHART('\n'));
				pRange->m_chars .Push(RCHART('\f'));
				pRange->m_chars .Push(RCHART('\v'));

				pStockElxs[nStockId] = pRange;
			}
			break;

		case STOCKELX_DIGITAL_RIGHTLEFT:
			{
				CRangeElxT <CHART> * pRange = (CRangeElxT <CHART> *)Keep(new CRangeElxT <CHART> (1, 1));

				pRange->m_ranges.Push(RCHART('0')); pRange->m_ranges.Push(RCHART('9'));

				pStockElxs[nStockId] = pRange;
			}
			break;

		case STOCKELX_DIGITAL_RIGHTLEFT_NOT:
			{
				CRangeElxT <CHART> * pRange = (CRangeElxT <CHART> *)Keep(new CRangeElxT <CHART> (1, 0));

				pRange->m_ranges.Push(RCHART('0')); pRange->m_ranges.Push(RCHART('9'));

				pStockElxs[nStockId] = pRange;
			}
			break;
		}
	}

	// return
	return pStockElxs[nStockId];
}

template <class CHART> ElxInterface * CBuilderT <CHART> :: BuildAlternative(int vaflags)
{
	if(curr == CHART_INFO(0, 1))
		return GetStockElx(STOCKELX_EMPTY);

	// flag instance
	int flags = vaflags;

	// first part
	ElxInterface * pAlternativeOne = BuildList(flags);

	// check alternative
	if(curr == CHART_INFO(RCHART('|'), 1))
	{
		CAlternativeElx * pAlternative = (CAlternativeElx *)Keep(new CAlternativeElx());
		pAlternative->m_elxlist.Push(pAlternativeOne);

		// loop
		while(curr == CHART_INFO(RCHART('|'), 1))
		{
			// skip '|' itself
			MoveNext();

			pAlternativeOne = BuildList(flags);
			pAlternative->m_elxlist.Push(pAlternativeOne);
		}

		return pAlternative;
	}

	return pAlternativeOne;
}

template <class CHART> ElxInterface * CBuilderT <CHART> :: BuildList(int & flags)
{
	if(curr == CHART_INFO(0, 1) || curr == CHART_INFO(RCHART('|'), 1) || curr == CHART_INFO(RCHART(')'), 1))
		return GetStockElx(STOCKELX_EMPTY);

	// first
	ElxInterface * pListOne = BuildRepeat(flags);

	if(curr != CHART_INFO(0, 1) && curr != CHART_INFO(RCHART('|'), 1) && curr != CHART_INFO(RCHART(')'), 1))
	{
		CListElx * pList = (CListElx *)Keep(new CListElx(flags & RIGHTTOLEFT));
		pList->m_elxlist.Push(pListOne);

		while(curr != CHART_INFO(0, 1) && curr != CHART_INFO(RCHART('|'), 1) && curr != CHART_INFO(RCHART(')'), 1))
		{
			pListOne = BuildRepeat(flags);

			// add
			pList->m_elxlist.Push(pListOne);
		}

		return pList;
	}

	return pListOne;
}

template <class CHART> ElxInterface * CBuilderT <CHART> :: BuildRepeat(int & flags)
{
	// simple
	ElxInterface * pSimple = BuildSimple(flags);

	if(curr.type == 0) return pSimple;

	// is quantifier or not
	int bIsQuantifier = 1;

	// quantifier range
	unsigned int nMin = 0, nMax = 0;

	switch(curr.ch)
	{
	case RCHART('{'):
		{
			CBufferT <char> re;

			// skip '{'
			MoveNext();

			// copy
			while(curr != CHART_INFO(0, 1) && curr != CHART_INFO(RCHART('}'), 1))
			{
				re.Append(((curr.ch & (CHART)0xff) == curr.ch) ? (char)curr.ch : 0, 1);
				MoveNext();
			}

			// skip '}'
			MoveNext();

			// read
			int red;
			char * str = re.GetBuffer();

			if( ! ReadDec(str, nMin) )
				red = 0;
			else if( *str != ',' )
				red = 1;
			else
			{
				str ++;

				if( ! ReadDec(str, nMax) )
					red = 2;
				else
					red = 3;
			}

			// check
			if(red  <=  1 ) nMax = nMin;
			if(red  ==  2 ) nMax = INT_MAX;
			if(nMax < nMin) nMax = nMin;
		}
		break;

	case RCHART('?'):
		nMin = 0;
		nMax = 1;

		// skip '?'
		MoveNext();
		break;

	case RCHART('*'):
		nMin = 0;
		nMax = INT_MAX;

		// skip '*'
		MoveNext();
		break;

	case RCHART('+'):
		nMin = 1;
		nMax = INT_MAX;

		// skip '+'
		MoveNext();
		break;

	default:
		bIsQuantifier = 0;
		break;
	}

	// do quantify
	if(bIsQuantifier)
	{
		// 0 times
		if(nMax == 0)
			return GetStockElx(STOCKELX_EMPTY);

		// fixed times
		if(nMin == nMax)
		{
			if(curr == CHART_INFO(RCHART('?'), 1) || curr == CHART_INFO(RCHART('+'), 1))
				MoveNext();

			return Keep(new CRepeatElx(pSimple, nMin));
		}

		// range times
		if(curr == CHART_INFO(RCHART('?'), 1))
		{
			MoveNext();
			return Keep(new CReluctantElx(pSimple, nMin, nMax));
		}
		else if(curr == CHART_INFO(RCHART('+'), 1))
		{
			MoveNext();
			return Keep(new CPossessiveElx(pSimple, nMin, nMax));
		}
		else
		{
			return Keep(new CGreedyElx(pSimple, nMin, nMax));
		}
	}

	return pSimple;
}

template <class CHART> ElxInterface * CBuilderT <CHART> :: BuildSimple(int & flags)
{
	CBufferT <CHART> fixed;

	while(curr != CHART_INFO(0, 1))
	{
		if(curr.type == 0)
		{
			if(next == CHART_INFO(RCHART('{'), 1) || next == CHART_INFO(RCHART('?'), 1) || next == CHART_INFO(RCHART('*'), 1) || next == CHART_INFO(RCHART('+'), 1))
			{
				if(fixed.GetSize() == 0)
				{
					fixed.Append(curr.ch, 1);
					MoveNext();
				}

				break;
			}
			else
			{
				fixed.Append(curr.ch, 1);
				MoveNext();
			}
		}
		else if(curr.type == 1)
		{
			CHART vch = curr.ch;

			// end of simple
			if(vch == RCHART(')') || vch == RCHART('|'))
				break;

			// has fixed already
			if(fixed.GetSize() > 0)
				break;

			// left parentheses
			if(vch == RCHART('('))
			{
				return BuildRecursive(flags);
			}

			// char set
			if( vch == RCHART('[') || vch == RCHART('.') || vch == RCHART('w') || vch == RCHART('W') ||
				vch == RCHART('s') || vch == RCHART('S') || vch == RCHART('d') || vch == RCHART('D')
			)
			{
				return BuildCharset(flags);
			}

			// boundary
			if( vch == RCHART('^') || vch == RCHART('$') || vch == RCHART('A') || vch == RCHART('Z') || vch == RCHART('z') ||
				vch == RCHART('b') || vch == RCHART('B') || vch == RCHART('G') // vch == RCHART('<') || vch == RCHART('>')
			)
			{
				return BuildBoundary(flags);
			}

			// backref
			if(vch == RCHART('\\') || vch == RCHART('k') || vch == RCHART('g'))
			{
				return BuildBackref(flags);
			}

			// treat vchar as char
			fixed.Append(curr.ch, 1);
			MoveNext();
		}
	}

	if(fixed.GetSize() > 0)
		return Keep(new CStringElxT <CHART> (fixed.GetBuffer(), fixed.GetSize(), flags & RIGHTTOLEFT, flags & IGNORECASE));
	else
		return GetStockElx(STOCKELX_EMPTY);
}

#define max(a, b)  (((a) > (b)) ? (a) : (b))
#define min(a, b)  (((a) < (b)) ? (a) : (b))

template <class CHART> ElxInterface * CBuilderT <CHART> :: BuildCharset(int & flags)
{
	// char
	CHART ch = curr.ch;

	// skip
	MoveNext();

	switch(ch)
	{
	case RCHART('.'):
		return GetStockElx(
			flags & RIGHTTOLEFT ?
			((flags & SINGLELINE) ? STOCKELX_DOT_ALL_RIGHTLEFT : STOCKELX_DOT_NOT_ALL_RIGHTLEFT) :
			((flags & SINGLELINE) ? STOCKELX_DOT_ALL : STOCKELX_DOT_NOT_ALL)
		);

	case RCHART('w'):
		return GetStockElx(flags & RIGHTTOLEFT ? STOCKELX_WORD_RIGHTLEFT : STOCKELX_WORD);

	case RCHART('W'):
		return GetStockElx(flags & RIGHTTOLEFT ? STOCKELX_WORD_RIGHTLEFT_NOT : STOCKELX_WORD_NOT);

	case RCHART('s'):
		return GetStockElx(flags & RIGHTTOLEFT ? STOCKELX_SPACE_RIGHTLEFT : STOCKELX_SPACE);

	case RCHART('S'):
		return GetStockElx(flags & RIGHTTOLEFT ? STOCKELX_SPACE_RIGHTLEFT_NOT : STOCKELX_SPACE_NOT);

	case RCHART('d'):
		return GetStockElx(flags & RIGHTTOLEFT ? STOCKELX_DIGITAL_RIGHTLEFT : STOCKELX_DIGITAL);

	case RCHART('D'):
		return GetStockElx(flags & RIGHTTOLEFT ? STOCKELX_DIGITAL_RIGHTLEFT_NOT : STOCKELX_DIGITAL_NOT);

	case RCHART('['):
		{
			CRangeElxT <CHART> * pRange;

			// create
			if(curr == CHART_INFO(RCHART(':'), 1))
			{
				CBufferT <char> posix;

				do {
					posix.Append(((curr.ch & (CHART)0xff) == curr.ch) ? (char)curr.ch : 0, 1);
					MoveNext();
				}
				while(curr.ch != RCHART(0) && curr != CHART_INFO(RCHART(']'), 1));

				MoveNext(); // skip ']'

				// posix
				return Keep(new CPosixElxT <CHART> (posix.GetBuffer(), flags & RIGHTTOLEFT));
			}
			else if(curr == CHART_INFO(RCHART('^'), 1))
			{
				MoveNext(); // skip '^'
				pRange = (CRangeElxT <CHART> *)Keep(new CRangeElxT <CHART> (flags & RIGHTTOLEFT, 0));
			}
			else
			{
				pRange = (CRangeElxT <CHART> *)Keep(new CRangeElxT <CHART> (flags & RIGHTTOLEFT, 1));
			}

			// parse
			while(curr != CHART_INFO(0, 1) && curr != CHART_INFO(RCHART(']'), 1))
			{
				ch = curr.ch;

				if(curr.type == 1 && (
					ch == RCHART('.') || ch == RCHART('w') || ch == RCHART('W') || ch == RCHART('s') || ch == RCHART('S') || ch == RCHART('d') || ch == RCHART('D') ||
					(ch == RCHART('[') && next == CHART_INFO(RCHART(':'), 1))
				))
				{
					pRange->m_embeds.Push(BuildCharset(flags));
				}
				else if(next == CHART_INFO(RCHART('-'), 1) && nex2.type == 0)
				{
					pRange->m_ranges.Push(ch); pRange->m_ranges.Push(nex2.ch);

					// next
					MoveNext();
					MoveNext();
					MoveNext();
				}
				else
				{
					pRange->m_chars.Push(ch);

					// next
					MoveNext();
				}
			}

			// skip ']'
			MoveNext();

			if( flags & IGNORECASE )
			{
				CBufferT <CHART> & ranges = pRange->m_ranges;
				int i, oldcount = ranges.GetSize() / 2;

				for(i=0; i<oldcount; i++)
				{
					CHART newmin, newmax;

					if( ranges[i*2] <= RCHART('Z') && ranges[i*2+1] >= RCHART('A') )
					{
						newmin = tolower( max(RCHART('A'), ranges[i*2  ]) );
						newmax = tolower( min(RCHART('Z'), ranges[i*2+1]) );

						if( newmin < ranges[i*2] || newmax > ranges[i*2+1] )
						{
							ranges.Push(newmin);
							ranges.Push(newmax);
						}
					}

					if( ranges[i*2] <= RCHART('z') && ranges[i*2+1] >= RCHART('a') )
					{
						newmin = toupper( max(RCHART('a'), ranges[i*2  ]) );
						newmax = toupper( min(RCHART('z'), ranges[i*2+1]) );

						if( newmin < ranges[i*2] || newmax > ranges[i*2+1] )
						{
							ranges.Push(newmin);
							ranges.Push(newmax);
						}
					}
				}

				CBufferT <CHART> & chars = pRange->m_chars;
				oldcount = chars.GetSize();
				for(i=0; i<oldcount; i++)
				{
					if( isupper(chars[i]) && ! pRange->IsContainChar(tolower(chars[i])) )
						chars.Push(tolower(chars[i]));

					if( islower(chars[i]) && ! pRange->IsContainChar(toupper(chars[i])) )
						chars.Push(toupper(chars[i]));
				}
			}

			return pRange;
		}
	}

	return GetStockElx(STOCKELX_EMPTY);
}

template <class CHART> ElxInterface * CBuilderT <CHART> :: BuildRecursive(int & flags)
{
	// skip '('
	MoveNext();

	if(curr == CHART_INFO(RCHART('?'), 1))
	{
		ElxInterface * pElx = 0;

		// skip '?'
		MoveNext();

		int bNegative = 0;
		CHART named_end = RCHART('>');

		switch(curr.ch)
		{
		case RCHART('!'):
			bNegative = 1;

		case RCHART('='):
			{
				MoveNext(); // skip '!' or '='
				pElx = Keep(new CAssertElx(BuildAlternative(flags & ~RIGHTTOLEFT), !bNegative));
			}
			break;

		case RCHART('<'):
			switch(next.ch)
			{
			case RCHART('!'):
				bNegative = 1;

			case RCHART('='):
				MoveNext(); // skip '<'
				MoveNext(); // skip '!' or '='
				{
					pElx = Keep(new CAssertElx(BuildAlternative(flags | RIGHTTOLEFT), !bNegative));
				}
				break;

			default: // named group
				break;
			}
			// break if assertion // else named
			if(pElx != 0) break;

		case RCHART('P'):
			if(curr.ch == RCHART('P')) MoveNext(); // skip 'P'

		case RCHART('\''):
			if     (curr.ch == RCHART('<' )) named_end = RCHART('>' );
			else if(curr.ch == RCHART('\'')) named_end = RCHART('\'');
			MoveNext(); // skip '<' or '\''
			{
				// named number
				int nThisBackref = m_nNextNamed ++;

				CListElx    * pList  = (CListElx    *)Keep(new CListElx(flags & RIGHTTOLEFT));
				CBracketElx * pleft  = (CBracketElx *)Keep(new CBracketElx(-1, flags & RIGHTTOLEFT ? 1 : 0));
				CBracketElx * pright = (CBracketElx *)Keep(new CBracketElx(-1, flags & RIGHTTOLEFT ? 0 : 1));

				// save name
				CBufferT <CHART> & name = pleft->m_szNamed;
				CBufferT <char> num;

				while(curr.ch != RCHART(0) && curr.ch != named_end)
				{
					name.Append(curr.ch, 1);
					num .Append(((curr.ch & (CHART)0xff) == curr.ch) ? (char)curr.ch : 0, 1);
					MoveNext();
				}
				MoveNext(); // skip '>' or '\''

				// check <num>
				unsigned int number;
				char * str = num.GetBuffer();

				if( ReadDec(str, number) ? ( *str == '\0') : 0 )
				{
					pleft ->m_nnumber = number;
					pright->m_nnumber = number;

					name.Release();
				}

				// left, center, right
				pList->m_elxlist.Push(pleft);
				pList->m_elxlist.Push(BuildAlternative(flags));
				pList->m_elxlist.Push(pright);

				// for recursive
				m_namedlist.Prepare(nThisBackref);
				m_namedlist[nThisBackref] = pList;

				pElx = pList;
			}
			break;

		case RCHART('>'):
			{
				MoveNext(); // skip '>'
				pElx = Keep(new CIndependentElx(BuildAlternative(flags)));
			}
			break;

		case RCHART('R'):
			MoveNext(); // skip 'R'
			while(curr.ch != RCHART(0) && isspace(curr.ch)) MoveNext(); // skip space

			if(curr.ch == RCHART('<') || curr.ch == RCHART('\''))
			{
				named_end = curr.ch == RCHART('<') ? RCHART('>') : RCHART('\'');
				CDelegateElx * pDelegate = (CDelegateElx *)Keep(new CDelegateElx(-3));

				MoveNext(); // skip '<' or '\\'

				// save name
				CBufferT <CHART> & name = pDelegate->m_szNamed;
				CBufferT <char> num;

				while(curr.ch != RCHART(0) && curr.ch != named_end)
				{
					name.Append(curr.ch, 1);
					num .Append(((curr.ch & (CHART)0xff) == curr.ch) ? (char)curr.ch : 0, 1);
					MoveNext();
				}
				MoveNext(); // skip '>' or '\''

				// check <num>
				unsigned int number;
				char * str = num.GetBuffer();

				if( ReadDec(str, number) ? ( *str == '\0') : 0 )
				{
					pDelegate->m_ndata = number;
					name.Release();
				}

				m_recursivelist.Push(pDelegate);
				pElx = pDelegate;
			}
			else
			{
				CBufferT <char> rto;
				while(curr.ch != RCHART(0) && curr.ch != RCHART(')'))
				{
					rto.Append(((curr.ch & (CHART)0xff) == curr.ch) ? (char)curr.ch : 0, 1);
					MoveNext();
				}

				unsigned int rtono = 0;
				char * str = rto.GetBuffer();
				ReadDec(str, rtono);

				CDelegateElx * pDelegate = (CDelegateElx *)Keep(new CDelegateElx(rtono));

				m_recursivelist.Push(pDelegate);
				pElx = pDelegate;
			}
			break;

		case RCHART('('):
			{
				CConditionElx * pConditionElx = (CConditionElx *)Keep(new CConditionElx());

				// condition
				ElxInterface * & pCondition = pConditionElx->m_pelxask;

				if(next == CHART_INFO(RCHART('?'), 1))
				{
					pCondition = BuildRecursive(flags);
				}
				else // named, assert or number
				{
					MoveNext(); // skip '('
					int pos0 = curr.pos;

					// save elx condition
					pCondition = Keep(new CAssertElx(BuildAlternative(flags), 1));

					// save name
					pConditionElx->m_szNamed.Append(m_pattern.GetBuffer() + pos0, curr.pos - pos0, 1);

					// save number
					CBufferT <char> numstr;
					while(pos0 < curr.pos)
					{
						CHART ch = m_pattern[pos0];
						numstr.Append(((ch & (CHART)0xff) == ch) ? (char)ch : 0, 1);
						pos0 ++;
					}

					unsigned int number;
					char * str = numstr.GetBuffer();

					// valid group number
					if( ReadDec(str, number) ? ( *str == '\0') : 0 )
					{
						pConditionElx->m_nnumber = number;
						pCondition = 0;
					}
					else // maybe elx, maybe named
					{
						pConditionElx->m_nnumber = -1;
						m_namedconditionlist.Push(pConditionElx);
					}

					MoveNext(); // skip ')'
				}

				// alternative
				{
					int newflags = flags;

					pConditionElx->m_pelxyes = BuildList(newflags);
				}

				if(curr.ch == RCHART('|'))
				{
					MoveNext(); // skip '|'

					pConditionElx->m_pelxno = BuildAlternative(flags);
				}
				else
				{
					pConditionElx->m_pelxno = 0;
				}

				pElx = pConditionElx;
			}
			break;

		default:
			while(curr.ch != RCHART(0) && isspace(curr.ch)) MoveNext(); // skip space

			if(curr.ch >= RCHART('0') && curr.ch <= RCHART('9')) // recursive (?1) => (?R1)
			{
				CBufferT <char> rto;
				while(curr.ch != RCHART(0) && curr.ch != RCHART(')'))
				{
					rto.Append(((curr.ch & (CHART)0xff) == curr.ch) ? (char)curr.ch : 0, 1);
					MoveNext();
				}

				unsigned int rtono = 0;
				char * str = rto.GetBuffer();
				ReadDec(str, rtono);

				CDelegateElx * pDelegate = (CDelegateElx *)Keep(new CDelegateElx(rtono));

				m_recursivelist.Push(pDelegate);
				pElx = pDelegate;
			}
			else
			{
				// flag
				int newflags = flags;
				while(curr != CHART_INFO(0, 1) && curr.ch != RCHART(':') && curr.ch != RCHART(')') && curr != CHART_INFO(RCHART('('), 1))
				{
					int tochange = 0;

					switch(curr.ch)
					{
					case RCHART('i'):
					case RCHART('I'):
						tochange = IGNORECASE;
						break;

					case RCHART('s'):
					case RCHART('S'):
						tochange = SINGLELINE;
						break;

					case RCHART('m'):
					case RCHART('M'):
						tochange = MULTILINE;
						break;

					case RCHART('g'):
					case RCHART('G'):
						tochange = GLOBAL;
						break;

					case RCHART('-'):
						bNegative = 1;
						break;
					}

					if(bNegative)
						newflags &= ~tochange;
					else
						newflags |=  tochange;

					// move to next char
					MoveNext();
				}

				if(curr.ch == RCHART(':') || curr == CHART_INFO(RCHART('('), 1))
				{
					// skip ':'
					if(curr.ch == RCHART(':')) MoveNext();

					pElx = BuildAlternative(newflags);
				}
				else
				{
					// change parent flags
					flags = newflags;

					pElx = GetStockElx(STOCKELX_EMPTY);
				}
			}
			break;
		}

		MoveNext(); // skip ')'

		return pElx;
	}
	else
	{
		// group and number
		CListElx * pList = (CListElx *)Keep(new CListElx(flags & RIGHTTOLEFT));
		int nThisBackref = ++ m_nMaxNumber;

		// left, center, right
		pList->m_elxlist.Push(Keep(new CBracketElx(nThisBackref, flags & RIGHTTOLEFT ? 1 : 0)));
		pList->m_elxlist.Push(BuildAlternative(flags));
		pList->m_elxlist.Push(Keep(new CBracketElx(nThisBackref, flags & RIGHTTOLEFT ? 0 : 1)));

		// for recursive
		m_grouplist.Prepare(nThisBackref);
		m_grouplist[nThisBackref] = pList;

		// right
		MoveNext(); // skip ')' 

		return pList;
	}
}

template <class CHART> ElxInterface * CBuilderT <CHART> :: BuildBoundary(int & flags)
{
	// char
	CHART ch = curr.ch;

	// skip
	MoveNext();

	switch(ch)
	{
	case RCHART('^'):
		return Keep(new CBoundaryElxT <CHART> ((flags & MULTILINE) ? BOUNDARY_LINE_BEGIN : BOUNDARY_FILE_BEGIN));

	case RCHART('$'):
		return Keep(new CBoundaryElxT <CHART> ((flags & MULTILINE) ? BOUNDARY_LINE_END : BOUNDARY_FILE_END));

	case RCHART('b'):
		return Keep(new CBoundaryElxT <CHART> (BOUNDARY_WORD_EDGE));

	case RCHART('B'):
		return Keep(new CBoundaryElxT <CHART> (BOUNDARY_WORD_EDGE, 0));

	case RCHART('A'):
		return Keep(new CBoundaryElxT <CHART> (BOUNDARY_FILE_BEGIN));

	case RCHART('Z'):
		return Keep(new CBoundaryElxT <CHART> (BOUNDARY_FILE_END_N));

	case RCHART('z'):
		return Keep(new CBoundaryElxT <CHART> (BOUNDARY_FILE_END));

	case RCHART('G'):
		if(flags & GLOBAL)
			return Keep(new CGlobalElx());
		else
			return GetStockElx(STOCKELX_EMPTY);

	default:
		return GetStockElx(STOCKELX_EMPTY);
	}
}

template <class CHART> ElxInterface * CBuilderT <CHART> :: BuildBackref(int & flags)
{
	// skip '\\' or '\k' or '\g'
	MoveNext();

	if(curr.ch == RCHART('<') || curr.ch == RCHART('\''))
	{
		CHART named_end = curr.ch == RCHART('<') ? RCHART('>') : RCHART('\'');
		CBackrefElxT <CHART> * pbackref = (CBackrefElxT <CHART> *)Keep(new CBackrefElxT <CHART> (-1, flags & RIGHTTOLEFT, flags & IGNORECASE));

		MoveNext(); // skip '<' or '\''

		// save name
		CBufferT <CHART> & name = pbackref->m_szNamed;
		CBufferT <char> num;

		while(curr.ch != RCHART(0) && curr.ch != named_end)
		{
			name.Append(curr.ch, 1);
			num .Append(((curr.ch & (CHART)0xff) == curr.ch) ? (char)curr.ch : 0, 1);
			MoveNext();
		}
		MoveNext(); // skip '>' or '\''

		// check <num>
		unsigned int number;
		char * str = num.GetBuffer();

		if( ReadDec(str, number) ? ( *str == '\0') : 0 )
		{
			pbackref->m_nnumber = number;
			name.Release();
		}
		else
		{
			m_namedbackreflist.Push(pbackref);
		}

		return pbackref;
	}
	else
	{
		unsigned int nbackref = 0;

		for(int i=0; i<3; i++)
		{
			if(curr.ch >= RCHART('0') && curr.ch <= RCHART('9'))
				nbackref = nbackref * 10 + (curr.ch - RCHART('0'));
			else
				break;

			MoveNext();
		}

		return Keep(new CBackrefElxT <CHART> (nbackref, flags & RIGHTTOLEFT, flags & IGNORECASE));
	}
}

template <class CHART> int CBuilderT <CHART> :: ReadDec(char * & str, unsigned int & dec)
{
	int s = 0;
	while(str[s] != 0 && isspace(str[s])) s++;

	if(str[s] < '0' || str[s] > '9') return 0;

	dec = 0;
	unsigned int i;

	for(i = s; i<sizeof(CHART)*3 + s; i++)
	{
		if(str[i] >= '0' && str[i] <= '9')
			dec = dec * 10 + (str[i] - '0');
		else
			break;
	}

	while(str[i] != 0 && isspace(str[i])) i++;
	str += i;

	return 1;
}

//
// Regexp
//
template <class CHART> class CRegexpT
{
public:
	CRegexpT(const CHART * pattern = 0, int flags = 0);
	CRegexpT(const CHART * pattern, int length, int flags);
	void Compile(const CHART * pattern, int flags = 0);
	void Compile(const CHART * pattern, int length, int flags);

public:
	MatchResult MatchExact(const CHART * tstring, CContext * pContext = 0) const;
	MatchResult MatchExact(const CHART * tstring, int length, CContext * pContext = 0) const;
	MatchResult Match(const CHART * tstring, int start = -1, CContext * pContext = 0) const;
	MatchResult Match(const CHART * tstring, int length, int start, CContext * pContext = 0) const;
	MatchResult Match(CContext * pContext) const;
	CContext * PrepareMatch(const CHART * tstring, int start = -1, CContext * pContext = 0) const;
	CContext * PrepareMatch(const CHART * tstring, int length, int start, CContext * pContext = 0) const;
	CHART * Replace(const CHART * tstring, const CHART * replaceto, int start = -1, int ntimes = -1, MatchResult * result = 0, CContext * pContext = 0) const;
	CHART * Replace(const CHART * tstring, int string_length, const CHART * replaceto, int to_length, int & result_length, int start = -1, int ntimes = -1, MatchResult * result = 0, CContext * pContext = 0) const;
	int GetNamedGroupNumber(const CHART * group_name) const;

public:
	static void ReleaseString (CHART    * tstring );
	static void ReleaseContext(CContext * pContext);

public:
	CBuilderT <CHART> m_builder;
};

//
// Implementation
//
template <class CHART> CRegexpT <CHART> :: CRegexpT(const CHART * pattern, int flags)
{
	Compile(pattern, CBufferRefT<CHART>(pattern).GetSize(), flags);
}

template <class CHART> CRegexpT <CHART> :: CRegexpT(const CHART * pattern, int length, int flags)
{
	Compile(pattern, length, flags);
}

template <class CHART> inline void CRegexpT <CHART> :: Compile(const CHART * pattern, int flags)
{
	Compile(pattern, CBufferRefT<CHART>(pattern).GetSize(), flags);
}

template <class CHART> void CRegexpT <CHART> :: Compile(const CHART * pattern, int length, int flags)
{
	m_builder.Clear();
	if(pattern != 0) m_builder.Build(CBufferRefT<CHART>(pattern, length), flags);
}

template <class CHART> inline MatchResult CRegexpT <CHART> :: MatchExact(const CHART * tstring, CContext * pContext) const
{
	return MatchExact(tstring, CBufferRefT<CHART>(tstring).GetSize(), pContext);
}

template <class CHART> MatchResult CRegexpT <CHART> :: MatchExact(const CHART * tstring, int length, CContext * pContext) const
{
	if(m_builder.m_pTopElx == 0)
		return 0;

	// info
	int endpos = 0;

	CContext context;
	if(pContext == 0) pContext = &context;

	pContext->m_stack.Restore(0);
	pContext->m_capturestack.Restore(0);
	pContext->m_captureindex.Restore(0);

	pContext->m_nParenZindex  = 0;
	pContext->m_nLastBeginPos = -1;
	pContext->m_pMatchString  = (void*)tstring;
	pContext->m_pMatchStringLength = length;

	if(m_builder.m_nFlags & RIGHTTOLEFT)
	{
		pContext->m_nBeginPos   = length;
		pContext->m_nCurrentPos = length;
		endpos = 0;
	}
	else
	{
		pContext->m_nBeginPos   = 0;
		pContext->m_nCurrentPos = 0;
		endpos = length;
	}

	pContext->m_captureindex.Prepare(m_builder.m_nMaxNumber, -1);
	pContext->m_captureindex[0] = 0;
	pContext->m_capturestack.Push(0);
	pContext->m_capturestack.Push(pContext->m_nCurrentPos);
	pContext->m_capturestack.Push(-1);
	pContext->m_capturestack.Push(-1);

	// match
	if( ! m_builder.m_pTopElx->Match( pContext ) )
		return 0;
	else
	{
		while( pContext->m_nCurrentPos != endpos )
		{
			if( ! m_builder.m_pTopElx->MatchNext( pContext ) )
				return 0;
			else
			{
				if( pContext->m_nLastBeginPos == pContext->m_nBeginPos && pContext->m_nBeginPos == pContext->m_nCurrentPos )
					return 0;
				else
					pContext->m_nLastBeginPos = pContext->m_nCurrentPos;
			}
		}

		// end pos
		pContext->m_capturestack[2] = pContext->m_nCurrentPos;

		return MatchResult( pContext, m_builder.m_nMaxNumber );
	}
}

template <class CHART> MatchResult CRegexpT <CHART> :: Match(const CHART * tstring, int start, CContext * pContext) const
{
	return Match(tstring, CBufferRefT<CHART>(tstring).GetSize(), start, pContext);
}

template <class CHART> MatchResult CRegexpT <CHART> :: Match(const CHART * tstring, int length, int start, CContext * pContext) const
{
	if(m_builder.m_pTopElx == 0)
		return 0;

	CContext context;
	if(pContext == 0) pContext = &context;

	PrepareMatch(tstring, length, start, pContext);

	return Match( pContext );
}

template <class CHART> MatchResult CRegexpT <CHART> :: Match(CContext * pContext) const
{
	if(m_builder.m_pTopElx == 0)
		return 0;

	int endpos, delta;

	if(m_builder.m_nFlags & RIGHTTOLEFT)
	{
		endpos = -1;
		delta  = -1;
	}
	else
	{
		endpos = pContext->m_pMatchStringLength + 1;
		delta  = 1;
	}

	while(pContext->m_nCurrentPos != endpos)
	{
		pContext->m_captureindex.Restore(0);
		pContext->m_stack       .Restore(0);
		pContext->m_capturestack.Restore(0);

		pContext->m_captureindex.Prepare(m_builder.m_nMaxNumber, -1);
		pContext->m_captureindex[0] = 0;
		pContext->m_capturestack.Push(0);
		pContext->m_capturestack.Push(pContext->m_nCurrentPos);
		pContext->m_capturestack.Push(-1);
		pContext->m_capturestack.Push(-1);

		if( m_builder.m_pTopElx->Match( pContext ) )
		{
			pContext->m_capturestack[2] = pContext->m_nCurrentPos;

			// zero width
			if( /* pContext->m_nLastBeginPos == pContext->m_nBeginPos && */ pContext->m_nBeginPos == pContext->m_nCurrentPos )
			{
				pContext->m_nCurrentPos += delta;
				/* continue; */
			}

			// save pos
			pContext->m_nLastBeginPos   = pContext->m_nBeginPos;
			pContext->m_nBeginPos       = pContext->m_nCurrentPos;

			// return
			return MatchResult( pContext, m_builder.m_nMaxNumber );
		}
		else
		{
			pContext->m_nCurrentPos += delta;
		}
	}

	return 0;
}

template <class CHART> inline CContext * CRegexpT <CHART> :: PrepareMatch(const CHART * tstring, int start, CContext * pContext) const
{
	return PrepareMatch(tstring, CBufferRefT<CHART>(tstring).GetSize(), start, pContext);
}

template <class CHART> CContext * CRegexpT <CHART> :: PrepareMatch(const CHART * tstring, int length, int start, CContext * pContext) const
{
	if(m_builder.m_pTopElx == 0)
		return 0;

	if(pContext == 0) pContext = new CContext();

	pContext->m_nParenZindex  =  0;
	pContext->m_nLastBeginPos = -1;
	pContext->m_pMatchString  = (void*)tstring;
	pContext->m_pMatchStringLength = length;

	if(start < 0)
	{
		if(m_builder.m_nFlags & RIGHTTOLEFT)
		{
			pContext->m_nBeginPos   = length;
			pContext->m_nCurrentPos = length;
		}
		else
		{
			pContext->m_nBeginPos   = 0;
			pContext->m_nCurrentPos = 0;
		}
	}
	else
	{
		if(start > length) start = length + ((m_builder.m_nFlags & RIGHTTOLEFT)?0:1);

		pContext->m_nBeginPos   = start;
		pContext->m_nCurrentPos = start;
	}

	return pContext;
}

template <class CHART> inline int CRegexpT <CHART> :: GetNamedGroupNumber(const CHART * group_name) const
{
	return m_builder.GetNamedNumber(group_name);
}

template <class CHART> CHART * CRegexpT <CHART> :: Replace(const CHART * tstring, const CHART * replaceto, int start, int ntimes, MatchResult * result, CContext * pContext) const
{
	int result_length = 0;
	return Replace(tstring, CBufferRefT<CHART>(tstring).GetSize(), replaceto, CBufferRefT<CHART>(replaceto).GetSize(), result_length, start, ntimes, result, pContext);
}

template <class CHART> CHART * CRegexpT <CHART> :: Replace(const CHART * tstring, int string_length, const CHART * replaceto, int to_length, int & result_length, int start, int ntimes, MatchResult * remote_result, CContext * oContext) const
{
	if(m_builder.m_pTopElx == 0) return 0;

	// --- compile replace to ---

	CBufferT <int> compiledto;

	static const CHART rtoptn[] = { RCHART('\\'), RCHART('$' ), RCHART('('), RCHART('?'), RCHART(':'), RCHART('[' ), RCHART('$' ), RCHART('&' ), RCHART('`' ), RCHART('\''), RCHART('+'), RCHART('_' ), RCHART('\\'), RCHART('d'), RCHART(']'), RCHART('|'), RCHART('\\'), RCHART('{'), RCHART('.'), RCHART('*'), RCHART('?'), RCHART('\\'), RCHART('}'), RCHART(')' ), RCHART('\0') };
	static CRegexpT <CHART> rtoreg(rtoptn);

	MatchResult local_result(0), * result = remote_result ? remote_result : & local_result;

	// prepare
	CContext * pContext = PrepareMatch(replaceto, to_length, -1, oContext);
	int lastIndex = 0, nmatch = 0;

	while( ((*result) = rtoreg.Match(pContext)).IsMatched() )
	{
		int delta = result->GetStart() - lastIndex;
		if( delta > 0 )
		{
			compiledto.Push(lastIndex);
			compiledto.Push(delta);
		}

		lastIndex = result->GetStart();
		delta     = 2;

		switch(replaceto[lastIndex + 1])
		{
		case RCHART('$'):
			compiledto.Push(lastIndex);
			compiledto.Push(1);
			break;

		case RCHART('&'):
		case RCHART('`'):
		case RCHART('\''):
		case RCHART('+'):
		case RCHART('_'):
			compiledto.Push(-1);
			compiledto.Push((int)replaceto[lastIndex + 1]);
			break;

		case RCHART('{'):
			delta  = result->GetEnd() - result->GetStart();
			nmatch = m_builder.GetNamedNumber(CBufferRefT <CHART> (replaceto + (lastIndex + 2), delta - 3));

			if(nmatch > 0 && nmatch <= m_builder.m_nMaxNumber)
			{
				compiledto.Push(-2);
				compiledto.Push(nmatch);
			}
			else
			{
				compiledto.Push(lastIndex);
				compiledto.Push(delta);
			}
			break;

		default:
			nmatch = 0;
			for(delta=1; delta<=3; delta++)
			{
				CHART ch = replaceto[lastIndex + delta];

				if(ch < RCHART('0') || ch > RCHART('9'))
					break;

				nmatch = nmatch * 10 + (ch - RCHART('0'));
			}

			if(nmatch > m_builder.m_nMaxNumber)
			{
				while(nmatch > m_builder.m_nMaxNumber)
				{
					nmatch /= 10;
					delta --;
				}

				if(nmatch == 0)
				{
					delta = 1;
				}
			}

			if(delta == 1)
			{
				compiledto.Push(lastIndex);
				compiledto.Push(1);
			}
			else
			{
				compiledto.Push(-2);
				compiledto.Push(nmatch);
			}
			break;
		}

		lastIndex += delta;
	}

	if(lastIndex < to_length)
	{
		compiledto.Push(lastIndex);
		compiledto.Push(to_length - lastIndex);
	}

	int rightleft = m_builder.m_nFlags & RIGHTTOLEFT;

	int tb = rightleft ? compiledto.GetSize() - 2 : 0;
	int te = rightleft ? -2 : compiledto.GetSize();
	int ts = rightleft ? -2 : 2;

	// --- compile complete ---

	int beginpos  = rightleft ? string_length : 0;
	int endpos    = rightleft ? 0 : string_length;

	int toIndex0  = 0;
	int toIndex1  = 0;
	int i, ntime;

	CBufferT <const CHART *> buffer;

	// prepare
	pContext  = PrepareMatch(tstring, string_length, start, pContext);
	lastIndex = beginpos;

	// Match
	for(ntime = 0; ntimes < 0 || ntime < ntimes; ntime ++)
	{
		(*result) = Match(pContext);

		if( ! result->IsMatched() )
			break;

		// before
		if( rightleft )
		{
			int distance = lastIndex - result->GetEnd();
			if( distance )
			{
				buffer.Push(tstring + result->GetEnd());
				buffer.Push((const CHART *)distance);

				toIndex1 -= distance;
			}
			lastIndex = result->GetStart();
		}
		else
		{
			int distance = result->GetStart() - lastIndex;
			if( distance )
			{
				buffer.Push(tstring + lastIndex);
				buffer.Push((const CHART *)distance);

				toIndex1 += distance;
			}
			lastIndex = result->GetEnd();
		}

		toIndex0 = toIndex1;

		// middle
		for(i=tb; i!=te; i+=ts)
		{
			int off = compiledto[i];
			int len = compiledto[i + 1];

			const CHART * sub = replaceto + off;

			if( off == -1 )
			{
				switch(RCHART(len))
				{
				case RCHART('&'):
					sub = tstring + result->GetStart();
					len = result->GetEnd() - result->GetStart();
					break;

				case RCHART('`'):
					sub = tstring;
					len = result->GetStart();
					break;

				case RCHART('\''):
					sub = tstring + result->GetEnd();
					len = string_length - result->GetEnd();
					break;

				case RCHART('+'):
					for(nmatch = result->MaxGroupNumber(); nmatch >= 0; nmatch --)
					{
						if(result->GetGroupStart(nmatch) >= 0) break;
					}
					sub = tstring + result->GetGroupStart(nmatch);
					len = result->GetGroupEnd(nmatch) - result->GetGroupStart(nmatch);
					break;

				case RCHART('_'):
					sub = tstring;
					len = string_length;
					break;
				}
			}
			else if( off == -2 )
			{
				sub = tstring + result->GetGroupStart(len);
				len = result->GetGroupEnd(len) - result->GetGroupStart(len);
			}

			buffer.Push(sub);
			buffer.Push((const CHART *)len);

			toIndex1 += rightleft ? (-len) : len;
		}
	}

	// after
	if(rightleft)
	{
		if(endpos < lastIndex)
		{
			buffer.Push(tstring + endpos);
			buffer.Push((const CHART *)(lastIndex - endpos));
		}
	}
	else
	{
		if(lastIndex < endpos)
		{
			buffer.Push(tstring + lastIndex);
			buffer.Push((const CHART *)(endpos - lastIndex));
		}
	}

	if(oContext == 0) ReleaseContext(pContext);

	// join string
	result_length = 0;
	for(i=0; i<buffer.GetSize(); i+=2)
	{
		result_length += (int)buffer[i+1];
	}

	CBufferT <CHART> result_string;
	result_string.Prepare(result_length);
	result_string.Restore(0);

	if(rightleft)
	{
		for(i=buffer.GetSize()-2; i>=0; i-=2)
		{
			result_string.Append(buffer[i], (int)buffer[i+1]);
		}
	}
	else
	{
		for(i=0; i<buffer.GetSize(); i+=2)
		{
			result_string.Append(buffer[i], (int)buffer[i+1]);
		}
	}

	result_string.Append(0);

	result->m_result.Append(result_length, 3);
	result->m_result.Append(ntime);

	if(rightleft)
	{
		result->m_result.Append(result_length - toIndex1);
		result->m_result.Append(result_length - toIndex0);
	}
	else
	{
		result->m_result.Append(toIndex0);
		result->m_result.Append(toIndex1);
	}

	return result_string.Detach();
}

template <class CHART> inline void CRegexpT <CHART> :: ReleaseString(CHART * tstring)
{
	if(tstring != 0) free(tstring);
}

template <class CHART> inline void CRegexpT <CHART> :: ReleaseContext(CContext * pContext)
{
	if(pContext != 0) delete pContext;
}

//
// All implementations
//
template <int x> CAlternativeElxT <x> :: CAlternativeElxT()
{
}

template <int x> int CAlternativeElxT <x> :: Match(CContext * pContext) const
{
	if(m_elxlist.GetSize() == 0)
		return 1;

	// try all
	for(int n = 0; n < m_elxlist.GetSize(); n++)
	{
		if(m_elxlist[n]->Match(pContext))
		{
			pContext->m_stack.Push(n);
			return 1;
		}
	}

	return 0;
}

template <int x> int CAlternativeElxT <x> :: MatchNext(CContext * pContext) const
{
	if(m_elxlist.GetSize() == 0)
		return 0;

	int n = 0;

	// recall prev
	pContext->m_stack.Pop(n);

	// prev
	if(m_elxlist[n]->MatchNext(pContext))
	{
		pContext->m_stack.Push(n);
		return 1;
	}
	else
	{
		// try rest
		for(n++; n < m_elxlist.GetSize(); n++)
		{
			if(m_elxlist[n]->Match(pContext))
			{
				pContext->m_stack.Push(n);
				return 1;
			}
		}

		return 0;
	}
}

// assertx.cpp: implementation of the CAssertElx class.
//
template <int x> CAssertElxT <x> :: CAssertElxT(ElxInterface * pelx, int byes)
{
	m_pelx = pelx;
	m_byes = byes;
}

template <int x> int CAssertElxT <x> :: Match(CContext * pContext) const
{
	int nbegin = pContext->m_nCurrentPos;
	int nsize  = pContext->m_stack.GetSize();
	int ncsize = pContext->m_capturestack.GetSize();
	int bsucc;

	// match
	if( m_byes )
		bsucc =   m_pelx->Match(pContext);
	else
		bsucc = ! m_pelx->Match(pContext);

	// status
	pContext->m_stack.Restore(nsize);
	pContext->m_nCurrentPos = nbegin;

	if( bsucc )
		pContext->m_stack.Push(ncsize);
	else
		pContext->m_capturestack.Restore(ncsize);

	return bsucc;
}

template <int x> int CAssertElxT <x> :: MatchNext(CContext * pContext) const
{
	int ncsize = 0;

	pContext->m_stack.Pop(ncsize);
	pContext->m_capturestack.Restore(ncsize);

	return 0;
}

// emptyelx.cpp: implementation of the CEmptyElx class.
//
template <int x> CEmptyElxT <x> :: CEmptyElxT()
{
}

template <int x> int CEmptyElxT <x> :: Match(CContext *) const
{
	return 1;
}

template <int x> int CEmptyElxT <x> :: MatchNext(CContext *) const
{
	return 0;
}

// globalx.cpp: implementation of the CGlobalElx class.
//
template <int x> CGlobalElxT <x> ::CGlobalElxT()
{
}

template <int x> int CGlobalElxT <x> :: Match(CContext * pContext) const
{
	return pContext->m_nCurrentPos == pContext->m_nBeginPos;
}

template <int x> int CGlobalElxT <x> :: MatchNext(CContext *) const
{
	return 0;
}

// greedelx.cpp: implementation of the CGreedyElx class.
//
template <int x> CGreedyElxT <x> :: CGreedyElxT(ElxInterface * pelx, int nmin, int nmax) : CRepeatElxT <x> (pelx, nmin)
{
	m_nvart = nmax - nmin;
}

template <int x> int CGreedyElxT <x> :: Match(CContext * pContext) const
{
	if( ! CRepeatElxT <x> :: MatchFixed(pContext) )
		return 0;

	while( ! MatchVart(pContext) )
	{
		if( ! CRepeatElxT <x> :: MatchNextFixed(pContext) )
			return 0;
	}

	return 1;
}

template <int x> int CGreedyElxT <x> :: MatchNext(CContext * pContext) const
{
	if( MatchNextVart(pContext) )
		return 1;

	if( ! CRepeatElxT <x> :: MatchNextFixed(pContext) )
		return 0;

	while( ! MatchVart(pContext) )
	{
		if( ! CRepeatElxT <x> :: MatchNextFixed(pContext) )
			return 0;
	}

	return 1;
}

template <int x> int CGreedyElxT <x> :: MatchVart(CContext * pContext) const
{
	int n      = 0;
	int nbegin = pContext->m_nCurrentPos;

	while(n < m_nvart && CRepeatElxT <x> :: m_pelx->Match(pContext))
	{
		while(pContext->m_nCurrentPos == nbegin)
		{
			if( ! CRepeatElxT <x> :: m_pelx->MatchNext(pContext) ) break;
		}

		if(pContext->m_nCurrentPos == nbegin) break;

		n ++;
		nbegin = pContext->m_nCurrentPos;
	}

	pContext->m_stack.Push(n);

	return 1;
}

template <int x> int CGreedyElxT <x> :: MatchNextVart(CContext * pContext) const
{
	int n = 0;
	pContext->m_stack.Pop(n);

	if(n == 0) return 0;

	if( ! CRepeatElxT <x> :: m_pelx->MatchNext(pContext) )
	{
		n --;
	}

	pContext->m_stack.Push(n);

	return 1;
}

// indepelx.cpp: implementation of the CIndependentElx class.
//
template <int x> CIndependentElxT <x> :: CIndependentElxT(ElxInterface * pelx)
{
	m_pelx = pelx;
}

template <int x> int CIndependentElxT <x> :: Match(CContext * pContext) const
{
	int nbegin = pContext->m_nCurrentPos;
	int nsize  = pContext->m_stack.GetSize();
	int ncsize = pContext->m_capturestack.GetSize();

	// match
	int bsucc  = m_pelx->Match(pContext);

	// status
	pContext->m_stack.Restore(nsize);

	if( bsucc )
	{
		pContext->m_stack.Push(nbegin);
		pContext->m_stack.Push(ncsize);
	}

	return bsucc;
}

template <int x> int CIndependentElxT <x> :: MatchNext(CContext * pContext) const
{
	int nbegin = 0, ncsize = 0;

	pContext->m_stack.Pop(ncsize);
	pContext->m_stack.Pop(nbegin);

	pContext->m_capturestack.Restore(ncsize);
	pContext->m_nCurrentPos = nbegin;

	return 0;
}

// listelx.cpp: implementation of the CListElx class.
//
template <int x> CListElxT <x> :: CListElxT(int brightleft)
{
	m_brightleft = brightleft;
}

template <int x> int CListElxT <x> :: Match(CContext * pContext) const
{
	if(m_elxlist.GetSize() == 0)
		return 1;

	// prepare
	int bol = m_brightleft ? m_elxlist.GetSize() : -1;
	int stp = m_brightleft ? -1 : 1;
	int eol = m_brightleft ? -1 : m_elxlist.GetSize();

	// from first
	int n = bol + stp;

	// match all
	while(n != eol)
	{
		if(m_elxlist[n]->Match(pContext))
		{
			n += stp;
		}
		else
		{
			n -= stp;

			while(n != bol && ! m_elxlist[n]->MatchNext(pContext))
				n -= stp;

			if(n != bol)
				n += stp;
			else
				return 0;
		}
	}

	return 1;
}

template <int x> int CListElxT <x> :: MatchNext(CContext * pContext) const
{
	if(m_elxlist.GetSize() == 0)
		return 0;

	// prepare
	int bol = m_brightleft ? m_elxlist.GetSize() : -1;
	int stp = m_brightleft ? -1 : 1;
	int eol = m_brightleft ? -1 : m_elxlist.GetSize();

	// from last
	int n = eol - stp;

	while(n != bol && ! m_elxlist[n]->MatchNext(pContext))
		n -= stp;

	if(n != bol)
		n += stp;
	else
		return 0;

	// match rest
	while(n != eol)
	{
		if(m_elxlist[n]->Match(pContext))
		{
			n += stp;
		}
		else
		{
			n -= stp;

			while(n != bol && ! m_elxlist[n]->MatchNext(pContext))
				n -= stp;

			if(n != bol)
				n += stp;
			else
				return 0;
		}
	}

	return 1;
}

// mresult.cpp: implementation of the MatchResult class.
//
template <int x> MatchResultT <x> :: MatchResultT(CContext * pContext, int nMaxNumber)
{
	if(pContext != 0)
	{
		m_result.Prepare(nMaxNumber * 2 + 3, -1);

		// matched
		m_result[0] = 1;
		m_result[1] = nMaxNumber;

		for(int n = 0; n <= nMaxNumber; n++)
		{
			int index = pContext->m_captureindex[n];
			if( index < 0 ) continue;

			// check enclosed
			int pos1 = pContext->m_capturestack[index + 1];
			int pos2 = pContext->m_capturestack[index + 2];

			// info
			m_result[n*2 + 2] = pos1 < pos2 ? pos1 : pos2;
			m_result[n*2 + 3] = pos1 < pos2 ? pos2 : pos1;
		}
	}
}

template <int x> inline int MatchResultT <x> :: IsMatched() const
{
	return m_result.At(0, 0);
}

template <int x> inline int MatchResultT <x> :: MaxGroupNumber() const
{
	return m_result.At(1, 0);
}

template <int x> inline int MatchResultT <x> :: GetStart() const
{
	return m_result.At(2, -1);
}

template <int x> inline int MatchResultT <x> :: GetEnd() const
{
	return m_result.At(3, -1);
}

template <int x> inline int MatchResultT <x> :: GetGroupStart(int nGroupNumber) const
{
	return m_result.At(2 + nGroupNumber * 2, -1);
}

template <int x> inline int MatchResultT <x> :: GetGroupEnd(int nGroupNumber) const
{
	return m_result.At(2 + nGroupNumber * 2 + 1, -1);
}

template <int x> MatchResultT <x> & MatchResultT <x> :: operator = (const MatchResultT <x> & result)
{
	m_result.Restore(0);
	if(result.m_result.GetSize() > 0) m_result.Append(result.m_result.GetBuffer(), result.m_result.GetSize());

	return *this;
}

// posselx.cpp: implementation of the CPossessiveElx class.
//
template <int x> CPossessiveElxT <x> :: CPossessiveElxT(ElxInterface * pelx, int nmin, int nmax) : CGreedyElxT <x> (pelx, nmin, nmax)
{
}

template <int x> int CPossessiveElxT <x> :: Match(CContext * pContext) const
{
	int nbegin = pContext->m_nCurrentPos;
	int nsize  = pContext->m_stack.GetSize();
	int ncsize = pContext->m_capturestack.GetSize();
	int bsucc  = 1;

	// match
	if( ! CRepeatElxT <x> :: MatchFixed(pContext) )
	{
		bsucc = 0;
	}
	else
	{
		while( ! CGreedyElxT <x> :: MatchVart(pContext) )
		{
			if( ! CRepeatElxT <x> :: MatchNextFixed(pContext) )
			{
				bsucc = 0;
				break;
			}
		}
	}

	// status
	pContext->m_stack.Restore(nsize);

	if( bsucc )
	{
		pContext->m_stack.Push(nbegin);
		pContext->m_stack.Push(ncsize);
	}

	return bsucc;
}

template <int x> int CPossessiveElxT <x> :: MatchNext(CContext * pContext) const
{
	int nbegin = 0, ncsize = 0;

	pContext->m_stack.Pop(ncsize);
	pContext->m_stack.Pop(nbegin);

	pContext->m_capturestack.Restore(ncsize);
	pContext->m_nCurrentPos = nbegin;

	return 0;
}

// reluctx.cpp: implementation of the CReluctantElx class.
//
template <int x> CReluctantElxT <x> :: CReluctantElxT(ElxInterface * pelx, int nmin, int nmax) : CRepeatElxT <x> (pelx, nmin)
{
	m_nvart = nmax - nmin;
}

template <int x> int CReluctantElxT <x> :: Match(CContext * pContext) const
{
	if( ! CRepeatElxT <x> :: MatchFixed(pContext) )
		return 0;

	while( ! MatchVart(pContext) )
	{
		if( ! CRepeatElxT <x> :: MatchNextFixed(pContext) )
			return 0;
	}

	return 1;
}

template <int x> int CReluctantElxT <x> :: MatchNext(CContext * pContext) const
{
	if( MatchNextVart(pContext) )
		return 1;

	if( ! CRepeatElxT <x> :: MatchNextFixed(pContext) )
		return 0;

	while( ! MatchVart(pContext) )
	{
		if( ! CRepeatElxT <x> :: MatchNextFixed(pContext) )
			return 0;
	}

	return 1;
}

template <int x> int CReluctantElxT <x> :: MatchVart(CContext * pContext) const
{
	pContext->m_stack.Push(0);

	return 1;
}

template <int x> int CReluctantElxT <x> :: MatchNextVart(CContext * pContext) const
{
	int n = 0, nbegin = pContext->m_nCurrentPos;

	pContext->m_stack.Pop(n);

	if(n < m_nvart && CRepeatElxT <x> :: m_pelx->Match(pContext))
	{
		while(pContext->m_nCurrentPos == nbegin)
		{
			if( ! CRepeatElxT <x> :: m_pelx->MatchNext(pContext) ) break;
		}

		if(pContext->m_nCurrentPos != nbegin)
		{
			n ++;

			pContext->m_stack.Push(nbegin);
			pContext->m_stack.Push(n);

			return 1;
		}
	}

	while(n > 0)
	{
		pContext->m_stack.Pop(nbegin);

		while( CRepeatElxT <x> :: m_pelx->MatchNext(pContext) )
		{
			if(pContext->m_nCurrentPos != nbegin)
			{
				pContext->m_stack.Push(nbegin);
				pContext->m_stack.Push(n);

				return 1;
			}
		}

		n --;
	}

	return 0;
}

// repeatx.cpp: implementation of the CRepeatElx class.
//
template <int x> CRepeatElxT <x> :: CRepeatElxT(ElxInterface * pelx, int ntimes)
{
	m_pelx   = pelx;
	m_nfixed = ntimes;
}

template <int x> int CRepeatElxT <x> :: Match(CContext * pContext) const
{
	return MatchFixed(pContext);
}

template <int x> int CRepeatElxT <x> :: MatchNext(CContext * pContext) const
{
	return MatchNextFixed(pContext);
}

template <int x> int CRepeatElxT <x> :: MatchFixed(CContext * pContext) const
{
	if(m_nfixed == 0)
		return 1;

	int n = 0;

	while(n < m_nfixed)
	{
		if(m_pelx->Match(pContext))
		{
			n ++;
		}
		else
		{
			n --;

			while(n >= 0 && ! m_pelx->MatchNext(pContext))
				n --;

			if(n >= 0)
				n ++;
			else
				return 0;
		}
	}

	return 1;
}

template <int x> int CRepeatElxT <x> :: MatchNextFixed(CContext * pContext) const
{
	if(m_nfixed == 0)
		return 0;

	// from last
	int n = m_nfixed - 1;

	while(n >= 0 && ! m_pelx->MatchNext(pContext))
		n --;

	if(n >= 0)
		n ++;
	else
		return 0;

	// match rest
	while(n < m_nfixed)
	{
		if(m_pelx->Match(pContext))
		{
			n ++;
		}
		else
		{
			n --;

			while(n >= 0 && ! m_pelx->MatchNext(pContext))
				n --;

			if(n >= 0)
				n ++;
			else
				return 0;
		}
	}

	return 1;
}

// Regexp
typedef CRegexpT <char> CRegexpA;
typedef CRegexpT <unsigned short> CRegexpW;

#if defined(_UNICODE) || defined(UNICODE)
	typedef CRegexpW CRegexp;
#else
	typedef CRegexpA CRegexp;
#endif

static CRegexpT <char> regexp(%%2);
char sRead[10240];
CFile mFile(_T(%%1),CFile::modeRead);
CString content;
while(sRead!=NULL)
{
mFile.Read(sRead,10240);
content+=CString(sRead);
}
mFile.Close();
CString line;
CString sub;
char seperator='\n';
for(int pos=0;AfxExtractSubString(line,content,pos,seperator);++pos)
{
line.TrimLeft();
line.TrimRight();
if(line!="")
{
MatchResult result = regexp.MatchExact(line.GetBuffer(0));
if(result.IsMatched())
{
%%3
}
}
}

/*
#include <stdio.h>
#include <sys/types.h>
#include <regex.h>
*/
char *get_regerror (int errcode, regex_t *compiled)
{
size_t length = regerror (errcode, compiled, NULL, 0);
char *buffer = malloc(length);
if (!buffer) return NULL;
(void) regerror (errcode, compiled, buffer, length);
return buffer;
}

int regtest(const char*pattern, const char* string)
{
regex_t reg;
regmatch_t *subexprs = NULL;
int ret;
int i;

if (0 != (ret=regcomp(?, pattern, REG_EXTENDED))) {
   char *buffer = get_regerror(ret, ?);
   if (buffer) {
    fprintf(stderr, "regcomp:[%d]%s\n", ret, buffer);
    free(buffer);
   }

   return -1;
}

subexprs = malloc((reg.re_nsub+1)*sizeof(regmatch_t));
if (!subexprs) {
   fprintf(stderr, "error malloc subexprs\n");
   regfree(?);
   return -1;
}

if (0 != (ret=regexec(?, string, reg.re_nsub+1, subexprs, 0))) {
   char *buffer = get_regerror(ret, ?);
   if (buffer) {
    fprintf(stderr, "regexec:[%d]%s\n", ret, buffer);
    free(buffer);
   }
  
   regfree(?);
   return -1;
}

for (i = 0; i <= reg.re_nsub; i++)   {
   printf("[%d]:", i);
  
   if (subexprs[i].rm_so == subexprs[i].rm_eo) {
    printf("[EMPTY SUBEXPR]\n");
   }
   else if (subexprs[i].rm_so == -1 || 
    subexprs[i].rm_eo == -1) {
    printf("[NO SUBEXPR]\n");
   }
   else   {
    fwrite(string+subexprs[i].rm_so, 1, 
     subexprs[i].rm_eo-subexprs[i].rm_so, stdout);
    printf("\n");
   }
}

regfree(?);
if (subexprs) free(subexprs);
return 0;
}

regtest(%%1, %%2);

/*
#include <stdio.h>
#include <string.h>
#include <pcre.h>
*/
#define OVECCOUNT 30     /* should be a multiple of 3 */

int main(int argc, char **argv)
{
pcre *re;
const char *error;
char *pattern;
char *subject;
unsigned char *name_table;
int erroffset;
int find_all;
int namecount;
int name_entry_size;
int ovector[OVECCOUNT];
int subject_length;
int rc, i;


/**************************************************************************
* First, sort out the command line. There is only one possible option at   *
* the moment, "-g" to request repeated matching to find all occurrences,   *
* like Perl's /g option. We set the variable find_all to a non-zero value *
* if the -g option is present. Apart from that, there must be exactly two *
* arguments.                                                               *
**************************************************************************/

find_all = 0;
for (i = 1; i < argc; i++) {
   if (strcmp(argv[i], "-g") == 0) find_all = 1;
   else break;
}

/* After the options, we require exactly two arguments, which are the pattern,
and the subject string. */

if (argc - i != 2) {
   printf("Two arguments required: a regex and a subject string\n");
   return 1;
}

pattern = argv[i];
subject = argv[i+1];
subject_length = (int)strlen(subject);


/*************************************************************************
* Now we are going to compile the regular expression pattern, and handle *
* and errors that are detected.                                           *
*************************************************************************/

re = pcre_compile(
   pattern,               /* the pattern */
   0,                     /* default options */
   &error,                /* for error message */
   &erroffset,            /* for error offset */
   NULL);                 /* use default character tables */


/* Compilation failed: print the error message and exit */

if (re == NULL) {
   printf("PCRE compilation failed at offset %d: %s\n", erroffset, error);
   return 1;
}


/*************************************************************************
* If the compilation succeeded, we call PCRE again, in order to do a      *
* pattern match against the subject string. This does just ONE match. If *
* further matching is needed, it will be done below.                      *
*************************************************************************/

rc = pcre_exec(
   re,                    /* the compiled pattern */
   NULL,                  /* no extra data - we didn't study the pattern */
   subject,               /* the subject string */
   subject_length,        /* the length of the subject */
   0,                     /* start at offset 0 in the subject */
   0,                     /* default options */
   ovector,               /* output vector for substring information */
   OVECCOUNT);            /* number of elements in the output vector */

/* Matching failed: handle error cases */

if (rc < 0) {
   switch(rc) {
    case PCRE_ERROR_NOMATCH: printf("No match\n"); break;
   /*
   Handle other special cases if you like
    */
    default: printf("Matching error %d\n", rc); break;
   }
   free(re);      /* Release memory used for the compiled pattern */
    return 1;
}

/* Match succeded */

printf("\nMatch succeeded at offset %d\n", ovector[0]);


/*************************************************************************
* We have found the first match within the subject string. If the output *
* vector wasn't big enough, set its size to the maximum. Then output any *
* substrings that were captured.                                          *
*************************************************************************/

/* The output vector wasn't big enough */

if (rc == 0) {
   rc = OVECCOUNT/3;
   printf("ovector only has room for %d captured substrings\n", rc - 1);
}

/* Show substrings stored in the output vector by number. Obviously, in a real
application you might want to do things other than print them. */

for (i = 0; i < rc; i++) {
   char *substring_start = subject + ovector[2*i];
   int substring_length = ovector[2*i+1] - ovector[2*i];
   printf("%2d: %.*s\n", i, substring_length, substring_start);
}


/**************************************************************************
* That concludes the basic part of this demonstration program. We have     *
* compiled a pattern, and performed a single match. The code that follows *
* first shows how to access named substrings, and then how to code for     *
* repeated matches on the same subject.                                    *
**************************************************************************/

/* See if there are any named substrings, and if so, show them by name. First
we have to extract the count of named parentheses from the pattern. */

(void)pcre_fullinfo(
   re,                    /* the compiled pattern */
   NULL,                  /* no extra data - we didn't study the pattern */
   PCRE_INFO_NAMECOUNT,   /* number of named substrings */
   &namecount);           /* where to put the answer */

if (namecount <= 0) printf("No named substrings\n"); else
{
   unsigned char *tabptr;
   printf("Named substrings\n");
  
   /* Before we can access the substrings, we must extract the table for
   translating names to numbers, and the size of each entry in the table. */
  
   (void)pcre_fullinfo(
    re,                        /* the compiled pattern */
    NULL,                      /* no extra data - we didn't study the pattern */
    PCRE_INFO_NAMETABLE,       /* address of the table */
    &name_table);              /* where to put the answer */
  
   (void)pcre_fullinfo(
    re,                        /* the compiled pattern */
    NULL,                      /* no extra data - we didn't study the pattern */
    PCRE_INFO_NAMEENTRYSIZE,   /* size of each entry in the table */
    &name_entry_size);         /* where to put the answer */
  
            /* Now we can scan the table and, for each entry, print the number, the name,
   and the substring itself. */
  
   tabptr = name_table;
   for (i = 0; i < namecount; i++)   {
    int n = (tabptr[0] << 8) | tabptr[1];
    printf("(%d) %*s: %.*s\n", n, name_entry_size - 3, tabptr + 2,
     ovector[2*n+1] - ovector[2*n], subject + ovector[2*n]);
    tabptr += name_entry_size;
   }
}


/*************************************************************************
* If the "-g" option was given on the command line, we want to continue   *
* to search for additional matches in the subject string, in a similar    *
* way to the /g option in Perl. This turns out to be trickier than you    *
* might think because of the possibility of matching an empty string.     *
* What happens is as follows:                                             *
*                                                                         *
* If the previous match was NOT for an empty string, we can just start    *
* the next match at the end of the previous one.                          *
*                                                                         *
* If the previous match WAS for an empty string, we can't do that, as it *
* would lead to an infinite loop. Instead, a special call of pcre_exec() *
* is made with the PCRE_NOTEMPTY and PCRE_ANCHORED flags set. The first   *
* of these tells PCRE that an empty string is not a valid match; other    *
* possibilities must be tried. The second flag restricts PCRE to one      *
* match attempt at the initial string position. If this match succeeds,   *
* an alternative to the empty string match has been found, and we can     *
* proceed round the loop.                                                 *
*************************************************************************/

if (!find_all) {
   free(re);    /* Release the memory used for the compiled pattern */
   return 0;    /* Finish unless -g was given */
}

/* Loop for second and subsequent matches */

for (;;) {
   int options = 0;                  /* Normally no options */
   int start_offset = ovector[1];    /* Start at end of previous match */
  
            /* If the previous match was for an empty string, we are finished if we are
            at the end of the subject. Otherwise, arrange to run another match at the
   same point to see if a non-empty match can be found. */
  
   if (ovector[0] == ovector[1])   {
    if (ovector[0] == subject_length) break;
    options = PCRE_NOTEMPTY | PCRE_ANCHORED;
   }
  
   /* Run the next matching operation */
  
   rc = pcre_exec(
    re,                    /* the compiled pattern */
    NULL,                  /* no extra data - we didn't study the pattern */
    subject,               /* the subject string */
    subject_length,        /* the length of the subject */
    start_offset,          /* starting offset in the subject */
    options,               /* options */
    ovector,               /* output vector for substring information */
    OVECCOUNT);            /* number of elements in the output vector */
  
           /* This time, a result of NOMATCH isn't an error. If the value in "options"
           is zero, it just means we have found all possible matches, so the loop ends.
           Otherwise, it means we have failed to find a non-empty-string match at a
           point where there was a previous empty-string match. In this case, we do what
           Perl does: advance the matching position by one, and continue. We do this by
           setting the "end of previous match" offset, because that is picked up at the
   top of the loop as the point at which to start again. */
  
   if (rc == PCRE_ERROR_NOMATCH)   {
    if (options == 0) break;
    ovector[1] = start_offset + 1;
    continue;     /* Go round the loop again */
   }
  
   /* Other matching errors are not recoverable. */
  
   if (rc < 0)   {
    printf("Matching error %d\n", rc);
    free(re);     /* Release memory used for the compiled pattern */
    return 1;
   }
  
   /* Match succeded */
  
   printf("\nMatch succeeded again at offset %d\n", ovector[0]);
  
   /* The match succeeded, but the output vector wasn't big enough. */
  
   if (rc == 0)   {
    rc = OVECCOUNT/3;
    printf("ovector only has room for %d captured substrings\n", rc - 1);
   }
  
  
   /* As before, show substrings stored in the output vector by number, and then
   also any named substrings. */
  
   for (i = 0; i < rc; i++)   {
    char *substring_start = subject + ovector[2*i];
    int substring_length = ovector[2*i+1] - ovector[2*i];
    printf("%2d: %.*s\n", i, substring_length, substring_start);
   }
  
   if (namecount <= 0) printf("No named substrings\n"); else
   {
    unsigned char *tabptr = name_table;
    printf("Named substrings\n");
    for (i = 0; i < namecount; i++)
    {
     int n = (tabptr[0] << 8) | tabptr[1];
     printf("(%d) %*s: %.*s\n", n, name_entry_size - 3, tabptr + 2,
      ovector[2*n+1] - ovector[2*n], subject + ovector[2*n]);
     tabptr += name_entry_size;
    }
   }
}       /* End of loop to find second and subsequent matches */

printf("\n");
free(re);        /* Release memory used for the compiled pattern */
return 0;
}

47.直接创建多级目录
/*
#include <sys/stat.h>
#include <sys/types.h>
#include <errno.h>
#include <fcntl.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <ctype.h>
#include <limits.h>
*/
extern char *progname;

mode_t parse_file_mode(char *arg, mode_t mode, mode_t sumask)
{
        char *clause;

        if (isdigit(*arg) && *arg < '8') {
                unsigned long num;

                num = strtoul(arg, NULL, 8);
                if ((num == ULONG_MAX && errno == ERANGE) || num > 07777) {
                        fprintf(stderr, "%s: invalid mode `%s'\n", progname,
                                arg);
                        exit(255);
                }
                return (mode_t) num;
        }

        while ((clause = strsep(&arg, ",")) != NULL) {
                mode_t who = 0;
                int action;
                char *p = clause;

                /*
                 * Parse the who list.  Optional.
                 */
                while (1) {
                        switch (*p++) {
                        case 'u':
                                who |= S_IRWXU | S_ISUID;
                                continue;
                        case 'g':
                                who |= S_IRWXG | S_ISGID;
                                continue;
                        case 'o':
                                who |= S_IRWXO | S_ISVTX;
                                continue;
                        case 'a':
                                who =
                                    S_IRWXU | S_IRWXG | S_IRWXO | S_ISUID |
                                    S_ISGID | S_ISVTX;
                                continue;
                        }
                        /* undo the increment above */
                        p--;
                        break;
                }

                if (who == 0)
                        who = (~sumask) | S_ISVTX;

                /*
                 * Parse an action list.  Must be at least one action.
                 */
                while (*p) {
                        mode_t perm = 0;

                        /*
                         * Parse the action
                         */
                        action = *p;
                        if (action == '+' || action == '-' || action == '=')
                                p++;

                        /*
                         * Parse perm
                         */
                        while (*p) {
                                switch (*p++) {
                                case 'r':
                                        perm |= S_IRUSR | S_IRGRP | S_IROTH;
                                        continue;
                                case 'w':
                                        perm |= S_IWUSR | S_IWGRP | S_IWOTH;
                                        continue;
                                case 'x':
                                        perm |= S_IXUSR | S_IXGRP | S_IXOTH;
                                        continue;
                                case 'X':
                                        perm |= S_ISVTX;
                                        continue;
                                case 's':
                                        perm |= S_ISUID | S_ISGID;
                                        continue;
                                case 'u':
                                        perm = mode & S_IRWXU;
                                        perm |= perm >> 3 | perm >> 6;
                                        if (mode & S_ISUID)
                                                perm |= S_ISGID;
                                        continue;
                                case 'g':
                                        perm = mode & S_IRWXG;
                                        perm |= perm << 3 | perm >> 3;
                                        if (mode & S_ISGID)
                                                perm |= S_ISUID;
                                        continue;
                                case 'o':
                                        perm = mode & S_IRWXO;
                                        perm |= perm << 6 | perm << 3;
                                        continue;
                                }
                                /* undo the increment above */
                                p--;
                                break;
                        }

                        perm &= who;

                        switch (action) {
                        case '+':
                                mode |= perm;
                                continue;

                        case '-':
                                mode &= ~perm;
                                continue;

                        case '=':
                                mode &= ~who;
                                mode |= perm;
                                continue;
                        }

                        if (!action)
                                break;
                        fprintf(stderr, "%s: invalid mode `%s'\n", progname,
                                clause);
                        exit(255);
                }
        }

        return mode;
}

static mode_t leaf_mode, subdir_mode;
static int p_flag;

char *progname;

static int make_one_dir(char *dir, mode_t mode)
{
        struct stat stbuf;

        if (mkdir(dir, mode) == -1) {
                int err = errno;

                /*
                 * Ignore the error if it all of the following
                 * are satisfied:
                 *  - error was EEXIST
                 *  - -p was specified
                 *  - stat indicates that its a directory
                 */
                if (p_flag && errno == EEXIST &&
                    stat(dir, &stbuf) == 0 && S_ISDIR(stbuf.st_mode))
                        return 1;
                errno = err;
                fprintf(stderr, "%s: ", progname);
                perror(dir);
                return -1;
        }
        return 0;
}

static int make_dir(char *dir)
{
        int ret;

        if (p_flag) {
                char *s, *p;

                /*
                 * Recurse each directory, trying to make it
                 * as we go.  Should we check to see if it
                 * exists, and if so if it's a directory
                 * before calling mkdir?
                 */
                s = dir;
                while ((p = strchr(s, '/')) != NULL) {
                        /*
                         * Ignore the leading /
                         */
                        if (p != dir) {
                                *p = '\0';

                                /*
                                 * Make the intermediary directory.  POSIX
                                 * says that these directories are created
                                 * with umask,u+wx
                                 */
                                if (make_one_dir(dir, subdir_mode) == -1)
                                        return -1;

                                *p = '/';
                        }
                        s = p + 1;
                }
        }

        /*
         * Make the final target.  Only complain if the
         * target already exists if -p was not specified.
         * This is created with the asked for mode & ~umask
         */
        ret = make_one_dir(dir, leaf_mode);
        if (ret == -1)
                return -1;

        /*
         * We might not set all the permission bits.  Do that
         * here (but only if we did create it.)
         */
        if (ret == 0 && chmod(dir, leaf_mode) == -1) {
                int err_save = errno;

                /*
                 * We failed, remove the directory we created
                 */
                rmdir(dir);
                errno = err_save;
                fprintf(stderr, "%s: ", progname);
                perror(dir);
                return -1;
        }
        return 0;
}

int main(int argc, char *argv[])
{
        int c, ret = 0;
        mode_t saved_umask;

        progname = argv[0];

        saved_umask = umask(0);
        leaf_mode = (S_IRWXU | S_IRWXG | S_IRWXO) & ~saved_umask;
        subdir_mode = (saved_umask ^ (S_IRWXU | S_IRWXG | S_IRWXO))
            | S_IWUSR | S_IXUSR;

        do {
                c = getopt(argc, argv, "pm:");
                if (c == EOF)
                        break;
                switch (c) {
                case 'm':
                        leaf_mode =
                            parse_file_mode(optarg, leaf_mode, saved_umask);
                        break;
                case 'p':
                        p_flag = 1;
                        break;

                case '?':
                        fprintf(stderr, "%s: invalid option -%c\n",
                                progname, optopt);
                        exit(1);
                }
        } while (1);

        if (optind == argc) {
                fprintf(stderr, "Usage: %s [-p] [-m mode] dir...\n", progname);
                exit(1);
        }

        while (optind < argc) {
                if (make_dir(argv[optind]))
                        ret = 255;      /* seems to be what gnu mkdir does */
                optind++;
        }

        return ret;
}

48.批量重命名
//#include<stdio.h>
rename(%%1,%%2);

49.文本查找替换

50.文件关联

51.批量转换编码从GB2312到Unicode

52.设置JDK环境变量
/*
#include <stdio.h>
#include <string.h>
#include <sys/types.h>
#include <regex.h>
#define MAX_LINE 1024
*/
char buf[MAX_LINE];
FILE *fp;
int len;
if((fp = fopen("TestBash.txt", "r")) != NULL) //.bashrc
{
	const char *pattern="export\\ JAVA_HOME=(\\/([0-9a-zA-Z._]+))+"; //
	regex_t reg;
	int status = 0;
	int cflags = REG_EXTENDED|REG_NOSUB;
	char error[32];
	status = regcomp(&reg, pattern, cflags);
	if (status != 0)
	{
		regerror(status,&reg, error, sizeof(error));
		printf("regcomp ERROR -> %s: pattern '%s'\n", pattern, error);
		return -1;
	}
	while(fgets(buf, MAX_LINE, fp) != NULL)
	{
		len = strlen(buf);
		buf[len - 1] = '\0';
		if(strstr(buf,"export CLASSPATH=.:$JAVA_HOME/lib:$JAVA_HOME/jre/lib"))
			printf("%s\n",buf);
		else if(strstr(buf,"PATH=$PATH:$JAVA_HOME/bin:$JAVA_HOME/jre/bin"))
			printf("%s\n",buf);
		else
		{
			status = regexec(&reg, buf, 0, NULL, 0);
			if(status != 0 && status != REG_NOMATCH)
			{
				regerror(status,&reg, error, sizeof(error));
				//printf("regexec -> NON REG_NOMATCH -> ERROR -> status = %s: '\n", error);
				status = -2;
			}
			else if(status == REG_NOMATCH)
			{
				//printf("regexec -> REG_NOMATCH -> ERROR -> status = %s: '\n", error);
				status = -3;
			}
			else
			{
				//printf("regexec -> REG_NOMATCH -> SUCCESS -> pattern = %s, buf = %s \n", pattern, buf);
				printf("%s\n",buf);
				status = 0;
			}
		}
	}
	regfree(&reg);
}
/*
FILE* fd;
if(fd=fopen("TestBash.txt","w")) //.bashrc
{
const char buf[]=%%2;
if(fprintf(fd,buf))
{
//%%3
}
close(fd);
}
*/

53.批量转换编码从Unicode到GB2312

54.删除空文件夹

55.发送数据到剪贴板

56.从剪贴板中取数据

57.获取文件路径的父路径

58.Unicode文件转UTF-8格式


59.CRC循环冗余校验
* 函数crcrevhware是传统的CRC算法的反序算法，其返回值即CRC值 */ 
unsigned short crcrevhware(data,genpoly,accum) 
unsigned short data; 
unsigned short genpoly; 
unsigned short accum; 
{ 
static int i; 
data<<=1; 
for(i=8;i>0;i--) 
{ 
data>>=1; 
if((data^accum)0x0001) 
accum=(accum>>1)^genpoly; 
else 
accum>>=1; 
} 
return accum; 
} 
/* 函数crcrevupdate用以用反序查表法计算CRC值并更新CRC累加器值 */ 
void crcrevupdate(data,accum,crcrevtab) 
unsigned short data; 
unsigned short *accum; 

60.判断是否为空文件
/*
#include <stdio.h>
#include <stdlib.h>
*/
  FILE *fp;
  char ch;
  if((fp=fopen("1.txt","r"))==NULL)
  {
   printf("Error!\n");
   exit(0);
  }
ch=fgetc(fp);
if(ch==EOF)
{
%%1
}

61.终止程序
/*
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <string.h>
*/
char *progname;
static __noreturn usage(void)
{
        fprintf(stderr, "Usage: %s pid\n", progname);
        exit(1);
}
int main(int argc, char *argv[], char *envp[])
{
        long pid;
        char *endp;

        progname = argv[0];
        if (argc != 2)
                usage();

        pid = strtol(argv[1], &endp, 10);
        if (*endp != '\0') {
                perror("pid");
                usage();
        }

        if (kill(pid, SIGTERM) == -1) {
                perror("kill");
                exit(-1);
        }
        exit(0);
}

62.定时关机
/*
#include <stdlib.h>
#include <unistd.h>
#include <signal.h>
#include <sys/reboot.h>
#include <klibc/compiler.h>
*/
static __noreturn usage(void)
{
       static char mesg[] = "Usage: {halt|reboot|poweroff} [-n]\n";
       write(2, mesg, sizeof(mesg) - 1);
       exit(1);
}

int main(int argc, char *argv[])
{
       int cmd = 0; /* initalize to shut gcc up */
       int do_sync = 1;
       char *ptr, *ptr2;

       /* Which action (program name)? */
       ptr2 = ptr = argv[0];
       while (*ptr2)
               if (*ptr2++ == '/')
                       ptr = ptr2;
       if (*ptr == 'r')
               cmd = LINUX_REBOOT_CMD_RESTART;
       else if (*ptr == 'h')
               cmd = LINUX_REBOOT_CMD_HALT;
       else if (*ptr == 'p')
               cmd = LINUX_REBOOT_CMD_POWER_OFF;
       else
               usage();

       /* Walk options */
       while (*++argv && **argv == '-')
               switch (*++*argv) {
                       case 'f': break; /* -f assumed */
                       case 'n': do_sync = 0; break;
                       default:
                               usage();
               }
       if (*argv)
               usage(); /* any args == error */

       if (do_sync)
               sync();
       reboot(LINUX_REBOOT_CMD_CAD_OFF); /* Enable CTRL+ALT+DEL */
       if (!reboot(cmd)) {
               /* Success. Currently, CMD_HALT returns, so stop the world */
               /* kill(-1, SIGSTOP); */
               kill(getpid(), SIGSTOP);
       }
       write(2, "failed.\n", 8);
       return 1;
}

63.显示进程列表
//#include  <tlhelp32.h>
HANDLE hHandle = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS,0);    //创建当前进程快照列表
    if(hHandle != INVALID_HANDLE_VALUE){ 
    PROCESSENTRY32 *pinfo = new PROCESSENTRY32;                            //创建进程信息变量，用于保存信息 
    pinfo->dwSize = sizeof(PROCESSENTRY32);                                //设置块大小 
    if(Process32First(hHandle,pinfo))                                    //开始枚举进程 
    { 
        if(GetLastError() != ERROR_NO_MORE_FILES)
{
            CString %%1,%%2; 
            %%1.Format("%d",pinfo->th32ProcessID);
            %%2.Format("%s",pinfo->szExeFile);
            while(Process32Next(hHandle,pinfo) != FALSE)                //继续获取下一个进程信息 
            { 
                %%1.Format("%-5d",pinfo->th32ProcessID);
                %%2.Format("%-s",pinfo->szExeFile);
            } 
        } 
    } 
    delete pinfo;            //释放空间 
    CloseHandle(hHandle);        //关闭进程句柄
}

64.遍历文件夹列出文件大小
			if(OpenClipboard(NULL))
			{
				BROWSEINFO bInfo;
				ZeroMemory(&bInfo, sizeof(bInfo));
				bInfo.hwndOwner = NULL;
				bInfo.lpszTitle = _T("请选择路径: ");
				bInfo.ulFlags = BIF_RETURNONLYFSDIRS;
				LPITEMIDLIST lpDlist; //用来保存返回信息的IDList
				lpDlist = SHBrowseForFolder(&bInfo) ; //显示选择对话框
				if(lpDlist != NULL)  //用户按了确定按钮
				{
					TCHAR chPath[255]; //用来存储路径的字符串
					SHGetPathFromIDList(lpDlist, chPath);//把项目标识列表转化成字符串
					CFileFind fd;
					deque<CString>delfiles;
					CString path(chPath);
					delfiles.push_back(path);
					CString clip;
					while (delfiles.size()>0)
					{
						CString fn;
						fn.Format("%s\\*.*",delfiles.front());
						BOOL bWorking = fd.FindFile(fn);
						delfiles.pop_front();
						while (bWorking) {
							bWorking = fd.FindNextFile();
							if(fd.IsDirectory() && !fd.IsDots())
							{
								CString filename;
								filename.Format("%s\\*.*",fd.GetFilePath());
								CFileFind finder;
								BOOL aWorking = finder.FindFile(filename);
								while(aWorking)
								{
									aWorking = finder.FindNextFile();
									CString filepath=finder.GetFilePath();
									if(finder.IsDirectory() && !finder.IsDots())
										delfiles.push_back(filepath);
									else if(!finder.IsDirectory() && !finder.IsDots())
									{
										clip+=filepath;
										clip+="\t";
										DWORD dwDirSize=finder.GetLength();
										CString showsize;
										if(dwDirSize>=1073741824)
											showsize.Format("%0.2f GB",(double)dwDirSize/1073741824);
										else if(dwDirSize>=1048576)
											showsize.Format("%0.2f MB",(double)dwDirSize/1048576);
										else if(dwDirSize>=1024)
											showsize.Format("%0.2f KB",(double)dwDirSize/1024);
										else if(dwDirSize>1)
											showsize.Format("%ld Bytes",dwDirSize);
										else
											showsize="1 Byte";
										clip+=showsize;
										clip+="\r\n";
									}
								}
								finder.Close();
							}
							else if(!fd.IsDirectory() && !fd.IsDots())
							{
								clip+=fd.GetFilePath();
								clip+="\t";
								DWORD dwDirSize=fd.GetLength();
								CString showsize;
								if(dwDirSize>=1073741824)
									showsize.Format("%0.2f GB",(double)dwDirSize/1073741824);
								else if(dwDirSize>=1048576)
									showsize.Format("%0.2f MB",(double)dwDirSize/1048576);
								else if(dwDirSize>=1024)
									showsize.Format("%0.2f KB",(double)dwDirSize/1024);
								else if(dwDirSize>1)
									showsize.Format("%ld Bytes",dwDirSize);
								else
									showsize="1 Byte";
								clip+=showsize;
								clip+="\r\n";
							}
						}
						fd.Close();
					}
					HGLOBAL hMem;
					char *pMem;
					hMem = GlobalAlloc( GHND | GMEM_DDESHARE, strlen(clip)+1);
					if(hMem)
					{
						pMem = (char*)GlobalLock(hMem);
						strcpy(pMem,clip);
						GlobalUnlock(hMem);
						EmptyClipboard();
						SetClipboardData(CF_TEXT,hMem);
					}
					CloseClipboard();
				}
			}

65.GOST算法
/*
#include <stdio.h>
#include <stdlib.h>
*/
/* 
 * The GOST 28147-89 cipher 
 * 
 * This is based on the 25 Movember 1993 draft translation 
 * by Aleksandr Malchik, with Whitfield Diffie, of the Government 
 * Standard of the U.S.S.R. GOST 28149-89, "Cryptographic Transformation 
 * Algorithm", effective 1 July 1990.  (Whitfield.Diffie@eng.sun.com) 
 * 
 * That is a draft, and may contain errors, which will be faithfully 
 * reflected here, along with possible exciting new bugs. 
 * 
 * Some details have been cleared up by the paper "Soviet Encryption 
 * Algorithm" by Josef Pieprzyk and Leonid Tombak of the University 
 * of Wollongong, New South Wales.  (josef/leo@cs.adfa.oz.au) 
 * 
 * The standard is written by A. Zabotin (project leader), G.P. Glazkov, 
 * and V.B. Isaeva.  It was accepted and introduced into use by the 
 * action of the State Standards Committee of the USSR on 2 June 89 as 
 * No. 1409.  It was to be reviewed in 1993, but whether anyone wishes 
 * to take on this obligation from the USSR is questionable. 
 * 
 * This code is placed in the public domain. 
 */  
  
/* 
 * If you read the standard, it belabors the point of copying corresponding 
 * bits from point A to point B quite a bit.  It helps to understand that 
 * the standard is uniformly little-endian, although it numbers bits from 
 * 1 rather than 0, so bit n has value 2^(n-1).  The least significant bit 
 * of the 32-bit words that are manipulated in the algorithm is the first, 
 * lowest-numbered, in the bit string. 
 */  
  
  
/* A 32-bit data type */  
#ifdef __alpha  /* Any other 64-bit machines? */  
typedef unsigned int word32;  
#else  
typedef unsigned long word32;  
#endif  
  
/* 
 * The standard does not specify the contents of the 8 4 bit->4 bit 
 * substitution boxes, saying they're a parameter of the network 
 * being set up.  For illustration purposes here, I have used 
 * the first rows of the 8 S-boxes from the DES.  (Note that the 
 * DES S-boxes are numbered starting from 1 at the msb.  In keeping 
 * with the rest of the GOST, I have used little-endian numbering. 
 * Thus, k8 is S-box 1. 
 * 
 * Obviously, a careful look at the cryptographic properties of the cipher 
 * must be undertaken before "production" substitution boxes are defined. 
 * 
 * The standard also does not specify a standard bit-string representation 
 * for the contents of these blocks. 
 */  
static unsigned char const k8[16] = {  
    14,  4, 13,  1,  2, 15, 11,  8,  3, 10,  6, 12,  5,  9,  0,  7 };   
static unsigned char const k7[16] = {  
    15,  1,  8, 14,  6, 11,  3,  4,  9,  7,  2, 13, 12,  0,  5, 10 };  
static unsigned char const k6[16] = {  
    10,  0,  9, 14,  6,  3, 15,  5,  1, 13, 12,  7, 11,  4,  2,  8 };  
static unsigned char const k5[16] = {  
     7, 13, 14,  3,  0,  6,  9, 10,  1,  2,  8,  5, 11, 12,  4, 15 };  
static unsigned char const k4[16] = {  
     2, 12,  4,  1,  7, 10, 11,  6,  8,  5,  3, 15, 13,  0, 14,  9 };  
static unsigned char const k3[16] = {  
    12,  1, 10, 15,  9,  2,  6,  8,  0, 13,  3,  4, 14,  7,  5, 11 };  
static unsigned char const k2[16] = {  
     4, 11,  2, 14, 15,  0,  8, 13,  3, 12,  9,  7,  5, 10,  6,  1 };  
static unsigned char const k1[16] = {  
    13,  2,  8,  4,  6, 15, 11,  1, 10,  9,  3, 14,  5,  0, 12,  7 };  
  
/* Byte-at-a-time substitution boxes */  
static unsigned char k87[256];  
static unsigned char k65[256];  
static unsigned char k43[256];  
static unsigned char k21[256];  
  
/* 
 * Build byte-at-a-time subtitution tables. 
 * This must be called once for global setup. 
 */  
void  
kboxinit(void)  
{  
    int i;  
    for (i = 0; i < 256; i++) {  
        k87[i] = k8[i >> 4] << 4 | k7[i & 15];  
        k65[i] = k6[i >> 4] << 4 | k5[i & 15];  
        k43[i] = k4[i >> 4] << 4 | k3[i & 15];  
        k21[i] = k2[i >> 4] << 4 | k1[i & 15];  
    }  
}  
  
/* 
 * Do the substitution and rotation that are the core of the operation, 
 * like the expansion, substitution and permutation of the DES. 
 * It would be possible to perform DES-like optimisations and store 
 * the table entries as 32-bit words, already rotated, but the 
 * efficiency gain is questionable. 
 * 
 * This should be inlined for maximum speed 
 */  
#if __GNUC__  
__inline__  
#endif  
static word32  
f(word32 x)  
{  
    /* Do substitutions */  
#if 0  
    /* This is annoyingly slow */  
    x = k8[x>>28 & 15] << 28 | k7[x>>24 & 15] << 24 |  
        k6[x>>20 & 15] << 20 | k5[x>>16 & 15] << 16 |  
        k4[x>>12 & 15] << 12 | k3[x>> 8 & 15] <<  8 |  
        k2[x>> 4 & 15] <<  4 | k1[x     & 15];  
#else  
    /* This is faster */  
    x = k87[x>>24 & 255] << 24 | k65[x>>16 & 255] << 16 |  
        k43[x>> 8 & 255] <<  8 | k21[x & 255];  
#endif  
  
    /* Rotate left 11 bits */  
    return x<<11 | x>>(32-11);  
}  
  
/* 
 * The GOST standard defines the input in terms of bits 1..64, with 
 * bit 1 being the lsb of in[0] and bit 64 being the msb of in[1]. 
 * 
 * The keys are defined similarly, with bit 256 being the msb of key[7]. 
 */  
void  
gostcrypt(word32 const in[2], word32 out[2], word32 const key[8])  
{  
    register word32 n1, n2; /* As named in the GOST */  
  
    n1 = in[0];  
    n2 = in[1];  
  
    /* Instead of swapping halves, swap names each round */  
    n2 ^= f(n1+key[0]);  
    n1 ^= f(n2+key[1]);  
    n2 ^= f(n1+key[2]);  
    n1 ^= f(n2+key[3]);  
    n2 ^= f(n1+key[4]);  
    n1 ^= f(n2+key[5]);  
    n2 ^= f(n1+key[6]);  
    n1 ^= f(n2+key[7]);  
  
    n2 ^= f(n1+key[0]);  
    n1 ^= f(n2+key[1]);  
    n2 ^= f(n1+key[2]);  
    n1 ^= f(n2+key[3]);  
    n2 ^= f(n1+key[4]);  
    n1 ^= f(n2+key[5]);  
    n2 ^= f(n1+key[6]);  
    n1 ^= f(n2+key[7]);  
  
    n2 ^= f(n1+key[0]);  
    n1 ^= f(n2+key[1]);  
    n2 ^= f(n1+key[2]);  
    n1 ^= f(n2+key[3]);  
    n2 ^= f(n1+key[4]);  
    n1 ^= f(n2+key[5]);  
    n2 ^= f(n1+key[6]);  
    n1 ^= f(n2+key[7]);  
  
    n2 ^= f(n1+key[7]);  
    n1 ^= f(n2+key[6]);  
    n2 ^= f(n1+key[5]);  
    n1 ^= f(n2+key[4]);  
    n2 ^= f(n1+key[3]);  
    n1 ^= f(n2+key[2]);  
    n2 ^= f(n1+key[1]);  
    n1 ^= f(n2+key[0]);  
  
    /* There is no swap after the last round */  
    out[0] = n2;  
    out[1] = n1;  
}  
      
  
/* 
 * The key schedule is somewhat different for decryption. 
 * (The key table is used once forward and three times backward.) 
 * You could define an expanded key, or just write the code twice, 
 * as done here. 
 */  
void  
gostdecrypt(word32 const in[2], word32 out[2], word32 const key[8])  
{  
    register word32 n1, n2; /* As named in the GOST */  
  
    n1 = in[0];  
    n2 = in[1];  
  
    n2 ^= f(n1+key[0]);  
    n1 ^= f(n2+key[1]);  
    n2 ^= f(n1+key[2]);  
    n1 ^= f(n2+key[3]);  
    n2 ^= f(n1+key[4]);  
    n1 ^= f(n2+key[5]);  
    n2 ^= f(n1+key[6]);  
    n1 ^= f(n2+key[7]);  
  
    n2 ^= f(n1+key[7]);  
    n1 ^= f(n2+key[6]);  
    n2 ^= f(n1+key[5]);  
    n1 ^= f(n2+key[4]);  
    n2 ^= f(n1+key[3]);  
    n1 ^= f(n2+key[2]);  
    n2 ^= f(n1+key[1]);  
    n1 ^= f(n2+key[0]);  
  
    n2 ^= f(n1+key[7]);  
    n1 ^= f(n2+key[6]);  
    n2 ^= f(n1+key[5]);  
    n1 ^= f(n2+key[4]);  
    n2 ^= f(n1+key[3]);  
    n1 ^= f(n2+key[2]);  
    n2 ^= f(n1+key[1]);  
    n1 ^= f(n2+key[0]);  
  
    n2 ^= f(n1+key[7]);  
    n1 ^= f(n2+key[6]);  
    n2 ^= f(n1+key[5]);  
    n1 ^= f(n2+key[4]);  
    n2 ^= f(n1+key[3]);  
    n1 ^= f(n2+key[2]);  
    n2 ^= f(n1+key[1]);  
    n1 ^= f(n2+key[0]);  
  
    out[0] = n2;  
    out[1] = n1;  
}  
  
/* 
 * The GOST "Output feedback" standard.  It seems closer morally 
 * to the counter feedback mode some people have proposed for DES. 
 * The avoidance of the short cycles that are possible in OFB seems 
 * like a Good Thing. 
 * 
 * Calling it the stream mode makes more sense. 
 * 
 * The IV is encrypted with the key to produce the initial counter value. 
 * Then, for each output block, a constant is added, modulo 2^32-1 
 * (0 is represented as all-ones, not all-zeros), to each half of 
 * the counter, and the counter is encrypted to produce the value 
 * to XOR with the output. 
 * 
 * Len is the number of blocks.  Sub-block encryption is 
 * left as an exercise for the user.  Remember that the 
 * standard defines everything in a little-endian manner, 
 * so you want to use the low bit of gamma[0] first. 
 * 
 * OFB is, of course, self-inverse, so there is only one function. 
 */  
  
/* The constants for addition */  
#define C1 0x01010104  
#define C2 0x01010101  
  
void  
gostofb(word32 const *in, word32 *out, int len,  
    word32 const iv[2], word32 const key[8])  
{  
    word32 temp[2];         /* Counter */  
    word32 gamma[2];        /* Output XOR value */  
  
    /* Compute starting value for counter */  
    gostcrypt(iv, temp, key);  
  
    while (len--) {  
        temp[0] += C2;  
        if (temp[0] < C2)       /* Wrap modulo 2^32? */  
            temp[0]++;      /* Make it modulo 2^32-1 */  
        temp[1] += C1;  
        if (temp[1] < C1)       /* Wrap modulo 2^32? */  
            temp[1]++;      /* Make it modulo 2^32-1 */  
  
        gostcrypt(temp, gamma, key);  
  
        *out++ = *in++ ^ gamma[0];  
        *out++ = *in++ ^ gamma[1];  
    }  
}  
  
/* 
 * The CFB mode is just what you'd expect.  Each block of ciphertext y[] is 
 * derived from the input x[] by the following pseudocode: 
 * y[i] = x[i] ^ gostcrypt(y[i-1]) 
 * x[i] = y[i] ^ gostcrypt(y[i-1]) 
 * Where y[-1] is the IV. 
 * 
 * The IV is modified in place.  Again, len is in *blocks*. 
 */  
  
void  
gostcfbencrypt(word32 const *in, word32 *out, int len,  
           word32 iv[2], word32 const key[8])  
{  
    while (len--) {  
        gostcrypt(iv, iv, key);  
        iv[0] = *out++ ^= iv[0];  
        iv[1] = *out++ ^= iv[1];  
    }  
}  
  
void  
gostcfbdecrypt(word32 const *in, word32 *out, int len,  
           word32 iv[2], word32 const key[8])  
{  
    word32 t;  
    while (len--) {  
        gostcrypt(iv, iv, key);  
        t = *out;  
        *out++ ^= iv[0];  
        iv[0] = t;  
        t = *out;  
        *out++ ^= iv[1];  
        iv[1] = t;  
    }  
}  
  
  
/* 
 * The message suthetication code uses only 16 of the 32 rounds. 
 * There *is* a swap after the 16th round. 
 * The last block should be padded to 64 bits with zeros. 
 * len is the number of *blocks* in the input. 
 */  
void  
gostmac(word32 const *in, int len, word32 out[2], word32 const key[8])  
{  
    register word32 n1, n2; /* As named in the GOST */  
  
    n1 = 0;  
    n2 = 0;  
  
    while (len--) {  
        n1 ^= *in++;  
        n2 = *in++;  
  
        /* Instead of swapping halves, swap names each round */  
        n2 ^= f(n1+key[0]);  
        n1 ^= f(n2+key[1]);  
        n2 ^= f(n1+key[2]);  
        n1 ^= f(n2+key[3]);  
        n2 ^= f(n1+key[4]);  
        n1 ^= f(n2+key[5]);  
        n2 ^= f(n1+key[6]);  
        n1 ^= f(n2+key[7]);  
  
        n2 ^= f(n1+key[0]);  
        n1 ^= f(n2+key[1]);  
        n2 ^= f(n1+key[2]);  
        n1 ^= f(n2+key[3]);  
        n2 ^= f(n1+key[4]);  
        n1 ^= f(n2+key[5]);  
        n2 ^= f(n1+key[6]);  
        n1 ^= f(n2+key[7]);  
    }  
  
    out[0] = n1;  
    out[1] = n2;  
}
  
/* Designed to cope with 15-bit rand() implementations */  
#define RAND32 ((word32)rand() << 17 ^ (word32)rand() << 9 ^ rand()) 
    word32 key[8];  
    word32 plain[2];  
    word32 cipher[2];  
    int i, j;  
  
    kboxinit();  
  
    printf("GOST 21847-89 test driver.\n");  
  
    for (i = 0; i < 1000; i++) {  
        for (j = 0; j < 8; j++)  
            key[j] = RAND32;  
        plain[0] = RAND32;  
        plain[1] = RAND32;  
  
        printf("%3d\r", i);  
        fflush(stdout);  
  
        gostcrypt(plain, cipher, key);  
        for (j = 0; j < 99; j++)  
            gostcrypt(cipher, cipher, key);  
        for (j = 0; j < 100; j++)  
            gostdecrypt(cipher, cipher, key);  
  
        if (plain[0] != cipher[0] || plain[1] != cipher[1]) {  
            fprintf(stderr, "\nError! i = %d\n", i);  
            return 1;  
        }  
    }

66.对目标压缩文件解压缩到指定文件夹

67.保存文件时重名自动生成新文件

68.打开网页

69.删除空文件夹整合操作

70.获取磁盘所有分区，把结果放在数组drives中 

71.激活一个程序或程序关联的文件

72.MP3播放

73.WAV播放

74.写图像到剪切板 setClipboardImage

75.从剪贴板复制图像到窗体

76.删除文件夹下的所有文件且不删除文件夹下的文件夹

77.XML遍历结点属性值

78.拷贝文件名复制文件

79.开源程序库Xercesc-C++代码工程中内联

80.提取包含头文件列表

81.剪贴板文本转换成打印字符

82.Java程序打包

83.UTF-8文件转Unicode格式

84.创建PDF文档

85.创建Word文档

86.快速高效的文件加密

87.菜单勾选/取消开机自启动程序

88.菜单勾选/取消自动登录系统

89.模拟键盘输入字符串

90.提取PDF文件中的文本

91.操作内存映射文件

92.重定向windows控制台程序的输出信息

93.基数转序数

94.数字月份转英文

95.报表相关
xlslib和libxls默认
这2个是gnu的项目，我把它们修改下并且结合在一起作数据处理。
编译程序前现设好库和头文件 做好相应的连接
libxls 0.20 版本
test.c 载入xls文件 输出txt文件   输入内容和输入内容都写在程序中
sudo gcc test.c -o test -I /usr/include/libxls/ -L /usr/lib/libxls  -lxlsreader

xlslib-1.0 使用的是 1.0版本
wb.c  载入 txt文件 输入 xls文件   输入内容和输出内容都些在程序中
sudo gcc wb.c -o wb -I /usr/include/xlslib/ -L /usr/lib/ -lxls

程序不支持中文 
/*
#include <stdio.h>
#include <stdint.h>
#include <string.h>
#include <xlslib/xlslib.h>
*/
  workbook *w;
  worksheet *ws;
  int ret;
  FILE *fp;            //***
  char str;            //***
  int rows = 0;            //***
  int cols = 0;            //***
  char tmp[255];
  int i = 0;



  w = newWorkbook ();
  ws = callWorkbookSheet (w, "xlslib1");//打开要写入的


  //if(!(fp=fopen("/opt/libxls-0.2.0/test.txt","r")))
  if (!(fp = fopen ("/opt/libxls-0.2.0/test/test.txt", "r")))//打开读入文件
    {
      printf ("cannot open file\n");
      exit (1);
    }

  while ((str = getc (fp)) != EOF)    //检测文件是不结束
    {

      if (str != '\t' && str != '\n')    //不是tab，字符组合
    {


      printf ("%i\n", i);
      printf ("%c", str);
      tmp[i] = str;
//              strcpy(&tmp[i],str);

      i++;
    }
      //是tab 则输出到表格并让指针归0
      else
    {

      tmp[i] = '\0';
      printf ("第%d行\n", rows);
      printf ("第%d列\n", cols);
      printf ("%s", tmp);
      callWorksheetLabel (ws, rows, cols, tmp, 0);
      cols++;
      i = 0;
    }

      //检测文件是不换行
      if (str == '\n')
    {
       
      rows++;
      cols = 0;
    }            //如果还行，行数＋1，列数规0
    }


  fclose (fp);




/*    callWorksheetNumber(ws, 1, 1, 1.0, FMT_GENERAL, 0);
    callWorksheetNumber(ws, 2, 1, 1.0, FMT_GENERAL, 0);
    callWorksheetNumber(ws, 3, 1, 1.0, FMT_GENERAL, 0);
    callWorksheetLabel(ws, 4, 1, "=SUM(A1:A3)", 0);
*/
  ret = callWorkbookDump (w, "%%1.xls");
  printf ("saved it ret=%d!\n", ret);
  deleteWorkbook (w);
  printf ("deleted it!\n");

/*
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <libxls/xls.h>
*/
  xlsWorkBook *pWB;
  xlsWorkSheet *pWS;
  FILE *f;
  int i;

  struct st_row_data *row;
  WORD t, tt;
  pWB = xls_open ("%%1.xls", "ASCII");    // "KOI8-R"打开要转换的xls文件

  if (pWB != NULL)
    {
      f = fopen ("test.txt", "w");    //打开要写入的文件
      for (i = 0; i < pWB->sheets.count; i++)
    printf ("Sheet N%i (%s) pos %i\n", i, pWB->sheets.sheet[i].name,
        pWB->sheets.sheet[i].filepos);

      pWS = xls_getWorkSheet (pWB, 0);
      xls_parseWorkSheet (pWS);

      for (t = 0; t <= pWS->rows.lastrow; t++)    //对xls行处理
    {
      row = &pWS->rows.row[t];
     
      for (tt = 0; tt <= pWS->rows.lastcol; tt++)    //列处理
        {
          if (!row->cells.cell[tt].ishiden)
        {
         
          if (row->cells.cell[tt].colspan)
            fprintf (f, " colspan=%i", row->cells.cell[tt].colspan);
         
          if (row->cells.cell[tt].rowspan)
            fprintf (f, " rowspan=%i", row->cells.cell[tt].rowspan);
          
          if (row->cells.cell[tt].str != NULL
              && row->cells.cell[tt].str[0] != '\0')
            fprintf (f, "%s", row->cells.cell[tt].str);
         
          fprintf (f, "\t");
        }
        }
     
      fprintf (f, "\n");
    }
      
      printf ("Count of rows: %i\n", pWS->rows.lastrow);
      printf ("Max col: %i\n", pWS->rows.lastcol);
      printf ("Count of sheets: %i\n", pWB->sheets.count);

      fclose (f);
      xls_showBookInfo (pWB);
    }

96.BCP导入
//import java.io.*;
try{
	Runtime.getRuntime().exec("BCP %%0.%%1 in %%2 -c -T");
} catch (IOException ex) {
	ex.printStackTrace();
}

97.BCP导出
97.1.表导出
//import java.io.*;
try{
	Runtime.getRuntime().exec("BCP %%0.%%1 out %%2 -c -U\""sa\"" -P\""password\"");
} catch (IOException ex) {
	ex.printStackTrace();
}

97.2.查询导出
//import java.io.*;
try{
	Runtime.getRuntime().exec("BCP \""SELECT * FROM %%0.%%1\"" queryout %%1 -c -U"sa" -P\""password\"");
} catch (IOException ex) {
	ex.printStackTrace();
}

98.计算文件MD5值
/*
#include <string>
#include <fstream>
#include <iostream>
using namespace std;
*/
typedef unsigned char byte;
typedef unsigned int uint32;

using std::string;
using std::ifstream;

MD5();
MD5(const void* input, size_t length);
MD5(const string& str);
MD5(ifstream& in);
void update(const void* input, size_t length);
void update(const string& str);
void update(ifstream& in);
const byte* digest();
void reset();

void update(const byte* input, size_t length);
void final();
void transform(const byte block[64]);
void encode(const uint32* input, byte* output, size_t length);
void decode(const byte* input, uint32* output, size_t length);
string bytesToHexString(const byte* input, size_t length);

uint32 _state[4]; /* state (ABCD) */
uint32 _count[2]; /* number of bits, modulo 2^64 (low-order word first) */
byte _buffer[64]; /* input buffer */
byte _digest[16]; /* message digest */
bool _finished;   /* calculate finished ? */

enum { BUFFER_SIZE = 1024 };

/* Constants for MD5Transform routine. */
#define S11 7
#define S12 12
#define S13 17
#define S14 22
#define S21 5
#define S22 9
#define S23 14
#define S24 20
#define S31 4
#define S32 11
#define S33 16
#define S34 23
#define S41 6
#define S42 10
#define S43 15
#define S44 21


/* F, G, H and I are basic MD5 functions.
*/
#define F(x, y, z) (((x) & (y)) | ((~x) & (z)))
#define G(x, y, z) (((x) & (z)) | ((y) & (~z)))
#define H(x, y, z) ((x) ^ (y) ^ (z))
#define I(x, y, z) ((y) ^ ((x) | (~z)))

/* ROTATE_LEFT rotates x left n bits.
*/
#define ROTATE_LEFT(x, n) (((x) << (n)) | ((x) >> (32-(n))))

/* FF, GG, HH, and II transformations for rounds 1, 2, 3, and 4.
Rotation is separate from addition to prevent recomputation.
*/
#define FF(a, b, c, d, x, s, ac) { \
	(a) += F ((b), (c), (d)) + (x) + ac; \
	(a) = ROTATE_LEFT ((a), (s)); \
	(a) += (b); \
}
#define GG(a, b, c, d, x, s, ac) { \
	(a) += G ((b), (c), (d)) + (x) + ac; \
	(a) = ROTATE_LEFT ((a), (s)); \
	(a) += (b); \
}
#define HH(a, b, c, d, x, s, ac) { \
	(a) += H ((b), (c), (d)) + (x) + ac; \
	(a) = ROTATE_LEFT ((a), (s)); \
	(a) += (b); \
}
#define II(a, b, c, d, x, s, ac) { \
	(a) += I ((b), (c), (d)) + (x) + ac; \
	(a) = ROTATE_LEFT ((a), (s)); \
	(a) += (b); \
}


static const byte PADDING[64] = { 0x80 };
static const char HEX[16] = {
	'0', '1', '2', '3',
		'4', '5', '6', '7',
		'8', '9', 'a', 'b',
		'c', 'd', 'e', 'f'
};


/* Return the message-digest */
const byte* digest() {
	
	if (!_finished) {
		_finished = true;
		final();
	}
	return _digest;
}

/* Reset the calculate state */
void reset() {
	
	_finished = false;
	/* reset number of bits. */
	_count[0] = _count[1] = 0;
	/* Load magic initialization constants. */
	_state[0] = 0x67452301;
	_state[1] = 0xefcdab89;
	_state[2] = 0x98badcfe;
	_state[3] = 0x10325476;
}

/* Updating the context with a input buffer. */
void update(const void* input, size_t length) {
	update((const byte*)input, length);
}

/* Updating the context with a string. */
void update(const string& str) {
	update((const byte*)str.c_str(), str.length());
}

/* Updating the context with a file. */
void update(ifstream& in) {
	if(in)
	{
		std::streamsize length;
		char buffer[BUFFER_SIZE];
		while (!in.eof()) {
			in.read(buffer, BUFFER_SIZE);
			length = in.gcount();
			if (length > 0) {
				update(buffer, length);
			}
		}
		in.close();
	}
}

/* MD5 block update operation. Continues an MD5 message-digest
operation, processing another message block, and updating the
context.
*/
void update(const byte* input, size_t length) {
	
	uint32 i, index, partLen;
	
	_finished = false;
	
	/* Compute number of bytes mod 64 */
	index = (uint32)((_count[0] >> 3) & 0x3f);
	
	/* update number of bits */
	if ((_count[0] += ((uint32)length << 3)) < ((uint32)length << 3)) {
		++_count[1];
	}
	_count[1] += ((uint32)length >> 29);
	
	partLen = 64 - index;
	
	/* transform as many times as possible. */
	if (length >= partLen) {
		
		memcpy(&_buffer[index], input, partLen);
		transform(_buffer);
		
		for (i = partLen; i + 63 < length; i += 64) {
			transform(&input[i]);
		}
		index = 0;
		
	} else {
		i = 0;
	}
	
	/* Buffer remaining input */
	memcpy(&_buffer[index], &input[i], length - i);
}

/* MD5 finalization. Ends an MD5 message-_digest operation, writing the
the message _digest and zeroizing the context.
*/
void final() {
	
	byte bits[8];
	uint32 oldState[4];
	uint32 oldCount[2];
	uint32 index, padLen;
	
	/* Save current state and count. */
	memcpy(oldState, _state, 16);
	memcpy(oldCount, _count, 8);
	
	/* Save number of bits */
	encode(_count, bits, 8);
	
	/* Pad out to 56 mod 64. */
	index = (uint32)((_count[0] >> 3) & 0x3f);
	padLen = (index < 56) ? (56 - index) : (120 - index);
	update(PADDING, padLen);
	
	/* Append length (before padding) */
	update(bits, 8);
	
	/* Store state in digest */
	encode(_state, _digest, 16);
	
	/* Restore current state and count. */
	memcpy(_state, oldState, 16);
	memcpy(_count, oldCount, 8);
}

/* MD5 basic transformation. Transforms _state based on block. */
void transform(const byte block[64]) {
	
	uint32 a = _state[0], b = _state[1], c = _state[2], d = _state[3], x[16];
	
	decode(block, x, 64);
	
	/* Round 1 */
	FF (a, b, c, d, x[ 0], S11, 0xd76aa478); /* 1 */
	FF (d, a, b, c, x[ 1], S12, 0xe8c7b756); /* 2 */
	FF (c, d, a, b, x[ 2], S13, 0x242070db); /* 3 */
	FF (b, c, d, a, x[ 3], S14, 0xc1bdceee); /* 4 */
	FF (a, b, c, d, x[ 4], S11, 0xf57c0faf); /* 5 */
	FF (d, a, b, c, x[ 5], S12, 0x4787c62a); /* 6 */
	FF (c, d, a, b, x[ 6], S13, 0xa8304613); /* 7 */
	FF (b, c, d, a, x[ 7], S14, 0xfd469501); /* 8 */
	FF (a, b, c, d, x[ 8], S11, 0x698098d8); /* 9 */
	FF (d, a, b, c, x[ 9], S12, 0x8b44f7af); /* 10 */
	FF (c, d, a, b, x[10], S13, 0xffff5bb1); /* 11 */
	FF (b, c, d, a, x[11], S14, 0x895cd7be); /* 12 */
	FF (a, b, c, d, x[12], S11, 0x6b901122); /* 13 */
	FF (d, a, b, c, x[13], S12, 0xfd987193); /* 14 */
	FF (c, d, a, b, x[14], S13, 0xa679438e); /* 15 */
	FF (b, c, d, a, x[15], S14, 0x49b40821); /* 16 */
	
	/* Round 2 */
	GG (a, b, c, d, x[ 1], S21, 0xf61e2562); /* 17 */
	GG (d, a, b, c, x[ 6], S22, 0xc040b340); /* 18 */
	GG (c, d, a, b, x[11], S23, 0x265e5a51); /* 19 */
	GG (b, c, d, a, x[ 0], S24, 0xe9b6c7aa); /* 20 */
	GG (a, b, c, d, x[ 5], S21, 0xd62f105d); /* 21 */
	GG (d, a, b, c, x[10], S22, 0x2441453); /* 22 */
	GG (c, d, a, b, x[15], S23, 0xd8a1e681); /* 23 */
	GG (b, c, d, a, x[ 4], S24, 0xe7d3fbc8); /* 24 */
	GG (a, b, c, d, x[ 9], S21, 0x21e1cde6); /* 25 */
	GG (d, a, b, c, x[14], S22, 0xc33707d6); /* 26 */
	GG (c, d, a, b, x[ 3], S23, 0xf4d50d87); /* 27 */
	GG (b, c, d, a, x[ 8], S24, 0x455a14ed); /* 28 */
	GG (a, b, c, d, x[13], S21, 0xa9e3e905); /* 29 */
	GG (d, a, b, c, x[ 2], S22, 0xfcefa3f8); /* 30 */
	GG (c, d, a, b, x[ 7], S23, 0x676f02d9); /* 31 */
	GG (b, c, d, a, x[12], S24, 0x8d2a4c8a); /* 32 */
	
	/* Round 3 */
	HH (a, b, c, d, x[ 5], S31, 0xfffa3942); /* 33 */
	HH (d, a, b, c, x[ 8], S32, 0x8771f681); /* 34 */
	HH (c, d, a, b, x[11], S33, 0x6d9d6122); /* 35 */
	HH (b, c, d, a, x[14], S34, 0xfde5380c); /* 36 */
	HH (a, b, c, d, x[ 1], S31, 0xa4beea44); /* 37 */
	HH (d, a, b, c, x[ 4], S32, 0x4bdecfa9); /* 38 */
	HH (c, d, a, b, x[ 7], S33, 0xf6bb4b60); /* 39 */
	HH (b, c, d, a, x[10], S34, 0xbebfbc70); /* 40 */
	HH (a, b, c, d, x[13], S31, 0x289b7ec6); /* 41 */
	HH (d, a, b, c, x[ 0], S32, 0xeaa127fa); /* 42 */
	HH (c, d, a, b, x[ 3], S33, 0xd4ef3085); /* 43 */
	HH (b, c, d, a, x[ 6], S34, 0x4881d05); /* 44 */
	HH (a, b, c, d, x[ 9], S31, 0xd9d4d039); /* 45 */
	HH (d, a, b, c, x[12], S32, 0xe6db99e5); /* 46 */
	HH (c, d, a, b, x[15], S33, 0x1fa27cf8); /* 47 */
	HH (b, c, d, a, x[ 2], S34, 0xc4ac5665); /* 48 */
	
	/* Round 4 */
	II (a, b, c, d, x[ 0], S41, 0xf4292244); /* 49 */
	II (d, a, b, c, x[ 7], S42, 0x432aff97); /* 50 */
	II (c, d, a, b, x[14], S43, 0xab9423a7); /* 51 */
	II (b, c, d, a, x[ 5], S44, 0xfc93a039); /* 52 */
	II (a, b, c, d, x[12], S41, 0x655b59c3); /* 53 */
	II (d, a, b, c, x[ 3], S42, 0x8f0ccc92); /* 54 */
	II (c, d, a, b, x[10], S43, 0xffeff47d); /* 55 */
	II (b, c, d, a, x[ 1], S44, 0x85845dd1); /* 56 */
	II (a, b, c, d, x[ 8], S41, 0x6fa87e4f); /* 57 */
	II (d, a, b, c, x[15], S42, 0xfe2ce6e0); /* 58 */
	II (c, d, a, b, x[ 6], S43, 0xa3014314); /* 59 */
	II (b, c, d, a, x[13], S44, 0x4e0811a1); /* 60 */
	II (a, b, c, d, x[ 4], S41, 0xf7537e82); /* 61 */
	II (d, a, b, c, x[11], S42, 0xbd3af235); /* 62 */
	II (c, d, a, b, x[ 2], S43, 0x2ad7d2bb); /* 63 */
	II (b, c, d, a, x[ 9], S44, 0xeb86d391); /* 64 */
	
	_state[0] += a;
	_state[1] += b;
	_state[2] += c;
	_state[3] += d;
}

/* Encodes input (ulong) into output (byte). Assumes length is
a multiple of 4.
*/
void encode(const uint32* input, byte* output, size_t length) {
	
	for (size_t i = 0, j = 0; j < length; ++i, j += 4) {
		output[j]= (byte)(input[i] & 0xff);
		output[j + 1] = (byte)((input[i] >> 8) & 0xff);
		output[j + 2] = (byte)((input[i] >> 16) & 0xff);
		output[j + 3] = (byte)((input[i] >> 24) & 0xff);
	}
}

/* Decodes input (byte) into output (ulong). Assumes length is
a multiple of 4.
*/
void decode(const byte* input, uint32* output, size_t length) {
	
	for (size_t i = 0, j = 0; j < length; ++i, j += 4) {
		output[i] = ((uint32)input[j]) | (((uint32)input[j + 1]) << 8) |
			(((uint32)input[j + 2]) << 16) | (((uint32)input[j + 3]) << 24);
	}
}

/* Convert byte array to hex string. */
string bytesToHexString(const byte* input, size_t length) {
	
	string str;
	str.reserve(length << 1);
	for (size_t i = 0; i < length; ++i) {
		int t = input[i];
		int a = t / 16;
		int b = t % 16;
		str.append(1, HEX[a]);
		str.append(1, HEX[b]);
	}
	return str;
}
		reset();
		update(ifstream(%%1));
		string str=bytesToHexString(digest(), 16);

99.计算获取文件夹中文件的MD5值
/*
#include <string>
#include <fstream>
#include <iostream>
using namespace std;
*/
typedef unsigned char byte;
typedef unsigned int uint32;

using std::string;
using std::ifstream;

MD5();
MD5(const void* input, size_t length);
MD5(const string& str);
MD5(ifstream& in);
void update(const void* input, size_t length);
void update(const string& str);
void update(ifstream& in);
const byte* digest();
void reset();

void update(const byte* input, size_t length);
void final();
void transform(const byte block[64]);
void encode(const uint32* input, byte* output, size_t length);
void decode(const byte* input, uint32* output, size_t length);
string bytesToHexString(const byte* input, size_t length);

uint32 _state[4]; /* state (ABCD) */
uint32 _count[2]; /* number of bits, modulo 2^64 (low-order word first) */
byte _buffer[64]; /* input buffer */
byte _digest[16]; /* message digest */
bool _finished;   /* calculate finished ? */

enum { BUFFER_SIZE = 1024 };

/* Constants for MD5Transform routine. */
#define S11 7
#define S12 12
#define S13 17
#define S14 22
#define S21 5
#define S22 9
#define S23 14
#define S24 20
#define S31 4
#define S32 11
#define S33 16
#define S34 23
#define S41 6
#define S42 10
#define S43 15
#define S44 21


/* F, G, H and I are basic MD5 functions.
*/
#define F(x, y, z) (((x) & (y)) | ((~x) & (z)))
#define G(x, y, z) (((x) & (z)) | ((y) & (~z)))
#define H(x, y, z) ((x) ^ (y) ^ (z))
#define I(x, y, z) ((y) ^ ((x) | (~z)))

/* ROTATE_LEFT rotates x left n bits.
*/
#define ROTATE_LEFT(x, n) (((x) << (n)) | ((x) >> (32-(n))))

/* FF, GG, HH, and II transformations for rounds 1, 2, 3, and 4.
Rotation is separate from addition to prevent recomputation.
*/
#define FF(a, b, c, d, x, s, ac) { \
	(a) += F ((b), (c), (d)) + (x) + ac; \
	(a) = ROTATE_LEFT ((a), (s)); \
	(a) += (b); \
}
#define GG(a, b, c, d, x, s, ac) { \
	(a) += G ((b), (c), (d)) + (x) + ac; \
	(a) = ROTATE_LEFT ((a), (s)); \
	(a) += (b); \
}
#define HH(a, b, c, d, x, s, ac) { \
	(a) += H ((b), (c), (d)) + (x) + ac; \
	(a) = ROTATE_LEFT ((a), (s)); \
	(a) += (b); \
}
#define II(a, b, c, d, x, s, ac) { \
	(a) += I ((b), (c), (d)) + (x) + ac; \
	(a) = ROTATE_LEFT ((a), (s)); \
	(a) += (b); \
}


static const byte PADDING[64] = { 0x80 };
static const char HEX[16] = {
	'0', '1', '2', '3',
		'4', '5', '6', '7',
		'8', '9', 'a', 'b',
		'c', 'd', 'e', 'f'
};


/* Return the message-digest */
const byte* digest() {
	
	if (!_finished) {
		_finished = true;
		final();
	}
	return _digest;
}

/* Reset the calculate state */
void reset() {
	
	_finished = false;
	/* reset number of bits. */
	_count[0] = _count[1] = 0;
	/* Load magic initialization constants. */
	_state[0] = 0x67452301;
	_state[1] = 0xefcdab89;
	_state[2] = 0x98badcfe;
	_state[3] = 0x10325476;
}

/* Updating the context with a input buffer. */
void update(const void* input, size_t length) {
	update((const byte*)input, length);
}

/* Updating the context with a string. */
void update(const string& str) {
	update((const byte*)str.c_str(), str.length());
}

/* Updating the context with a file. */
void update(ifstream& in) {
	if(in)
	{
		std::streamsize length;
		char buffer[BUFFER_SIZE];
		while (!in.eof()) {
			in.read(buffer, BUFFER_SIZE);
			length = in.gcount();
			if (length > 0) {
				update(buffer, length);
			}
		}
		in.close();
	}
}

/* MD5 block update operation. Continues an MD5 message-digest
operation, processing another message block, and updating the
context.
*/
void update(const byte* input, size_t length) {
	
	uint32 i, index, partLen;
	
	_finished = false;
	
	/* Compute number of bytes mod 64 */
	index = (uint32)((_count[0] >> 3) & 0x3f);
	
	/* update number of bits */
	if ((_count[0] += ((uint32)length << 3)) < ((uint32)length << 3)) {
		++_count[1];
	}
	_count[1] += ((uint32)length >> 29);
	
	partLen = 64 - index;
	
	/* transform as many times as possible. */
	if (length >= partLen) {
		
		memcpy(&_buffer[index], input, partLen);
		transform(_buffer);
		
		for (i = partLen; i + 63 < length; i += 64) {
			transform(&input[i]);
		}
		index = 0;
		
	} else {
		i = 0;
	}
	
	/* Buffer remaining input */
	memcpy(&_buffer[index], &input[i], length - i);
}

/* MD5 finalization. Ends an MD5 message-_digest operation, writing the
the message _digest and zeroizing the context.
*/
void final() {
	
	byte bits[8];
	uint32 oldState[4];
	uint32 oldCount[2];
	uint32 index, padLen;
	
	/* Save current state and count. */
	memcpy(oldState, _state, 16);
	memcpy(oldCount, _count, 8);
	
	/* Save number of bits */
	encode(_count, bits, 8);
	
	/* Pad out to 56 mod 64. */
	index = (uint32)((_count[0] >> 3) & 0x3f);
	padLen = (index < 56) ? (56 - index) : (120 - index);
	update(PADDING, padLen);
	
	/* Append length (before padding) */
	update(bits, 8);
	
	/* Store state in digest */
	encode(_state, _digest, 16);
	
	/* Restore current state and count. */
	memcpy(_state, oldState, 16);
	memcpy(_count, oldCount, 8);
}

/* MD5 basic transformation. Transforms _state based on block. */
void transform(const byte block[64]) {
	
	uint32 a = _state[0], b = _state[1], c = _state[2], d = _state[3], x[16];
	
	decode(block, x, 64);
	
	/* Round 1 */
	FF (a, b, c, d, x[ 0], S11, 0xd76aa478); /* 1 */
	FF (d, a, b, c, x[ 1], S12, 0xe8c7b756); /* 2 */
	FF (c, d, a, b, x[ 2], S13, 0x242070db); /* 3 */
	FF (b, c, d, a, x[ 3], S14, 0xc1bdceee); /* 4 */
	FF (a, b, c, d, x[ 4], S11, 0xf57c0faf); /* 5 */
	FF (d, a, b, c, x[ 5], S12, 0x4787c62a); /* 6 */
	FF (c, d, a, b, x[ 6], S13, 0xa8304613); /* 7 */
	FF (b, c, d, a, x[ 7], S14, 0xfd469501); /* 8 */
	FF (a, b, c, d, x[ 8], S11, 0x698098d8); /* 9 */
	FF (d, a, b, c, x[ 9], S12, 0x8b44f7af); /* 10 */
	FF (c, d, a, b, x[10], S13, 0xffff5bb1); /* 11 */
	FF (b, c, d, a, x[11], S14, 0x895cd7be); /* 12 */
	FF (a, b, c, d, x[12], S11, 0x6b901122); /* 13 */
	FF (d, a, b, c, x[13], S12, 0xfd987193); /* 14 */
	FF (c, d, a, b, x[14], S13, 0xa679438e); /* 15 */
	FF (b, c, d, a, x[15], S14, 0x49b40821); /* 16 */
	
	/* Round 2 */
	GG (a, b, c, d, x[ 1], S21, 0xf61e2562); /* 17 */
	GG (d, a, b, c, x[ 6], S22, 0xc040b340); /* 18 */
	GG (c, d, a, b, x[11], S23, 0x265e5a51); /* 19 */
	GG (b, c, d, a, x[ 0], S24, 0xe9b6c7aa); /* 20 */
	GG (a, b, c, d, x[ 5], S21, 0xd62f105d); /* 21 */
	GG (d, a, b, c, x[10], S22, 0x2441453); /* 22 */
	GG (c, d, a, b, x[15], S23, 0xd8a1e681); /* 23 */
	GG (b, c, d, a, x[ 4], S24, 0xe7d3fbc8); /* 24 */
	GG (a, b, c, d, x[ 9], S21, 0x21e1cde6); /* 25 */
	GG (d, a, b, c, x[14], S22, 0xc33707d6); /* 26 */
	GG (c, d, a, b, x[ 3], S23, 0xf4d50d87); /* 27 */
	GG (b, c, d, a, x[ 8], S24, 0x455a14ed); /* 28 */
	GG (a, b, c, d, x[13], S21, 0xa9e3e905); /* 29 */
	GG (d, a, b, c, x[ 2], S22, 0xfcefa3f8); /* 30 */
	GG (c, d, a, b, x[ 7], S23, 0x676f02d9); /* 31 */
	GG (b, c, d, a, x[12], S24, 0x8d2a4c8a); /* 32 */
	
	/* Round 3 */
	HH (a, b, c, d, x[ 5], S31, 0xfffa3942); /* 33 */
	HH (d, a, b, c, x[ 8], S32, 0x8771f681); /* 34 */
	HH (c, d, a, b, x[11], S33, 0x6d9d6122); /* 35 */
	HH (b, c, d, a, x[14], S34, 0xfde5380c); /* 36 */
	HH (a, b, c, d, x[ 1], S31, 0xa4beea44); /* 37 */
	HH (d, a, b, c, x[ 4], S32, 0x4bdecfa9); /* 38 */
	HH (c, d, a, b, x[ 7], S33, 0xf6bb4b60); /* 39 */
	HH (b, c, d, a, x[10], S34, 0xbebfbc70); /* 40 */
	HH (a, b, c, d, x[13], S31, 0x289b7ec6); /* 41 */
	HH (d, a, b, c, x[ 0], S32, 0xeaa127fa); /* 42 */
	HH (c, d, a, b, x[ 3], S33, 0xd4ef3085); /* 43 */
	HH (b, c, d, a, x[ 6], S34, 0x4881d05); /* 44 */
	HH (a, b, c, d, x[ 9], S31, 0xd9d4d039); /* 45 */
	HH (d, a, b, c, x[12], S32, 0xe6db99e5); /* 46 */
	HH (c, d, a, b, x[15], S33, 0x1fa27cf8); /* 47 */
	HH (b, c, d, a, x[ 2], S34, 0xc4ac5665); /* 48 */
	
	/* Round 4 */
	II (a, b, c, d, x[ 0], S41, 0xf4292244); /* 49 */
	II (d, a, b, c, x[ 7], S42, 0x432aff97); /* 50 */
	II (c, d, a, b, x[14], S43, 0xab9423a7); /* 51 */
	II (b, c, d, a, x[ 5], S44, 0xfc93a039); /* 52 */
	II (a, b, c, d, x[12], S41, 0x655b59c3); /* 53 */
	II (d, a, b, c, x[ 3], S42, 0x8f0ccc92); /* 54 */
	II (c, d, a, b, x[10], S43, 0xffeff47d); /* 55 */
	II (b, c, d, a, x[ 1], S44, 0x85845dd1); /* 56 */
	II (a, b, c, d, x[ 8], S41, 0x6fa87e4f); /* 57 */
	II (d, a, b, c, x[15], S42, 0xfe2ce6e0); /* 58 */
	II (c, d, a, b, x[ 6], S43, 0xa3014314); /* 59 */
	II (b, c, d, a, x[13], S44, 0x4e0811a1); /* 60 */
	II (a, b, c, d, x[ 4], S41, 0xf7537e82); /* 61 */
	II (d, a, b, c, x[11], S42, 0xbd3af235); /* 62 */
	II (c, d, a, b, x[ 2], S43, 0x2ad7d2bb); /* 63 */
	II (b, c, d, a, x[ 9], S44, 0xeb86d391); /* 64 */
	
	_state[0] += a;
	_state[1] += b;
	_state[2] += c;
	_state[3] += d;
}

/* Encodes input (ulong) into output (byte). Assumes length is
a multiple of 4.
*/
void encode(const uint32* input, byte* output, size_t length) {
	
	for (size_t i = 0, j = 0; j < length; ++i, j += 4) {
		output[j]= (byte)(input[i] & 0xff);
		output[j + 1] = (byte)((input[i] >> 8) & 0xff);
		output[j + 2] = (byte)((input[i] >> 16) & 0xff);
		output[j + 3] = (byte)((input[i] >> 24) & 0xff);
	}
}

/* Decodes input (byte) into output (ulong). Assumes length is
a multiple of 4.
*/
void decode(const byte* input, uint32* output, size_t length) {
	
	for (size_t i = 0, j = 0; j < length; ++i, j += 4) {
		output[i] = ((uint32)input[j]) | (((uint32)input[j + 1]) << 8) |
			(((uint32)input[j + 2]) << 16) | (((uint32)input[j + 3]) << 24);
	}
}

/* Convert byte array to hex string. */
string bytesToHexString(const byte* input, size_t length) {
	
	string str;
	str.reserve(length << 1);
	for (size_t i = 0; i < length; ++i) {
		int t = input[i];
		int a = t / 16;
		int b = t % 16;
		str.append(1, HEX[a]);
		str.append(1, HEX[b]);
	}
	return str;
}
		reset();
		update(ifstream(%%1));
		string str=bytesToHexString(digest(), 16);

100.复制一个目录下所有文件到一个文件夹中

101.移动一个目录下所有文件到一个文件夹中

102.文件RSA高级加密
//rsa算法
/*------------------------------------------------vlong.h----------------------------------------------------*/
//长整数类，可随意定义其长度
class vlong       
{
public:
  // 重载常用算术运算符
  friend vlong operator +( const vlong& x, const vlong& y );
  friend vlong operator -( const vlong& x, const vlong& y );
  friend vlong operator *( const vlong& x, const vlong& y );
  friend vlong operator /( const vlong& x, const vlong& y );
  friend vlong operator %( const vlong& x, const vlong& y );
  vlong& operator +=( const vlong& x );
  vlong& operator -=( const vlong& x );
  // 重载常用比较运算符
  friend inline int operator !=( const vlong& x, const vlong& y ){ return x.cf( y ) != 0; }
  friend inline int operator ==( const vlong& x, const vlong& y ){ return x.cf( y ) == 0; }
  friend inline int operator >=( const vlong& x, const vlong& y ){ return x.cf( y ) >= 0; }
  friend inline int operator <=( const vlong& x, const vlong& y ){ return x.cf( y ) <= 0; }
  friend inline int operator > ( const vlong& x, const vlong& y ){ return x.cf( y ) > 0; }
  friend inline int operator < ( const vlong& x, const vlong& y ){ return x.cf( y ) < 0; }
  // 构造函数
  vlong ( unsigned x=0 );
  vlong ( const vlong& x );
  // 析构函数
  ~vlong();
 // 转换操作符
  operator unsigned ();
  vlong& operator =(const vlong& x);
private:
  class vlong_value * value;
  int negative;
  int cf( const vlong x ) const;
  void docopy();
  friend class monty;
};
vlong modexp( const vlong & x, const vlong & e, const vlong & m ); // m必须为质数
vlong gcd( const vlong &X, const vlong &Y ); // 求最大因子
vlong modinv( const vlong &a, const vlong &m ); //Euclid算法
 
/*-----------------------------------------------RSA.h--------------------------------------------------*/
#include "vlong.h"
class public_key
{
  public:
  vlong m,e;
  vlong encrypt( const vlong& plain ); // Requires 0 <= plain < m
};
class private_key : public public_key
{
  public:
  vlong p,q;
  vlong decrypt( const vlong& cipher );
  void create( const char * r1, const char * r2 );
  // r1 和 r2 为以null结尾的字符串，长度约为35个字符（以保证n约为500位模块）
};
//将以0结尾的字符串转化为长整数
static vlong from_str( const char * s )
{
  vlong x = 0;
  while (*s)
  {
    x = x * vlong(256) + (vlong)(unsigned char)*s;
    s += 1;
  }
  return x;
}
/*---------------------------------------------vlong.cpp*---------------------------------------------------------*/
#include "vlong.h"
class vlong_value;
/*-------------------------------以下为flex_unit类定义与实现----------------------------*/
//flex_unit类：提供存储分配与索引检查的类
class flex_unit          
{
  unsigned * a;          //内存unsigned int单元数组
  unsigned z;          //分配单元数
public:
  unsigned n;          //已使用的单元数(只读属性)
  flex_unit();
  ~flex_unit();
  void clear();           //已使用单元数n清0
  unsigned get( unsigned i ) const;    //获取第i个单元值
  void set( unsigned i, unsigned x );     //设置第i个单元值
  void reserve( unsigned x );          //扩展存储区
  //有时间要求的乘法
  void fast_mul( flex_unit &x, flex_unit &y, unsigned n );
};
//按索引获取单元值
unsigned flex_unit::get( unsigned i ) const
{
  if ( i >= n ) return 0;
  return a[i];
}
//清空
void flex_unit::clear()
{
   n = 0;
}
//构造函数
flex_unit::flex_unit()
{
  z = 0;
  a = 0;
  n = 0;
}
//析构函数
flex_unit::~flex_unit()
{
  unsigned i=z;
  while (i) 
  {
    i-=1; 
     a[i] = 0; 
  }
  delete [] a;
}
//改变大数尺寸
void flex_unit::reserve( unsigned x )
{
  if (x > z)
  {
    unsigned * na = new unsigned[x];
    for (unsigned i=0;i<n;i+=1) na[i] = a[i];
    delete [] a;
    a = na;
    z = x;
  }
}
//根据索引设置元素值
void flex_unit::set( unsigned i, unsigned x )
{
  if ( i < n )
  {
    a[i] = x;
    if (x==0) 
    while (n && a[n-1]==0)      //去除高位0
    n-=1;     
  }
  else if ( x )
  {
    reserve(i+1);
    for (unsigned j=n;j<i;j+=1) a[j] = 0;
    a[i] = x;
    n = i+1;
  }
}
#define BPU ( 8*sizeof(unsigned) )    //unsigned int类型bit数
#define lo(x) ( (x) & ((1<<(BPU/2))-1) )   //unsigned int低半部分
#define hi(x) ( (x) >> (BPU/2) )      //unsigned int高半部分
#define lh(x) ( (x) << (BPU/2) )           //使低半部分左移至高半部分
//快速乘法
void flex_unit::fast_mul( flex_unit &x, flex_unit &y, unsigned keep )
{
  // *this = (x*y) % (2**keep)
  unsigned i,limit = (keep+BPU-1)/BPU;  //运算结果单元数
  reserve(limit); 
  for (i=0; i<limit; i+=1) 
     a[i] = 0;
  unsigned min = x.n; 
  if (min>limit) 
     min = limit;
  for (i=0; i<min; i+=1)
  {
    unsigned m = x.a[i];
    unsigned c = 0; 
    unsigned min = i+y.n; 
    if (min>limit) min = limit;
    for ( unsigned j=i; j<min; j+=1 )
    {
      //此处代码为运算关键，可使用机器或汇编代码以加快速度
      // c:a[j] = a[j] + c + m*y.a[j-i];
      unsigned w, v = a[j], p = y.a[j-i];
      v += c; c = ( v < c );
      w = lo(p)*lo(m); v += w; c += ( v < w );
      w = lo(p)*hi(m); c += hi(w); w = lh(w); v += w; c += ( v < w );
      w = hi(p)*lo(m); c += hi(w); w = lh(w); v += w; c += ( v < w );
      c += hi(p) * hi(m);
      a[j] = v;
    }
    while ( c && j<limit )
    {
      a[j] += c;
      c = a[j] < c;
      j += 1;
    }
  }
  //去除不必要的bit
  keep %= BPU; 
  if (keep)
    a[limit-1] &= (1<<keep)-1;
   //计算使用单元数
  while (limit && a[limit-1]==0) 
     limit-=1;
  n = limit;
};
/*---------------------------------以上为flex_unit类定义与实现----------------------------*/

/*-------------------------------以下为vlong_value类定义与实现----------------------------*/
class vlong_value : public flex_unit  //继承自flex_unit，负责vlong类内存管理
{
  public:
  unsigned share;        
  int is_zero() const;
  int test( unsigned i ) const;
  unsigned bits() const;
  int cf( vlong_value& x ) const;
  void shl();
  void shr();
  void shr( unsigned n );
  void add( vlong_value& x );
  void subtract( vlong_value& x );
  void init( unsigned x );
  void copy( vlong_value& x );
  operator unsigned();       //转换至unsigned int类型，不安全
  vlong_value();
  void mul( vlong_value& x, vlong_value& y );
  void divide( vlong_value& x, vlong_value& y, vlong_value& rem );
};

// 将大数转换为无符号整数
vlong_value::operator unsigned()
{
  return get(0);
}
// 测试大数是否为0
int vlong_value::is_zero() const
{
  return n==0;
}
//测试第i位（bit）值是否为0
int vlong_value::test( unsigned i ) const
{ 
   return ( get(i/BPU) & (1<<(i%BPU)) ) != 0; 
}
//获取大数位（bit）数
unsigned vlong_value::bits() const
{
  unsigned x = n*BPU;
  while (x && test(x-1)==0) x -= 1;
  return x;
}
//比较两个大数值大小
int vlong_value::cf( vlong_value& x ) const
{
  if ( n > x.n ) return +1;
  if ( n < x.n ) return -1;
  unsigned i = n;
  while (i)
  {
    i -= 1;
    if ( get(i) > x.get(i) ) return +1;
    if ( get(i) < x.get(i) ) return -1;
  }
  return 0;
}
//按位左移
void vlong_value::shl()
{
  unsigned carry = 0;
  unsigned N = n;
  for (unsigned i=0;i<=N;i+=1)
  {
    unsigned u = get(i);
    set(i,(u<<1)+carry);
    carry = u>>(BPU-1);
  }
}
//按位右移
void vlong_value::shr()
{
  unsigned carry = 0;
  unsigned i=n;
  while (i)
  {
    i -= 1;
    unsigned u = get(i);
    set(i,(u>>1)+carry);
    carry = u<<(BPU-1);
  }
}
//左移x位
void vlong_value::shr( unsigned x )
{
  unsigned delta = x/BPU; 
x %= BPU;
  for (unsigned i=0;i<n;i+=1)
  {
    unsigned u = get(i+delta);
    if (x)
    {
      u >>= x;
      u += get(i+delta+1) << (BPU-x);
    }
    set(i,u);
  }
}
//大数加法
void vlong_value::add( vlong_value & x )
{
  unsigned carry = 0;
  unsigned max = n; if (max<x.n) max = x.n;
  reserve(max);
  for (unsigned i=0;i<max+1;i+=1)
  {
    unsigned u = get(i);
    u = u + carry; carry = ( u < carry );
    unsigned ux = x.get(i);
    u = u + ux; carry += ( u < ux );
    set(i,u);
  }
}
//大数减法
void vlong_value::subtract( vlong_value & x )
{
  unsigned carry = 0;
  unsigned N = n;
  for (unsigned i=0;i<N;i+=1)
  {
    unsigned ux = x.get(i);
    ux += carry;
    if ( ux >= carry )
    {
      unsigned u = get(i);
      unsigned nu = u - ux;
      carry = nu > u;
      set(i,nu);
    }
  }
}
//使用无符号整数x初始化大数
void vlong_value::init( unsigned x )
{
  clear();
  set(0,x);
}
//将参数x（大数类型）值赋给本实例
void vlong_value::copy( vlong_value& x )
{
  clear();
  unsigned i=x.n;
  while (i) { i -= 1; set( i, x.get(i) ); }
}
  
vlong_value::vlong_value()
{
  share = 0;
}
//大数乘法
void vlong_value::mul( vlong_value& x, vlong_value& y )
{
  fast_mul( x, y, x.bits()+y.bits() );
}
//大数除法
void vlong_value::divide( vlong_value& x, vlong_value& y, vlong_value& rem )
{
  init(0);
  rem.copy(x);
  vlong_value m,s;
  m.copy(y);
  s.init(1);
  while ( rem.cf(m) > 0 )
  {
    m.shl();
    s.shl();
  }
  while ( rem.cf(y) >= 0 )
  {
    while ( rem.cf(m) < 0 )
    {
      m.shr();
      s.shr();
    }
    rem.subtract( m );
    add( s );
  }
}
/*---------------------以上为vlong_value类定义与实现---------------------------*/

/*-----------------------------------以下为vlong类实现-------------------------------*/
void vlong::docopy()
{
  if ( value->share )
  {
    value->share -= 1;
    vlong_value * nv = new vlong_value;
    nv->copy(*value);
    value = nv;
  }
}
//大数比较
int vlong::cf( const vlong x ) const
{
  int neg = negative && !value->is_zero();
  if ( neg == (x.negative && !x.value->is_zero()) )
    return value->cf( *x.value );
  else if ( neg ) return -1;
  else return +1;
}
//构造函数
vlong::vlong (unsigned x)
{
  value = new vlong_value;
  negative = 0;
  value->init(x);
}
//复制构造函数
vlong::vlong ( const vlong& x ) 
{
  negative = x.negative;
  value = x.value;
  value->share += 1;
}
//赋值函数
vlong& vlong::operator =(const vlong& x)
{
  if ( value->share ) value->share -=1; else delete value;
  value = x.value;
  value->share += 1;
  negative = x.negative;
  return *this;
}
//析构函数
vlong::~vlong()
{
  if ( value->share ) value->share -=1; else delete value;
}
//unsigned转换符，将大数转换为无符号整数
vlong::operator unsigned () // conversion to unsigned
{
  return *value;
}
//重载+=运算符
vlong& vlong::operator +=(const vlong& x)
{
  if ( negative == x.negative )
  {
    docopy();
    value->add( *x.value );
  }
  else if ( value->cf( *x.value ) >= 0 )
  {
    docopy();
    value->subtract( *x.value );
  }
  else
  {
    vlong tmp = *this;
    *this = x;
    *this += tmp;
  }
  return *this;
}
//重载-=运算符
vlong& vlong::operator -=(const vlong& x)
{
  if ( negative != x.negative )
  {
    docopy();
    value->add( *x.value );
  }
  else if ( value->cf( *x.value ) >= 0 )
  {
    docopy();
    value->subtract( *x.value );
  }
  else
  {
    vlong tmp = *this;
    *this = x;
    *this -= tmp;
    negative = 1 - negative;
  }
  return *this;
}
//重载 + 运算符，大数加法
vlong operator +( const vlong& x, const vlong& y )
{
  vlong result = x;
  result += y;
  return result;
}
//重载 - 运算符，大数减法
vlong operator -( const vlong& x, const vlong& y )
{
  vlong result = x;
  result -= y;
  return result;
}
//重载 * 运算符，大数乘法
vlong operator *( const vlong& x, const vlong& y )
{
  vlong result;
  result.value->mul( *x.value, *y.value );
  result.negative = x.negative ^ y.negative;
  return result;
}
//重载 / 运算符，大数除法
vlong operator /( const vlong& x, const vlong& y )
{
  vlong result;
  vlong_value rem;
  result.value->divide( *x.value, *y.value, rem );
  result.negative = x.negative ^ y.negative;
  return result;
}
//重载 % 运算符，大数求模
vlong operator %( const vlong& x, const vlong& y )
{
  vlong result;
  vlong_value divide;
  divide.divide( *x.value, *y.value, *result.value );
  result.negative = x.negative; 
  return result;
}
//辗转相除求最大因子
vlong gcd( const vlong &X, const vlong &Y )
{
  vlong x=X, y=Y;
  while (1)
  {
    if ( y == (vlong)0 ) return x;
    x = x % y;
    if ( x == (vlong)0 ) return y;
    y = y % x;
  }
}
//密钥产生流程最后一步，Euclid 算法
// 返回在1到m-1之间的长整数i,使i*a = 1 mod m
// a必须为在1到m-1之间的长整数
vlong modinv( const vlong &a, const vlong &m ) 
{
  vlong j=1,i=0,b=m,c=a,x,y;
  while ( c != (vlong)0 )
  {
    x = b / c;
    y = b - x*c;
    b = c;
    c = y;
    y = j;
    j = i - j*x;
    i = y;
  }
  if ( i < (vlong)0 )
    i += m;
  return i;
}
/*-----------------------------------以下为vlong类实现-------------------------------*/

/*--------------------------以下为monty类定义与实现-------------------------------*/
//monty：求模与幂的相关类，主要用于分块加密与解密
//加密： = ^e ( mod n )
//解密： = ^d ( mod n )  
class monty   
{
  vlong R,R1,m,n1;
  vlong T,k;     //工作寄存器
  unsigned N;    //R的位（bit）数
  void mul( vlong &x, const vlong &y );
public:
  vlong exp( const vlong &x, const vlong &e );
  monty( const vlong &M );
};
//赋M为默认除数，即加/解密式中的n
monty::monty( const vlong &M )
{
  m = M;
  N = 0; 
  R = 1; 
  while ( R < M ) 
  { 
     R += R; 
     N += 1; 
  }
  R1 = modinv( R-m, m );
  n1 = R - modinv( m, R );
}
void monty::mul( vlong &x, const vlong &y )
{
  // T = x*y;
  T.value->fast_mul( *x.value, *y.value, N*2 );
  // k = ( T * n1 ) % R;
  k.value->fast_mul( *T.value, *n1.value, N );
  // x = ( T + k*m ) / R;
  x.value->fast_mul( *k.value, *m.value, N*2 );
  x += T;
  x.value->shr( N );
  if (x>=m) x -= m;
}
//返回值= (x^e)%(this->m)
vlong monty::exp( const vlong &x, const vlong &e )
{
  vlong result = R-m;
vlong t = ( x * R ) % m;
  unsigned bits = e.value->bits();
  unsigned i = 0;
  while (1)
  {
    if ( e.value->test(i) )
      mul( result, t);
    i += 1;
    if ( i == bits ) break;
    mul( t, t );
  }
  return ( result * R1 ) % m;
}
//返回值= (x^e)%m
vlong modexp( const vlong & x, const vlong & e, const vlong & m )
{
  monty me(m);
  return me.exp( x,e );
}

/*-----------------------------------------------RSA.cpp-----------------------------------------------*/
#include "rsa.h"
/*---------------------以下为prime_factory类定义与实现-------------------*/
//prime_factory：用于产生质数
class prime_factory
{
  unsigned np;
  unsigned *pl;
  public:
  prime_factory();
  ~prime_factory();
  vlong find_prime( vlong & start );
};
//判定是否有很大概率为质数
static int is_probable_prime( const vlong &p )
{
  //基于费马小定理：若p是任一质数, a 是任一整数, 则 a^p = 1 mod p 。换句话说, 
  //如果 a 和 p 互质, 则 a^(p-1) == 1 mod p。将{2,3,5,7}值分别代入a,若上式均成立，
  //则p为质数的概率极大
  const rep = 4;
  const unsigned any[rep] = { 2,3,5,7 };
  for ( unsigned i=0; i<rep; i+=1 )
    if ( modexp( any[i], p-(vlong)1, p ) != (vlong)1 )
      return 0;
  return 1;
}
//构造小质数表
prime_factory::prime_factory()
{
  np = 0;
  unsigned NP = 200;
  pl = new unsigned[NP];
  //初始化质数表
  unsigned SS = 8*NP;     //粗略估计质数表上限
  char * b = new char[SS+1];
  for (unsigned i=0;i<=SS;i+=1) 
  b[i] = 1;
  unsigned p = 2;
  while (1)
  {
    // skip composites
    while ( b[p] == 0 ) p += 1;
    if ( p == SS ) break;
    pl[np] = p;
    np += 1;
    if ( np == NP ) break;
    // cross off multiples
    unsigned c = p*2;
    while ( c < SS )
    {
      b[c] = 0;
      c += p;
    }
    p += 1;
  }
  delete [] b;
}
//析构函数
prime_factory::~prime_factory()
{
  delete [] pl;
}

//寻找第一个>=start的质数
vlong prime_factory::find_prime( vlong & start )
{
  unsigned SS = 1000;      //1000通常已足够
  char * b = new char[SS];     //后备质数检验位，若SS[i]=0，则不需要用
            //费马小定理（is_probable_prime）检验start+i,因为它
            //必非质数
  unsigned tested = 0;      //使用is_probable_prime函数检验过的后备质数次数
  while (1)
  {
    unsigned i;
    for (i=0;i<SS;i+=1)
      b[i] = 1;
    for (i=0;i<np;i+=1)
    {
      unsigned p = pl[i];
      unsigned r = start % (vlong)p;  //取模运算较慢，此处可专门设计函数做取模计算
      if (r) 
    r = p - r;
      // 去除所有能被p除尽的后备质数
      while ( r < SS )
      {
        b[r] = 0;
        r += p;
      }
    }
    // 检验后备质数
    for (i=0;i<SS;i+=1)
    {
      if ( b[i] )
      {
        tested += 1;
        if ( is_probable_prime(start) )
          return start;
      }
      start += 1;
    }
  }
  delete [] b;
}
//由字符串r1和r2创建p、q和公钥
void private_key::create( const char * r1, const char * r2 )
{
  // 由r1和r2产生质数p、q
  {
    prime_factory pf;
    p = pf.find_prime( from_str(r1) );
    q = pf.find_prime( from_str(r2) );
    if ( p > q ) 
    {
       vlong tmp = p; 
       p = q; 
       q = tmp; 
    }
  }
  // 计算公钥
  //从[0，（p-1）（q-1）-1]中随机选取加密密钥e，使得e和（p-1）（q-1）互质。此处
  //为使e较大，直接从一较大数开始选取（50001）
  {
    m = p*q;
    e = 50001;       //必须为奇数，因p-1，q-1均为偶数
    while ( gcd(p-(vlong)1,e) != (vlong)1 || gcd(q-(vlong)1,e) != (vlong)1 ) 
    e += 2;
  }
}
//加密明文
vlong public_key::encrypt( const vlong& plain )
{
  return modexp( plain, e, m );
}
//解密秘文
vlong private_key::decrypt( const vlong& cipher )
{
  // Calculate values for performing decryption
  // These could be cached, but the calculation is quite fast
  vlong d = modinv( e, (p-(vlong)1)*(q-(vlong)1) );
  vlong u = modinv( p, q );
  vlong dp = d % (p-(vlong)1);
  vlong dq = d % (q-(vlong)1);
  // 应用同余定理
  vlong a = modexp( cipher % p, dp, p );
  vlong b = modexp( cipher % q, dq, q );
  if ( b < a ) b += q;
  return a + p * ( ((b-a)*u) % q );
}
//rsa类简单使用实例
#include "rsa.h"
#include <iostream>
using namespace std;
main()
{
  private_key pkey;
  pkey.create("abcdefgaaaaaaaaaaaaaaaaaa","deeeeeeeeeeeeeeeefffffffff");
  vlong m;
  m=from_str("abbbbccc");
  pkey.encrypt(m);
  
  cout<<"ok";
  pkey.decrypt(m);
  
}

103.计算文件大小
/*
#include <stdio.h>
#include <sys\stat.h>
#include <fcntl.h>
#include <io.h>
#include <string.h>
#define KB 1024;
#define MB (1024*KB);
#define GB (1024*MB);
*/
int handle=open(%%1,O_RDWR);
long fileSize=filelength(handle);
close(handle);
char[] showsize;
if(fileSize>=GB)
sprinf(showsize,"%0.2f GB",(double)fileSize/GB);
else if(fileSize>=MB)
sprinf(showsize,"%0.2f MB",(double)fileSize/MB);
else if(fileSize>=KB)
sprinf(showsize,"%0.2f KB",(double)fileSize/KB);
else if(fileSize>1)
sprinf(showsize,"%ld Bytes",fileSize);
else
showsize="1 Byte";
　　strcpy(%%2,showsize);

104.计算文件夹的大小
/*
#include <windows.h>
#include <stdio.h>
*/
DWORD64 GetFolderSize(LPCTSTR szPath, DWORD *dwFiles, DWORD *dwFolders)
{
 TCHAR szFileFilter[512];
 TCHAR szFilePath[512];
 HANDLE hFind = NULL;
 WIN32_FIND_DATA fileinfo;
 DWORD64    dwSize = 0;

 strcpy(szFilePath,szPath);
 strcat(szFilePath,"\\");
 strcpy(szFileFilter,szFilePath);
 strcat(szFileFilter,"*.*");

 hFind = FindFirstFile(szFileFilter,&fileinfo);
 do
 {
  if(fileinfo.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
  {
   if (!strcmp(fileinfo.cFileName,".") || !strcmp(fileinfo.cFileName,".."))
   {
    //Do nothing for "." and ".." folders
   }
   else
   {
    TCHAR sztmp[512];
    strcpy(sztmp,szFilePath);
    strcat(sztmp,fileinfo.cFileName);
    dwSize = dwSize + GetFolderSize(sztmp,dwFiles,dwFolders);
    if(dwFolders != NULL)
    {
     ++(*dwFolders);
    }
   }
  }
  else
  {
   if(dwFiles != NULL)
   {
    ++(*dwFiles);
   }
  }

  dwSize += fileinfo.nFileSizeLow;

 }while(FindNextFile(hFind,&fileinfo));

 FindClose(hFind);
 return dwSize;
}

105.快速获得当前程序的驱动器、路径、文件名和扩展名
/*
#include <stdlib.h>
#include <direct.h>
*/
char path_buffer[_MAX_PATH];
char drive[_MAX_DRIVE];
char dir[_MAX_DIR];
char fname[_MAX_FNAME];
char ext[_MAX_EXT];
if(getcwd(path_buffer,_MAX_PATH))
_splitpath(path_buffer,drive,dir,fname,ext);

106.磁盘剩余空间计算
/*
#include <windows.h>
#include <string.h>
*/
ULARGE_INTEGER nFreeBytesAvailable,nTotalNumberOfBytes,nTotalNumberOfFreeBytes;
if (GetDiskFreeSpaceEx(%%1,&nFreeBytesAvailable,&nTotalNumberOfBytes,&nTotalNumberOfFreeBytes)) //"C:"
     {
        TCHAR chBuf[256];
       wsprintf(chBuf,"Av=%I64d,Total=%I64d,Free=%I64d\r\n",
              nFreeBytesAvailable,
              nTotalNumberOfBytes,
             nTotalNumberOfFreeBytes);
    //strcpy(%%2,chBuf);
    }

107.获取当前程序进程ID

108.全盘搜索文件

109.获得当前登录的用户名

110.获得所有用户名

111.创建MySQL管理用户
system("mysqladmin -u root password "+%%1);

112.管理MySQL数据库服务器
112.1.启动MySQL数据库服务器
system("mysqld -console");

112.2.登录MySQL数据库服务器
112.2.1.登录本地MySQL数据库服务器
system("mysql -uroot -p"+%%1);

112.2.2.登录远程MySQL数据库服务器
system("mysql -h "+%%1+" -u "+%%2+" -p"+%%3);

112.3.关闭MySQL数据库服务器
system("mysqladmin -u root shutdown");

112.4.测试MySQL数据库服务器
system("mysqlshow");

system("mysqlshow -u root mysql");

system("mysqladmin version status");

system("mysql test");

113.MySQL执行查询
system("mysqladmin -u %%1 -p%%2 SELECT * INTO OUTFILE ‘./bestlovesky.xls‘ FROM bestlovesky WHERE 1 ORDER BY id DESC  LIMIT 0, 50;");

system("mysql -u %%1 -p%%2 -e \"SELECT * INTO OUTFILE ‘./bestlovesky.xls‘ FROM bestlovesky WHERE 1 ORDER BY id DESC  LIMIT 0, 50;\"");

114.创建Oracle管理用户
114.1.创建新用户
create user test identified by test default tablespace ts_test temporary
tablespace temp;

114.2.给用户角色特权
system("grant connect,resource to test;");

115.登录Oracle数据库
sqlplusw
sqlplus /nolog
conn username/password@Oranet
conn system/systempwd@whfc
conn sys/syspwd@whfc as sysdba

115.创建Oracle表空间
conn system@whfc01
create tablespace ts_test datafile '/data2/oradata/ciis/ts_test01.dbf' size

116.添加Oracle数据文件
alter tablespace ts_test add datafile '/data2/oradata/ciis/ts_test02.dbf' size

117.查看Oracle表空间大小
system("desc DBA_DATA_FILES");

118.查看Oracle剩余表空间大小
system("desc DBA_FREE_SPACE");

119.查看Oracle当前用户表名
select * from tab;

120.Oracle创建索引
CREATE INDEX idx_book_bookid ON book(bookname);

121.Oracle创建主键约束
ALTER TABLE book ADD CONSTRAINT pk_book_bookid PRIMARY KEY (bookid);

122.Oracle显示表结构
desc book

123.Oracle查看表的索引
column index_name format a30
select table_name, index_name from user_indexes;

124.Oracle查看索引列
select table_name, index_name, column_name, column_position from user_ind_columns;

125.Oracle查看数据段占空间大小
desc user_segments

126.Oracle查看表占空间大小
select segment_name,segment_type,bytes from user_segments where segment_type='TABLE';

127.安全删除USB
system("rundll32.exe shell32.dll,Control_RunDLL hotplug.dll");

128.打开SQL Server Management Studio
//#include<string.h>
char strcmd[MAX_PATH]="sqlwb ";
strcpy(strcmd,%%1);
strcpy(strcmd,".sql");
system(strcmd);

129.MySQL数据库导出备份
//#include<string.h>
char strcmd[MAX_PATH]="mysqldump -u ";
strcpy(strcmd,%%1);
strcpy(strcmd," -p ");
strcpy(strcmd,%%2);
strcpy(strcmd," ");
strcpy(strcmd,%%3);
strcpy(strcmd,">");
strcpy(strcmd,%%4);
strcpy(strcmd,".sql");
system(strcmd);

130.MySQL数据库数据导入
//#include<string.h>
char strcmd[MAX_PATH]="mysql -u ";
strcpy(strcmd,%%1);
strcpy(strcmd," -p ");
strcpy(strcmd,%%2);
strcpy(strcmd," ");
strcpy(strcmd,%%3);
strcpy(strcmd,"<");
strcpy(strcmd,%%4);
strcpy(strcmd,".sql");
system(strcmd);

131.MySQL数据库检查
//#include<string.h>
char strcmd[MAX_PATH]="mysqlcheck -o ";
strcpy(strcmd,%%3);
strcpy(strcmd," -u ");
strcpy(strcmd,%%1);
strcpy(strcmd," -p ");
strcpy(strcmd,%%2);
system(strcmd);

132.MySQL数据表文件修复
//#include<string.h>
char strcmd[MAX_PATH]="myisamchk -B -o ";
strcpy(strcmd,%%1);
strcpy(strcmd,".myd");
system(strcmd);

133.检查端口占用
system("netstat -ano");

134.Linux下检查Apache是否安装
//#include <stdio.h>
system("rpm -qa | grep httpd");

135.Linux下启动Apache服务
//#include <stdio.h>
system("service httpd start");

136.Linux下停止Apache服务
//#include <stdio.h>
system("service httpd stop");

137.Linux下重新启动Apache服务
//#include <stdio.h>
system("service httpd restart");

138.Linux下自动加载Apache 服务
//#include <stdio.h>
system("chkconfig - level 3 httpd on");

139.Linux下不自动加载Apache 服务
//#include <stdio.h>
system("chkconfig - level 3 httpd off");

140.Linux下检查VSFTP是否安装
//#include <stdio.h>
system("rpm -qa | grep vsftpd");

141.Linux下启动VSFTP服务
//#include <stdio.h>
system("service vsftpd start");

142.Linux下停止VSFTP服务
//#include <stdio.h>
system("service vsftpd stop");

143.Linux下重新启动VSFTP服务
//#include <stdio.h>
system("service vsftpd restart");

144.Linux下检查VSFTP是否被启动
//#include <stdio.h>
system("pstree | grep vsftpd");

145.Linux下检查Sendmail是否安装
//#include <stdio.h>
system("rpm -qa | grep sendmail");

146.Linux下启动Sendmail服务
//#include <stdio.h>
system("service sendmail start");

147.Linux下停止Sendmail服务
//#include <stdio.h>
system("service sendma stop");

148.Linux下重新启动Sendmail服务
//#include <stdio.h>
system("service sendmail restart");

149.Linux下自动加载Sendmail 服务
//#include <stdio.h>
system("chkconfig - level 3 sendmail on");

150.Linux下不自动加载Sendmail 服务
//#include <stdio.h>
system("chkconfig - level 3 sendmail off");

151.Linux下文本图形界面配置启动服务
//#include <stdio.h>
system("ntsysv\r\n");

152.以数组的方式删除文件夹
/*
#include <stdio.h>
#include <direct.h>
#include <string.h>
*/
char const *deldir[]={
%%1,
%%2,
NULL};
char const **kwp;
for(kwp=deldir;*kwp!=NULL;kwp++)
{
if(rmdir(*kwp)==-1)
{
printf("目录%s删除失败!\n",*kwp);
}
}

153.GCC批量编译
/*
#include <stdio.h>
#include <sys/types.h>
#include <dirent.h>
#include <sys/stat.h>
#include <string.h>
*/
char *c="c";
char *cpp="cpp";
char *dot=".";
char retname[256];
char *getfilename(char *fullname)
{
	bzero(retname,256);
	char *q=rindex(fullname,'.');
	strncpy(retname,fullname,q-fullname);
	retname[q-fullname]='\0';
	return retname;
}
void CompileAll(char *path)
{
	DIR *dir;
	char fullpath[1024],currfile[1024];
	struct dirent *s_dir;
	struct stat file_stat;
	strcpy(fullpath,path);
	dir=opendir(fullpath);
	while((s_dir=readdir(dir))!=NULL)
	{
		if(s_dir->d_name[0]=='.')
			continue;
		sprintf(currfile,"%s/%s",fullpath,s_dir->d_name);
		stat(currfile,&file_stat);
		if(S_ISDIR(file_stat.st_mode))
			CompileAll(currfile);
		else if(strstr(currfile+2,dot))
		{
			char gcc[512]="gcc \"";
			char o[256]=" -o \"";
			char *p=currfile;
			while(*p)p++;
			while(p>currfile && *p!='.')p--;
			if (p!=currfile)p++;
			strcat(strcat(gcc,currfile),"\"");
			strcat(strcat(o,getfilename(currfile)),"\"");
			if((p-currfile+1==strlen(currfile) && strncmp(p,c,1)==0) || (p-currfile+3==strlen(currfile) && strncmp(p,cpp,3)==0))
			{
				sprintf(currfile,"%s%s",gcc,o);
				system(currfile);
			}
		}
	}
	closedir(dir);
}
CompileAll(dot);

154.批量赋予可执行权限
/*
#include <stdio.h>
#include <sys/types.h>
#include <dirent.h>
#include <sys/stat.h>
#include <string.h>
*/
char *sh="sh";
char *pl="pl";
char *rb="rb";
char *py="py";
char *run="run";
char *bin="bin";
char *dot=".";
char *bundle="bundle";
char retname[256];
char* getfilename(char *fullname)
{
	bzero(retname,256);
	char *q=rindex(fullname,'.');
	strncpy(retname,fullname,q-fullname);
	retname[q-fullname]='\0';
	return retname;
}
void RightAll(char *path)
{
	DIR *dir;
	char fullpath[1024],currfile[1024];
	struct dirent *s_dir;
	struct stat file_stat;
	strcpy(fullpath,path);
	dir=opendir(fullpath);
	while((s_dir=readdir(dir))!=NULL)
	{
		if(s_dir->d_name[0]=='.')
			continue;
		sprintf(currfile,"%s/%s",fullpath,s_dir->d_name);
		stat(currfile,&file_stat);
		if(S_ISDIR(file_stat.st_mode))
			RightAll(currfile);
		else if(strstr(currfile+2,dot))
		{
			char chmodx[256]="chmod +x \"";
			char *p=currfile;
			while(*p)p++;
			while(p>currfile && *p!='.')p--;
			if (p!=currfile)p++;
			if((p-currfile+2==strlen(currfile) && (strncmp(p,sh,2)==0 || strncmp(p,pl,2)==0) || strncmp(p,rb,2)==0) || strncmp(p,py,2)==0)) || (p-currfile+3==strlen(currfile) && (strncmp(p,bin,3)==0 || strncmp(p,run,3)==0)) || (p-currfile+6==strlen(currfile) && strncmp(p,bundle,6)==0))
				system(strcat(strcat(chmodx,currfile),"\""));
		}
	}
	closedir(dir);
}
RightAll(dot);

155.批量执行
/*
#include <stdio.h>
#include <sys/types.h>
#include <dirent.h>
#include <sys/stat.h>
#include <string.h>
*/
char *sh="sh";
char *run="run";
char *pl="pl";
char *rb="rb";
char *py="py";
char *bin="bin";
char *rpm="rpm";
char *jar="jar";
char *class1="class";
char *bundle="bundle";
char *dot=".";
char retname[256];
char* getfilename(char *fullname)
{
	bzero(retname,256);
	char *q=rindex(fullname,'.');  //从p中找到.出现的位置，此后q=".bin"
	strncpy(retname,fullname,q-fullname); //把p与q之间的字符复制给s,此后s="234"
	retname[q-fullname]='\0'; //在s数字字符串的末尾加上null
	return retname;
}
void ExecuteAll(char *path)
{
	DIR *dir;
	char fullpath[1024],currfile[1024];
	struct dirent *s_dir;
	struct stat file_stat;
	strcpy(fullpath,path);
	dir=opendir(fullpath);
	while((s_dir=readdir(dir))!=NULL)
	{
		if(s_dir->d_name[0]=='.')
			continue;
		sprintf(currfile,"%s/%s",fullpath,s_dir->d_name);
		stat(currfile,&file_stat);
		if(S_ISDIR(file_stat.st_mode))
			ExecuteAll(currfile);
		else if(strstr(currfile+2,dot))
		{
			char xterm[256]="xterm -e ";
			char *p=currfile;
			while(*p)p++;
			while(p>currfile && *p!='.')p--;
			if (p!=currfile)p++;
			if(p-currfile+2==strlen(currfile) && strncmp(p,sh,2)==0)
				system(strcat(strcat(strcat(xterm,"bash \""),currfile),"\""));
			else if((p-currfile+3==strlen(currfile) && (strncmp(p,bin,3)==0 || strncmp(p,run,3)==0)) || (p-currfile+6==strlen(currfile) && strncmp(p,bundle,6)==0))
				system(strcat(strcat(strcat(xterm,"\""),currfile),"\""));
			else if(p-currfile+2==strlen(currfile) && strncmp(p,rb,2)==0)
				system(strcat(strcat(strcat(xterm,"ruby \""),currfile),"\""));
			else if(p-currfile+2==strlen(currfile) && strncmp(p,pl,2)==0)
				system(strcat(strcat(strcat(xterm,"perl \""),currfile),"\""));
			else if(p-currfile+2==strlen(currfile) && strncmp(p,py,2)==0)
				system(strcat(strcat(strcat(xterm,"python \""),currfile),"\""));
			else if(p-currfile+5==strlen(currfile) && strncmp(p,class1,5)==0 && !strstr(currfile,"$"))
				system(strcat(strcat(strcat(xterm,"java \""),getfilename(currfile+2)),"\""));
			else if(p-currfile+3==strlen(currfile) && strncmp(p,rpm,3)==0)
				system(strcat(strcat(strcat(xterm,"rpm -ivh \""),currfile),"\""));
			else if(p-currfile+3==strlen(currfile) && strncmp(p,jar,3)==0)
				system(strcat(strcat(strcat(xterm,"java -jar \""),currfile),"\""));
		}
	}
	closedir(dir);
}
ExecuteAll(dot);

156.获取操作系统版本
/*
#include <windows.h>
typedef DWORD(CALLBACK* LPREGISTERSERVICEPROCESS)(DWORD,DWORD);
*/
if(GetVersion() >= 0x80000000)
{
　　HINSTANCE hDLL= LoadLibrary("KERNEL32");
　　//加载RegisterServiceProcess（）函数所在的动态链接库KERNEL32.DLL
　　LPREGISTERSERVICEPROCESS lpRegisterServiceProcess=(LPREGISTERSERVICEPROCESS)GetProcAddress(hDLL,"RegisterServiceProcess");
　　//得到RegisterServiceProcess （）函数的地址
　　lpRegisterServiceProcess(GetCurrentProcessId(),1); 
　　FreeLibrary(hDLL);
}

157.自身复制
/*
#include <string>
#include <windows.h>
#include <tchar.h>
using namespace std;
*/
TCHAR appName[MAX_PATH];
TCHAR sysPath[MAX_PATH];
GetSystemDirectory(sysPath ,MAX_PATH);
GetModuleFileName(NULL,appName,MAX_PATH);
string systemPath(sysPath);
systemPath+='\\';
size_t i=systemPath.rfind(sep,systemPath.length());
char* filename=NULL;
if(i!=string::npos)
{
filename=s.substr(i+1,systemPath.length()-i);
systemPath+=filename;
CopyFile(appName,systemPath.c_str(),true);
}

删除自身

#include <windows.h>
#include <tlhelp32.h>
#include <iostream>

__declspec(naked) DWORD WINAPI Start_(LPVOID lpThreadParameter)
{	
	__asm 
	{	  
		call    $+5
		sub     [esp],5                 ; // _code_start_		   	
		mov     ebp,[esp+8]             ; // hHandle
		push    [ebp-4]
		push    INFINITE				
		push    [ebp-4]					

		call    [ebp-8]		            ; // WaitForSingleObject
		call    [ebp-12]	            ; // CloseHandle

		push    ebp					    ; // lpFileName
		call    [ebp-16]	            ; // DeleteFileA           

		pop     eax
		push    EXIT_SUCCESS          
		sub     esp,4                   ; // nothing

		push    MEM_RELEASE				
		push    0  
		push    eax                     ; // _code_start_   

		push    [ebp-20]	            ; // ExitThread
		mov     eax,[ebp-24]
		jmp     eax			            ; // VirtualFree  		
	}
}

BYTE code[] ={
	232,0,0,0,0,128,44,36,5,139,108,36,8,255,117,
	252,106,255,255,117,252,255,85,248,255,85,244,
	85,255,85,240,88,106,0,131,236,4,104,0,
	128,0,0,106,0,80,255,117,236,139,69,232,255,224
};
#include <iostream>
void DeleteMe()
{
	HANDLE hToken;
	TOKEN_PRIVILEGES tp;
	ZeroMemory(&tp,sizeof tp);
	HANDLE hProcess = GetCurrentProcess();

	OpenProcessToken(hProcess, TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,&hToken);
	LookupPrivilegeValue(NULL, SE_DEBUG_NAME, &tp.Privileges[0].Luid);

	tp.PrivilegeCount = 1;
	tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

	AdjustTokenPrivileges(hToken, FALSE, &tp, sizeof(TOKEN_PRIVILEGES),NULL,NULL);
	CloseHandle(hToken);

	///////////////////////////////////////////////////////////////////////

	CHAR szFileName[MAX_PATH] = {'\0'};
	GetModuleFileNameA(NULL, szFileName, MAX_PATH);

	DWORD  dwProcessID   = 0;
	PROCESSENTRY32W pe32 = { sizeof( PROCESSENTRY32W ) };
	HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
	Process32FirstW(hSnapshot, &pe32);
	do
	{
		if (0 == lstrcmpiW(pe32.szExeFile, L"winlogon.exe"))
		{
			dwProcessID = pe32.th32ProcessID;
			break;
		}
	} while (Process32NextW(hSnapshot, &pe32));

	CloseHandle(hSnapshot);

	//////////////////////////////////////////////////////////////////////

	HANDLE hTargetProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE,dwProcessID);
	HANDLE h= NULL;
	DuplicateHandle(hProcess,hProcess,hTargetProcess,&h,0,FALSE,DUPLICATE_SAME_ACCESS);
	const SIZE_T dwSize = 4096;
	const DWORD codeLen = dwSize - MAX_PATH - sizeof(HANDLE);


	PBYTE lpRemoteBuf = (PBYTE)VirtualAllocEx(hTargetProcess, NULL, dwSize, MEM_COMMIT, PAGE_EXECUTE_READWRITE);
	PBYTE pLocalBuf =(PBYTE)VirtualAlloc(NULL, dwSize, MEM_COMMIT, PAGE_EXECUTE_READWRITE);

	HMODULE x =GetModuleHandleA("kernel32") ;
	memcpy(pLocalBuf,code,codeLen);
	*(PHANDLE(pLocalBuf+codeLen)) = h;
	*((FARPROC*)(pLocalBuf+codeLen- 4))  =GetProcAddress(x,"WaitForSingleObject");
	*((FARPROC*)(pLocalBuf+codeLen- 8))  =GetProcAddress(x,"CloseHandle");
	*((FARPROC*)(pLocalBuf+codeLen-12))  =GetProcAddress(x,"DeleteFileA");
	*((FARPROC*)(pLocalBuf+codeLen-16))  =GetProcAddress(x,"ExitThread");
	*((FARPROC*)(pLocalBuf+codeLen-20))  =GetProcAddress(x,"VirtualFree");
	memcpy(pLocalBuf+codeLen+4,szFileName,MAX_PATH);
	WriteProcessMemory(hTargetProcess, lpRemoteBuf, pLocalBuf,dwSize,0);
	VirtualFree(pLocalBuf, 0, MEM_RELEASE);

	HANDLE hThread = CreateRemoteThread(hTargetProcess, NULL, 0,
		(LPTHREAD_START_ROUTINE)lpRemoteBuf,
		(LPVOID)(lpRemoteBuf + codeLen + sizeof(HANDLE) ),0,0);

	CloseHandle(hThread);
	CloseHandle(hTargetProcess);

} 


int main()
{
	DeleteMe();
}

158.GCC批量创建静态库
静态函数库： 
　　这类库的名字一般是libxxx.a；利用静态函数库编译成的文件比较大，因为整个函数库的所有数据都会被整合进目标代码中，他的优点就显而易见了，即编译后的执行程序不需要外部的函数库支持，因为所有使用的函数都已经被编译进可执行文件了。当然这也会成为他的缺点，因为如果静态函数库改变了，那么你的程序必须重新编译，而且体积也较大。 

动态函数库： 
　　这类库的名字一般是libxxx.so，动态库又称共享库;相对于静态函数库，动态函数库在编译的时候并没有被编译进目标代码中，你的程序执行到相关函数时才调用该函数库里的相应函数，因此动态函数库所产生的可执行文件比较小。由于函数库没有被整合进你的程序，而是程序运行时动态的申请并调用，所以程序的运行环境中必须提供相应的库。动态函数库的改变并不影响你的程序，所以动态函数库的升级比较方便。而且如果多个应用程序都要使用同一函数库，动态库就非常适合，可以减小应用程序的体积。 

下面来介绍linux静态函数库的创建和使用： 

　　例程add.h add.c sub.h sub.c main.c: 

　　add.h 

　　#ifndef ADD_H 
　　#define ADD_H 
　　int add(int x,int y); 
　　#endif 

　　add.c 

　　#include <stdio.h> 
　　#include "add.h" 

int add(int x,int y) 
{ 
　　 return (x+y); 
} 
-------------------------------------------------------------------- 
sub.h 

　　#ifndef SUB_H 
　　#define SUB_H 
　　int sub(int x,int y); 
　　#endif 

　　sub.c 

　　#include <stdio.h> 
　　#include "sub.h" 
int sub(int x,int y) 
{ 
　　 return (x-y); 
　　} 
----------------------------------------------------------------------- 
main.c 

#include <stdio.h> 
　　#include "sub.h" 
#include "add.h" 

　　int main() 
{ 
int a,b; 
a = add(1,2); 
b = sub(10,5); 

printf(“a=%d,b=%d\n”,a,b); 
　　　　return 0; 
　　} 
----------------------------------------------------------------------- 
　　不管是静态函数库还是动态函数库，都是由*.o目标文件生成。 

所以先 gcc -c add.c 
gcc -c sub.c 
生成add.o sub.o 

　　静态函数库由ar命令创建 

　　本例：ar -cr libaddsub.a add.o sub.o 

　　-c create的意思 

　　-r replace的意思，表示当插入的模块名已经在库中存在，则替换同名的模块。如果若干模块中有一个模块在库中不存在，ar显示一个错误消息，并不替换其他同名模块。默认的情况下，新的成员增加在库的结尾处，可以使用其他任选项来改变增加的位置。 
　　到此静态函数库创建完毕。 

　　使用方法：通过gcc -o main main.c -L. -laddsub编译main.c就会把静态函数库整合进main。 

　　其中 

　　-L指定静态函数库的位置供查找，注意L后面还有'.'，表示静态函数库在本目录下查找。 

　　-l则指定了静态函数库名，由于静态函数库的命名方式是lib***.a，其中的lib和.a忽略。 

　　根据静态函数库的特性，此处删除libaddsub.a后main依然可以运行，因为静态库的内容已经整合进去了。 

　　动态函数库的创建和使用 

gcc -shared -fpic -o libaddsub.so add.c sub.c 

-fpic：产生位置无关代码 
-shared：生成共享库 

用上述命令生成libaddsub.so 动态函数库。 

　　gcc -o out main.c -L. -laddsub 

　　此时还不能立即./out，因为在动态函数库使用时，会查找/usr/lib /lib目录下的动态函数库，而此时我们生成的库不在里边。 

　　这个时候有好几种方法可以让他成功运行： 

　　最直接最简单的方法就是把libaddsub.so拉到/usr/lib 或/lib中去。 

还有一种方法,假设libaddsub.so在/home/linux/addsub 
export LD_LIBRARY_PATH=/home/linux/addsub：$LD_LIBRARY_PATH 

　　另外还可以在/etc/ld.so.conf文件里加入我们生成的库的目录，然后/sbin/ldconfig。 
/etc/ld.so.conf是非常重要的一个目录，里面存放的是链接器和加载器搜索共享库时要检查的目录，默认是从/usr/lib /lib中读取的，所以想要顺利运行，我们也可以把我们库的目录加入到这个文件中并执行/sbin/ldconfig。

159.Java批量打包EJB

160.获取环境变量

161.dd
/*
#include <ctype.h>
#include <errno.h>
#include <fcntl.h>
#include <limits.h>
#include <setjmp.h>
#include <signal.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define ARRAY_SIZE(x)   (sizeof(x) / sizeof(x[0]))

static char *progname;

struct option {
        const char *opt;
        char *str;
        char *arg;
};

struct conv {
        const char str[8];
        unsigned int set;
        unsigned int exclude;
};

#define CONV_BLOCK      (1<<0)
#define CONV_UNBLOCK    (1<<1)

#define CONV_LCASE      (1<<2)
#define CONV_UCASE      (1<<3)

#define CONV_SWAB       (1<<4)
#define CONV_NOERROR    (1<<5)
#define CONV_NOTRUNC    (1<<6)
#define CONV_SYNC       (1<<7)

static struct option options[] = {
        {"bs", NULL, NULL},
#define OPT_BS          (&options[0])
        {"cbs", NULL, NULL},
#define OPT_CBS         (&options[1])
        {"conv", NULL, NULL},
#define OPT_CONV        (&options[2])
        {"count", NULL, NULL},
#define OPT_COUNT       (&options[3])
        {"ibs", NULL, NULL},
#define OPT_IBS         (&options[4])
        {"if", NULL, NULL},
#define OPT_IF          (&options[5])
        {"obs", NULL, NULL},
#define OPT_OBS         (&options[6])
        {"of", NULL, NULL},
#define OPT_OF          (&options[7])
        {"seek", NULL, NULL},
#define OPT_SEEK        (&options[8])
        {"skip", NULL, NULL}
#define OPT_SKIP        (&options[9])
};

static const struct conv conv_opts[] = {
        {"block", CONV_BLOCK, CONV_UNBLOCK},
        {"unblock", CONV_UNBLOCK, CONV_BLOCK},
        {"lcase", CONV_LCASE, CONV_UCASE},
        {"ucase", CONV_UCASE, CONV_LCASE},
        {"swab", CONV_SWAB, 0},
        {"noerror", CONV_NOERROR, 0},
        {"notrunc", CONV_NOTRUNC, 0},
        {"sync", CONV_SYNC, 0},
};

static size_t cbs;
static unsigned int conv;
static unsigned int count;
static size_t ibs = 512;
static size_t obs = 512;
static unsigned int seek;
static unsigned int skip;
static char *in_buf;
static char *out_buf;
*/
static size_t parse_bs(struct option *opt)
{
        unsigned long val, realval = 1;
        char *str = opt->str;
        int err = 0;

        do {
                char *s = str;
                val = strtoul(str, &str, 10);
                if (s == str || (val == ULONG_MAX && errno == ERANGE)) {
                        err = 1;
                        break;
                }

                /*
                 * This option may be followed by
                 * 'b', 'k' or 'x'
                 */
                if (*str == 'b') {
                        val *= 512;
                        str++;
                } else if (*str == 'k') {
                        val *= 1024;
                        str++;
                }
                realval *= val;
                if (*str != 'x')
                        break;
                str++;
        } while (1);

        if (*str != '\0')
                err = 1;

        if (err) {
                fprintf(stderr, "%s: bad operand `%s'\n", progname, opt->arg);
                exit(1);
        }

        return (size_t) realval;
}

static unsigned int parse_num(struct option *opt)
{
        unsigned long val;
        char *str = opt->str;

        val = strtoul(str, &str, 10);
        if (str == opt->str || (val == ULONG_MAX && errno == ERANGE) ||
            val > UINT_MAX) {
                fprintf(stderr, "%s: bad operand `%s'\n", progname, opt->arg);
                exit(1);
        }

        return (unsigned int)val;
}

static int parse_options(int argc, char *argv[])
{
        unsigned int i;
        char *p, *s;
        int arg;

        /*
         * We cheat here; we don't parse the operand values
         * themselves here.  We merely split the operands
         * up.  This means that bs=foo bs=1 won't produce
         * an error.
         */
        for (arg = 1; arg < argc; arg++) {
                unsigned int len;

                s = strchr(argv[arg], '=');
                if (!s)
                        s = argv[arg];  /* don't recognise this arg */

                len = s - argv[arg];
                for (i = 0; i < ARRAY_SIZE(options); i++) {
                        if (strncmp(options[i].opt, argv[arg], len) != 0)
                                continue;

                        options[i].str = s + 1;
                        options[i].arg = argv[arg];
                        break;
                }

                if (i == ARRAY_SIZE(options)) {
                        fprintf(stderr, "%s: bad operand `%s'\n",
                                progname, argv[arg]);
                        return 1;
                }
        }

        /*
         * Translate numeric operands.
         */
        if (OPT_IBS->str)
                ibs = parse_bs(OPT_IBS);
        if (OPT_OBS->str)
                obs = parse_bs(OPT_OBS);
        if (OPT_CBS->str)
                cbs = parse_bs(OPT_CBS);
        if (OPT_COUNT->str)
                count = parse_num(OPT_COUNT);
        if (OPT_SEEK->str)
                seek = parse_num(OPT_SEEK);
        if (OPT_SKIP->str)
                skip = parse_num(OPT_SKIP);

        /*
         * If bs= is specified, it overrides ibs= and obs=
         */
        if (OPT_BS->str)
                ibs = obs = parse_bs(OPT_BS);

        /*
         * And finally conv=
         */
        if (OPT_CONV->str) {
                p = OPT_CONV->str;

                while ((s = strsep(&p, ",")) != NULL) {
                        for (i = 0; i < ARRAY_SIZE(conv_opts); i++) {
                                if (strcmp(s, conv_opts[i].str) != 0)
                                        continue;
                                conv &= ~conv_opts[i].exclude;
                                conv |= conv_opts[i].set;
                                break;
                        }

                        if (i == ARRAY_SIZE(conv_opts)) {
                                fprintf(stderr, "%s: bad conversion `%s'\n",
                                        progname, s);
                                return 1;
                        }
                }
        }

        if (conv & (CONV_BLOCK | CONV_UNBLOCK) && cbs == 0) {
                fprintf(stderr, "%s: block/unblock conversion with zero cbs\n",
                        progname);
                return 1;
        }

        return 0;
}

static int safe_read(int fd, void *buf, size_t size)
{
        int ret, count = 0;
        char *p = buf;

        while (size) {
                ret = read(fd, p, size);

                /*
                 * If we got EINTR, go again.
                 */
                if (ret == -1 && errno == EINTR)
                        continue;

                /*
                 * If we encountered an error condition
                 * or read 0 bytes (EOF) return what we
                 * have.
                 */
                if (ret == -1 || ret == 0)
                        return count ? count : ret;

                /*
                 * We read some bytes.
                 */
                count += ret;
                size -= ret;
                p += ret;
        }

        return count;
}

static int skip_blocks(int fd, void *buf, unsigned int blks, size_t size)
{
        unsigned int blk;
        int ret = 0;

        /*
         * Try to seek.
         */
        for (blk = 0; blk < blks; blk++) {
                ret = lseek(fd, size, SEEK_CUR);
                if (ret == -1)
                        break;
        }

        /*
         * If we failed to seek, read instead.
         * FIXME: we don't handle short reads here, or
         * EINTR correctly.
         */
        if (blk == 0 && ret == -1 && errno == ESPIPE) {
                for (blk = 0; blk < blks; blk++) {
                        ret = safe_read(fd, buf, size);
                        if (ret != (int)size)
                                break;
                }
        }

        if (ret == -1) {
                perror("seek/skip");
                return 1;
        }
        return 0;
}

struct stats {
        unsigned int in_full;
        unsigned int in_partial;
        unsigned int out_full;
        unsigned int out_partial;
        unsigned int truncated;
};

static int do_dd(int rd, int wr, struct stats *stats)
{
        unsigned int i;
        int ret;
        int fill_val = 0;
        size_t out_size = 0;
        size_t in_size;
        char *buf;

        if (conv & (CONV_BLOCK | CONV_UNBLOCK))
                fill_val = ' ';

        while (!OPT_COUNT->str || count-- != 0) {
                buf = in_buf;

                /*
                 * 1. read ibs-sized buffer
                 */
                in_size = ret = read(rd, in_buf, ibs);
                if (ret == -1 || (ret == 0 && (conv & CONV_NOERROR) == 0))
                        break;

                if (in_size == ibs) {
                        stats->in_full++;
                } else {
                        stats->in_partial++;

                        /*
                         * 2. zero (or append spaces)
                         */
                        if (conv & CONV_SYNC) {
                                memset(in_buf + in_size, fill_val,
                                       ibs - in_size);
                                in_size = ibs;
                        }
                }

                /*
                 * 4. swab conversion.  With an odd number of bytes,
                 * last byte does not get swapped.
                 */
                if (conv & CONV_SWAB) {
                        char c;

                        for (i = 1; i < in_size; i += 2) {
                                c = in_buf[i - 1];
                                in_buf[i - 1] = in_buf[i];
                                in_buf[i] = c;
                        }
                }

                /*
                 * 5. remaining conversions.
                 */
                if (conv & CONV_LCASE)
                        for (i = 0; i < in_size; i++)
                                in_buf[i] = tolower(in_buf[i]);

                if (conv & CONV_UCASE)
                        for (i = 0; i < in_size; i++)
                                in_buf[i] = toupper(in_buf[i]);

                /* block/unblock ? */

                /*
                 * 6. Aggregate into obs sized buffers.
                 * If the in_size is obs-sized and we have no
                 * data waiting, just write "buf" to the output.
                 */
                if (out_size == 0 && in_size == obs) {
                        write(wr, buf, obs);
                        stats->out_full++;
                } else {
                        /*
                         * We had data waiting, or we didn't have an
                         * obs-sized input block.  We need to append
                         * the input data to the output buffer.
                         */
                        unsigned int space;
                        char *in_ptr = in_buf;

                        do {
                                space = obs - out_size;
                                if (space > in_size)
                                        space = in_size;

                                memcpy(out_buf + out_size, in_ptr, space);
                                out_size += space;
                                in_size -= space;
                                in_ptr += space;

                                if (out_size == obs) {
                                        write(wr, out_buf, obs);
                                        stats->out_full++;
                                        out_size = 0;
                                }
                        } while (out_size == 0 && in_size);

                        if (in_size) {
                                memcpy(out_buf, in_ptr, in_size);
                                out_size = in_size;
                        }
                }
        }

        if (out_size) {
                write(wr, out_buf, out_size);
                stats->out_partial++;
        }

        return 0;
}

static sigjmp_buf jmp;

static void sigint_handler(int sig)
{
        siglongjmp(jmp, -sig);
}

static int dd(int rd_fd, int wr_fd, struct stats *stats)
{
        int ret;

        ret = sigsetjmp(jmp, 1);
        if (ret == 0) {
                sysv_signal(SIGINT, sigint_handler);
                ret = do_dd(rd_fd, wr_fd, stats);
        }

        sysv_signal(SIGINT, SIG_DFL);
        return ret;
}

int main(int argc, char *argv[])
{
        struct stats stats;
        int ret;
        int rd_fd = 0, wr_fd = 1;

        progname = argv[0];

        ret = parse_options(argc, argv);
        if (ret)
                return ret;

        if (conv & (CONV_BLOCK | CONV_UNBLOCK)) {
                fprintf(stderr, "%s: block/unblock not implemented\n",
                        progname);
                return 1;
        }

        in_buf = malloc(ibs);
        if (!in_buf) {
                perror("malloc ibs");
                return 1;
        }

        out_buf = malloc(obs);
        if (!out_buf) {
                perror("malloc obs");
                return 1;
        }

        /*
         * Open the input file, if specified.
         */
        if (OPT_IF->str) {
                rd_fd = open(OPT_IF->str, O_RDONLY);
                if (rd_fd == -1) {
                        perror("open input file");
                        return 1;
                }
        }

        /*
         * Open the output file, if specified.
         */
        if (OPT_OF->str) {
                int flags = O_WRONLY|O_CREAT;
                flags |= (conv & CONV_NOTRUNC) ? 0 : O_TRUNC;
                wr_fd = open(OPT_OF->str, flags, 0666);
                if (wr_fd == -1) {
                        perror("open output file");
                        return 1;
                }
        }

        /*
         * Skip obs-sized blocks of output file.
         */
        if (OPT_SEEK->str && skip_blocks(wr_fd, out_buf, seek, obs))
                return 1;

        /*
         * Skip ibs-sized blocks of input file.
         */
        if (OPT_SKIP->str && skip_blocks(rd_fd, in_buf, skip, ibs))
                return 1;

        memset(&stats, 0, sizeof(stats));

        /*
         * Do the real work
         */
        ret = dd(rd_fd, wr_fd, &stats);

        if (close(rd_fd) == -1)
                perror(OPT_IF->str ? OPT_IF->str : "stdin");
        if (close(wr_fd) == -1)
                perror(OPT_OF->str ? OPT_OF->str : "stdout");

        fprintf(stderr, "%u+%u records in\n", stats.in_full, stats.in_partial);
        fprintf(stderr, "%u+%u records out\n",
                stats.out_full, stats.out_partial);
        if (stats.truncated)
                fprintf(stderr, "%u truncated record%s\n",
                        stats.truncated, stats.truncated == 1 ? "" : "s");

        /*
         * ret will be -SIGINT if we got a SIGINT.  Raise
         * the signal again to cause us to terminate with
         * SIGINT status.
         */
        if (ret == -SIGINT)
                raise(SIGINT);

        return ret;
}

162.显示只有小写字母的文件
163.Zip压缩目录中的所有文件
164.Zip解压缩目录中的所有文件

165.分布式复制文件夹

166.注册反注册组件
//#include <stdio.h>
char fullpath[1024]="C:\\Windows\\system\\regsvr32.exe ";
system(strcat(fullpath,%%1));

167.LZMA

168.CAB压缩文件

169.CAB解压缩文件

170.锁定屏幕
//#include <stdio.h>
system("C:\\Windows\\system\\rundll32.exe USER32,LockWorkStation");

171.以其它用户的身份运行程序

172.添加系统用户

173.删除系统用户

174.添加用户组

175.删除用户组

176.赋予管理员权限

177.收回管理员权限

178.遍历目录产生删除文件的脚本

179.LZW压缩文件
#include <iostream> 
#include <sstream> 
#include <string> 
#include <map> 
#include <vector> 
#include <set> 
using namespace std; 
 
 vector<size_t> compress(string& sin) 
{ 
    istringstream in(sin); 
     
    // initialize the table, add all visible ascii char into the dictionary 
    map<string, int> dic; 
    for(char c=32;c<=126;c++) 
        dic[string(1,c)]=dic.size(); 
 
     vector<size_t> ret; 
 
     // do the encoding 
    string w; 
    for(char c=in.get(); c!=EOF; c=in.get()) 
    { 
        string wc=w+c; 
 
         if(dic.find(wc)!=dic.end()) 
            w=wc; 
        else 
        { 
            dic[wc]=dic.size(); 
            ret.push_back(dic[w]); 
            w=c; 
        } 
    } 
    ret.push_back(dic[w]); 
    return ret; 
} 
 
 string decompress(vector<size_t>& data) 
{ 
    // the dictionary, a aditional set is used to test whether a word is already in the dictionary
     vector<string> dic; 
    set<string> dic_set; 
 
     // initialize the dictionary 
    for(char c=32; c<=126;c++) 
    { 
        dic.push_back(string(1, c)); 
        dic_set.insert(string(1,c)); 
    } 
 
     // decode 
    string w, ret; 
    for(size_t i=0;i<data.size();i++) 
    { 
        size_t code=data[i]; 
 
         // please refer to: http://www.cis.udel.edu/~amer/CISC651/lzw.and.gif.explained.html
         string en = code>=dic.size() ? w+w[0] : dic[code]; 
 
         ret+=en; 
 
         string nw=w+en[0]; 
        if(dic_set.find(nw)==dic_set.end()) 
        { 
            dic.push_back(nw); 
            dic_set.insert(nw); 
        } 
        w=en; 
    } 
    return ret; 
} 
 
 int main() 
{ 
    //string s("ToBeOrNotToBe"); 
    string s("aaaaaffffffffffffffffffffffffffffffaaaafafafafaaaa"); 
    vector<size_t> ret=compress(s); 
    string s2=decompress(ret); 
}

180.LZW解压缩文件
#include <iostream> 
#include <sstream> 
#include <string> 
#include <map> 
#include <vector> 
#include <set> 
using namespace std; 
 
 vector<size_t> compress(string& sin) 
{ 
    istringstream in(sin); 
     
    // initialize the table, add all visible ascii char into the dictionary 
    map<string, int> dic; 
    for(char c=32;c<=126;c++) 
        dic[string(1,c)]=dic.size(); 
 
     vector<size_t> ret; 
 
     // do the encoding 
    string w; 
    for(char c=in.get(); c!=EOF; c=in.get()) 
    { 
        string wc=w+c; 
 
         if(dic.find(wc)!=dic.end()) 
            w=wc; 
        else 
        { 
            dic[wc]=dic.size(); 
            ret.push_back(dic[w]); 
            w=c; 
        } 
    } 
    ret.push_back(dic[w]); 
    return ret; 
} 
 
 string decompress(vector<size_t>& data) 
{ 
    // the dictionary, a aditional set is used to test whether a word is already in the dictionary
     vector<string> dic; 
    set<string> dic_set; 
 
     // initialize the dictionary 
    for(char c=32; c<=126;c++) 
    { 
        dic.push_back(string(1, c)); 
        dic_set.insert(string(1,c)); 
    } 
 
     // decode 
    string w, ret; 
    for(size_t i=0;i<data.size();i++) 
    { 
        size_t code=data[i]; 
 
         // please refer to: http://www.cis.udel.edu/~amer/CISC651/lzw.and.gif.explained.html
         string en = code>=dic.size() ? w+w[0] : dic[code]; 
 
         ret+=en; 
 
         string nw=w+en[0]; 
        if(dic_set.find(nw)==dic_set.end()) 
        { 
            dic.push_back(nw); 
            dic_set.insert(nw); 
        } 
        w=en; 
    } 
    return ret; 
} 
 
 int main() 
{ 
    //string s("ToBeOrNotToBe"); 
    string s("aaaaaffffffffffffffffffffffffffffffaaaafafafafaaaa"); 
    vector<size_t> ret=compress(s); 
    string s2=decompress(ret); 
}

181.递归赋予目录权限

182.卸载RPM包

183.删除源文件中的注释
/*
#include<string>
#include<fstream>
#include <stdio.h>
*/
const int Normal = 0;
const int String = 1;
const int AlmostComment = 2;
const int AlmostNormal = 3;
const int SigleLineComment = 4;
const int MultiLineComment = 5;

bool deleteComments(std::string& inputFileName,
                    std::string& outputFileName,
                    std::string& docFileName)
{
    std::ifstream inFile = std::ifstream(inputFileName.c_str(),std::ios::in|std::ios::binary);
    std::ofstream outFile = std::ofstream(outputFileName.c_str(),std::ios::out|std::ios::binary);
    std::ofstream docFile = std::ofstream(docFileName.c_str(),std::ios::out|std::ios::binary);
    if(!inFile.is_open() || !outFile.is_open() || !docFile.is_open() )  return false;
    char c[1];
    int status = Normal;
    while(true)
    {
        inFile.read(c,1);
        if(inFile.gcount() == 0) break;
        switch(status)
        {
        case Normal:
            if(c[0]=='/')  status  = AlmostComment;
            if(c[0]=='"') status  = String;
            if(c[0]!='/') outFile.write(c,1);
            break;
        case String:
            if(c[0]=='"') status = Normal;
            outFile.write(c,1);
            break;
        case AlmostComment:
            if(c[0]=='/') status = SigleLineComment;
            else if(c[0]=='*') status = MultiLineComment;
            else  status = Normal;
            if(c[0]!='/' && c[0]!='*') outFile.write(c,1);
            break;
        case AlmostNormal:
            if(c[0]=='/') status = Normal;
            else if(c[0]=='*') status = AlmostNormal;
            else status = MultiLineComment;
            if(c[0]!='/' && c[0]!='*')outFile.write(c,1);
            break;
        case SigleLineComment:
			//这里的按windows的行结束符处理,apple与unix请适当更改
            if(c[0]=='\r')
            {
                outFile.write(c,1);
                inFile.read(c,1);
                outFile.write(c,1);
                status = Normal;
            }
            else docFile.write(c,1);
            break;
        case MultiLineComment:
            if(c[0]=='*') status = AlmostNormal;
            docFile.write(c,1);
            break;
        }
    }
    inFile.close();
    outFile.close();
    docFile.close();
    return true;
}
    std::string inputFileName(%%1);
    std::string outputFileName(%%2);
    std::string docFileName(%%3);
    if(deleteComments(inputFileName,outputFileName,docFileName))
        printf("操作成功 %s -> %s %s",inputFileName.c_str(),outputFileName.c_str(),docFileName.c_str());

184.设置目录下所有文件属性为可写
/*
#include <stdio.h>
#include <sys/types.h>
#include <dirent.h>
#include <sys/stat.h>
#include <string.h>
#include <conio.h>
#include <io.h>
*/
char *dot=".";
char retname[256];

char* getfilename(char *fullname)
{
	bzero(retname,256);
	char *q=rindex(fullname,'.');
	strncpy(retname,fullname,q-fullname);
	retname[q-fullname]='\0';
	return retname;
}
void WriteAll(char *path)
{
	DIR *dir;
	char fullpath[1024],currfile[1024];
	struct dirent *s_dir;
	struct stat file_stat;
	strcpy(fullpath,path);
	dir=opendir(fullpath);
	while((s_dir=readdir(dir))!=NULL)
	{
		if(s_dir->d_name[0]=='.')
			continue;
		sprintf(currfile,"%s/%s",fullpath,s_dir->d_name);
		stat(currfile,&file_stat);
		if(S_ISDIR(file_stat.st_mode))
			WriteAll(currfile);
		else if(strstr(currfile+2,dot) && chmod(currfile,S_IWRITE)==-1)
			printf("%s cannot be set as writeable.",currfile);
	}
	closedir(dir);
}
WriteAll(dot);

185.统计目录下所有文件的总共行数

186.删除自身

187.打开终端
//#include <stdio.h>
system("xterm");

188.弹出光驱
/*
#include <unistd.h>
#include <stdlib.h>
#include <fcntl.h>
#include <sys/ioctl.h>
#include <linux/cdrom.h>
*/
#define DEVICE "/dev/cdrom"
int fd = open(DEVICE, O_RDONLY|O_NONBLOCK);
  if (fd < 0) {
    perror("unable to open "DEVICE);
    exit(1);
  }
  if (ioctl(fd, CDROMEJECT) != 0) {
    perror("CDROMEJECT ioctl failed");
    exit(1);
  }
  if (close(fd) != 0) {
    perror("unable to close "DEVICE);
    exit(1);
  }

189.收回光驱
/*
#include <unistd.h>
#include <stdlib.h>
#include <fcntl.h>
#include <sys/ioctl.h>
#include <linux/cdrom.h>
*/
#define DEVICE "/dev/cdrom"
int fd = open(DEVICE, O_RDONLY|O_NONBLOCK);
  if (fd < 0) {
    perror("unable to open "DEVICE);
    exit(1);
  }
  if (ioctl(fd, CDROMCLOSETRAY,0) != 0) {
    perror("CDROMCLOSETRAY ioctl failed");
    exit(1);
  }
  if (close(fd) != 0) {
    perror("unable to close "DEVICE);
    exit(1);
  }

190.磁盘总空间计算
/*
#include   <stdio.h> 
#include   <stdlib.h> 
#include   <unistd.h> 
#include   <sys/statfs.h> 
*/
int  i; 
struct statfs disk_statfs; 
printf( "%d   %d   %d\n ",   sizeof(disk_statfs),   sizeof(disk_statfs.f_blocks),   
sizeof(disk_statfs.f_ffree),   sizeof(disk_statfs.f_fsid)); 

//   printf( "Get:   %d\n ",   statfs( "/dev/hda2 ",   &disk_statfs)); 
printf( "Get:   %d\n ",   statfs( "/ ",   &disk_statfs)); 

printf( "f_type:   %d\n ",   disk_statfs.f_type); 
printf( "f_bsize:   %d\n ",   disk_statfs.f_bsize); //   每块的大小(字节数)   bytes 
printf( "f_blocks:   %d\n ",   disk_statfs.f_blocks); 
printf( "f_bfree:   %d\n ",   disk_statfs.f_bfree); 
printf( "f_bavail:   %d\n ",   disk_statfs.f_bavail); //   可用的块数   allbytes   =   f_bavail*f_bsize 
printf( "f_files:   %d\n ",   disk_statfs.f_files); 
printf( "f_ffree:   %d\n ",   disk_statfs.f_ffree); 

/*   printf( "f_fsid:   %d\n ",   disk_statfs.f_fsid); 
printf( "f_namelen:   %d\n ",   disk_statfs.f_namelen); 
for(i=0;   i <6;   i++) 
printf( "f_spare[%d]:   %d\n ",   i+1,   disk_statfs.f_spare[i]);     */ 

191.解析CSV文件

192.按行保存文件为数组

193.MySQL执行SQL文件
mysqladmin -u %%1 -p%%2 < %%3.sql

mysql -u %%1 -p%%2 -e "SOURCE %%3.sql"