/*
 * char.c - A simple example character device.
 *
 * Copyright (C) 2006 Jon Masters <jcm@jonmasters.org>
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 */

#include <linux/init.h>
#include <linux/fs.h>
#include <linux/major.h>
#include <linux/blkdev.h>
#include <linux/module.h>
#include <linux/cdev.h>

#include <asm/uaccess.h>

/* function prototypes */

static int char_open(struct inode *inode, struct file *file);
static int char_release(struct inode *inode, struct file *file);
static ssize_t char_read(struct file *file, char __user *buf,
			 size_t count, loff_t *ppos);

/* global variables */

static struct class *plp_class;     /* pretend /sys/class */
static dev_t char_dev;              /* dynamically assigned at registration. */
static struct cdev *char_cdev;      /* dynamically allocated at runtime. */

/* file_operations */

static struct file_operations char_fops = {
	.read    = char_read,
	.open    = char_open,
	.release = char_release,
	.owner   = THIS_MODULE,
};

/*
 * char_open: open the phony char device
 * @inode: the inode of the /dev/char device
 * @file: the in-kernel representation of this opened device
 * Description: This function just logs that the device got
 *              opened. In a real device driver, it would also
 *              handle setting up the hardware for access.
 */

static int char_open(struct inode *inode, struct file *file)
{
	printk(KERN_INFO "char: device file opened.\n");
	return 0;
}

/*
 * char_release: close (release) the phony char device
 * @inode: the inode of the /dev/char device
 * @file: the in-kernel representation of this opened device
 * Description: This function just logs that the device got
 * closed. In a real device driver, it would also handle
 * freeing up any previously used hardware resources.
 */


static int char_release(struct inode *inode, struct file *file)
{
	printk(KERN_INFO "char: device file released.\n");
	return 0;
}

/*
 * char_read: read the phony char device
 * @file: the in-kernel representation of this opened device
 * @buf: the userspace buffer to write into
 * @count: how many bytes to write
 * @ppos: the current file position.
 * Description: This function always returns "hello world"
 * into a userspace buffer (buf). The file position is
 * non-meaningful in this example. In a real driver, you
 * would read from the device and write into the buffer.
 */


static ssize_t char_read(struct file *file, char __user *buf,
			 size_t count, loff_t *ppos)
{
	char payload[] = "hello, world!\n";
	
	ssize_t payload_size = strlen(payload);

	if (count < payload_size)
		return -EFAULT;
	
	if (copy_to_user((void __user *)buf, &payload, payload_size))
		return -EFAULT;

	*ppos += payload_size;
	return payload_size;

}

/*
 * char_init: initialize the phony device
 * Description: This function allocates a few resources (a cdev,
 * a device, a sysfs class...) in order to register a new device
 * and populate an entry in sysfs that udev can use to setup a
 * new /dev/char entry for reading from the fake device.
 */


static int __init char_init(void)
{
	if (alloc_chrdev_region(&char_dev, 0, 1, "char"))
		goto error;

	if (0 == (char_cdev = cdev_alloc()))
		goto error;
	
	kobject_set_name(&char_cdev->kobj,"char_cdev");
	char_cdev->ops = &char_fops; /* wire up file ops */
	if (cdev_add(char_cdev, char_dev, 1)) {
		kobject_put(&char_cdev->kobj);
		unregister_chrdev_region(char_dev, 1);
		goto error;
	}

	plp_class = class_create(THIS_MODULE, "plp");
	if (IS_ERR(plp_class)) {
		printk(KERN_ERR "Error creating PLP class.\n");
		cdev_del(char_cdev);
		unregister_chrdev_region(char_dev, 1);
		goto error;
	}
    /*class_device_create(plp_class, NULL, char_dev, NULL, "char");*/
	device_create(plp_class, NULL, char_dev, NULL, "char");

	return 0;
	
	
error:
	printk(KERN_ERR "char: could not register device.\n");
	return 1;
}

/*
 * char_exit: uninitialize the phony device
 * Description: This function frees up any resource that got allocated
 * at init time and prepares for the driver to be unloaded.
 */


static void __exit char_exit(void)
{
	device_destroy(plp_class, char_dev);
	class_destroy(plp_class);
	cdev_del(char_cdev);
	unregister_chrdev_region(char_dev,1);
}

/* declare init/exit functions here */

module_init(char_init);
module_exit(char_exit);

/* define module meta data */

MODULE_AUTHOR("Jon Masters <jcm@jonmasters.org>");
MODULE_DESCRIPTION("A simple character device driver for a fake device");
MODULE_LICENSE("GPL");
