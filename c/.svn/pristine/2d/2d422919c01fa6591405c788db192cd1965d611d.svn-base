!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
ARG_MAX	getenv_saft.c	8;"	d	file:
CC	Makefile	/^CC = gcc -std=c99$/;"	m
CFLAGS	Makefile	/^CFLAGS = -g  -ansi$/;"	m
CMSG_LEN	apue.h	8;"	d
CMSG_LEN	backup/apue.h	8;"	d
Config	config.h	/^}Config, *pConfig;$/;"	t	typeref:struct:_config
Config	type.h	/^}Config, *pConfig;$/;"	t	typeref:struct:_config
DATABASE	config.h	10;"	d
DATABASE	type.h	10;"	d
DB_CFG_STR	type.h	/^static char *DB_CFG_STR[MAX_LEN] = {SERVER_HOST, DATABASE, USERNAME, PASSAWORD, PORT};$/;"	v
DB_CONFIG	config.h	/^char *DB_CONFIG[MAX_LEN] = {SERVER_HOST, DATABASE, USERNAME, PASSWORD, PORT};$/;"	v
DIR_MODE	apue.h	36;"	d
DIR_MODE	backup/apue.h	36;"	d
Data	stack.h	/^typedef int Data;$/;"	t
Data	type.h	/^typedef Property Data;$/;"	t
FILE_MODE	apue.h	31;"	d
FILE_MODE	backup/apue.h	31;"	d
FMT	listrlimit.c	4;"	d	file:
FMT	listrlimit.c	6;"	d	file:
FTW_D	traversal_dir.c	49;"	d	file:
FTW_DNR	traversal_dir.c	50;"	d	file:
FTW_F	traversal_dir.c	48;"	d	file:
FTW_NS	traversal_dir.c	51;"	d	file:
INCLUDE	Makefile	/^INCLUDE = .$/;"	m
MAXLINE	String.h	8;"	d
MAXLINE	apue.h	26;"	d
MAXLINE	backup/String.h	8;"	d
MAXLINE	backup/apue.h	26;"	d
MAXLINE	backup/file.c	7;"	d	file:
MAXLINE	file.c	7;"	d	file:
MAX_LEN	config.h	7;"	d
MAX_LEN	type.h	5;"	d
MAX_LINE	dos2unix.c	5;"	d	file:
MAX_LINE	unix2dos.c	5;"	d	file:
Malloc	backup/qyh.c	/^void * Malloc(size_t size) {$/;"	f
Malloc	qyh.c	/^void * Malloc(size_t size) {$/;"	f
Myfunc	traversal_dir.c	/^typedef int Myfunc(const char *, const struct stat *, int);$/;"	t	file:
PASSAWORD	type.h	12;"	d
PASSWORD	config.h	12;"	d
PORT	config.h	13;"	d
PORT	type.h	13;"	d
PROPERTY_NUM	type.h	7;"	d
Property	config.h	/^}Property, *pProperty;$/;"	t	typeref:struct:_property
Property	type.h	/^}Property, *pProperty;$/;"	t	typeref:struct:_property
RecvData	type.h	/^typedef Property RecvData;$/;"	t
SERVER_HOST	config.h	9;"	d
SERVER_HOST	type.h	9;"	d
SIG_ERR	apue.h	41;"	d
SIG_ERR	backup/apue.h	41;"	d
STACK_H_	stack.h	9;"	d
Set	config.h	/^}Set, *pSet;$/;"	t	typeref:struct:_set
SetData	config.h	/^typedef Property SetData;$/;"	t
Sigfunc	apue.h	/^typedef	void	Sigfunc(int);	\/* for signal handlers *\/$/;"	t
Sigfunc	backup/apue.h	/^typedef	void	Sigfunc(int);	\/* for signal handlers *\/$/;"	t
Stack	stack.h	/^}Stack, *pStack;$/;"	t	typeref:struct:_stack
String	String.h	/^}String, *pString;$/;"	t	typeref:struct:_String
String	backup/String.h	/^}String, *pString;$/;"	t	typeref:struct:_String
TELL_CHILD	apue.c	/^TELL_CHILD(pid_t pid)$/;"	f
TELL_PARENT	apue.c	/^TELL_PARENT(pid_t pid)$/;"	f
TELL_WAIT	apue.c	/^TELL_WAIT(void)$/;"	f
USERNAME	config.h	11;"	d
USERNAME	type.h	11;"	d
WAIT_CHILD	apue.c	/^WAIT_CHILD(void)$/;"	f
WAIT_PARENT	apue.c	/^WAIT_PARENT(void)$/;"	f
_APUE_H	apue.h	4;"	d
_APUE_H	backup/apue.h	4;"	d
_CONFIG_H_	config.h	2;"	d
_DATA_TYPE	stack.h	15;"	d
_DATA_TYPE	type.h	28;"	d
_LOG_TO_STDERR_	log_to_stderr.h	2;"	d
_QYH_LIB_	backup/qyh_string.h	2;"	d
_QYH_LIB_	qyh_string.h	2;"	d
_STRING_H___	String.h	2;"	d
_STRING_H___	backup/String.h	2;"	d
_String	String.h	/^typedef struct _String{$/;"	s
_String	backup/String.h	/^typedef struct _String{$/;"	s
_TYPE_H	type.h	2;"	d
_XOPEN_SOURCE	apue.h	10;"	d
_XOPEN_SOURCE	apue.h	7;"	d
_XOPEN_SOURCE	backup/apue.h	10;"	d
_XOPEN_SOURCE	backup/apue.h	7;"	d
__QYH__H_	backup/qyh.h	2;"	d
__QYH__H_	qyh.h	2;"	d
_config	config.h	/^typedef struct _config{$/;"	s
_config	type.h	/^typedef struct _config{$/;"	s
_property	config.h	/^typedef struct _property{$/;"	s
_property	type.h	/^typedef struct _property{$/;"	s
_qyh_file__	backup/file.h	2;"	d
_qyh_file__	file.h	2;"	d
_set	config.h	/^typedef struct _set{$/;"	s
_stack	stack.h	/^typedef struct _stack{$/;"	s
buf	fork.c	/^char    buf[] = "a write to stdout\\n";$/;"	v
capacity	String.h	/^    size_t capacity;$/;"	m	struct:_String
capacity	backup/String.h	/^    size_t capacity;$/;"	m	struct:_String
capacity	config.h	/^	size_t capacity;$/;"	m	struct:_set
capacity	stack.h	/^	size_t capacity;	\/* the capacity of stack *\/$/;"	m	struct:_stack
charatatime	tell_wait.c	/^charatatime(char *str)$/;"	f	file:
chars	String.h	/^typedef pString  chars;$/;"	t
chars	backup/String.h	/^typedef pString  chars;$/;"	t
chars_append	String.c	/^int chars_append(chars p, const char * s) {$/;"	f
chars_append	backup/String.c	/^int chars_append(chars p, const char * s) {$/;"	f
chars_cpy	String.c	/^int chars_cpy(chars p, const char *s) {$/;"	f
chars_cpy	backup/String.c	/^int chars_cpy(chars p, const char *s) {$/;"	f
chars_cut	String.c	/^int chars_cut(chars p, size_t begin, size_t size) {$/;"	f
chars_cut	backup/String.c	/^int chars_cut(chars p, size_t begin, size_t size) {$/;"	f
chars_fgets	String.c	/^char * chars_fgets(chars p, size_t size,  FILE *stream) {$/;"	f
chars_fgets	backup/String.c	/^char * chars_fgets(chars p, size_t size,  FILE *stream) {$/;"	f
chars_free	String.c	/^void chars_free(chars *p) {$/;"	f
chars_free	backup/String.c	/^void chars_free(chars *p) {$/;"	f
chars_init	String.c	/^void chars_init(chars *p, size_t size) {$/;"	f
chars_init	backup/String.c	/^void chars_init(chars *p, size_t size) {$/;"	f
chars_insert	String.c	/^int chars_insert(chars p, const char *str, size_t index) {$/;"	f
chars_insert	backup/String.c	/^int chars_insert(chars p, const char *str, size_t index) {$/;"	f
chars_nappend	String.c	/^int chars_nappend(chars p, const char * s, size_t size) {$/;"	f
chars_nappend	backup/String.c	/^int chars_nappend(chars p, const char * s, size_t size) {$/;"	f
chars_ncpy	String.c	/^int chars_ncpy(chars p, const char *s, size_t size) {$/;"	f
chars_ncpy	backup/String.c	/^int chars_ncpy(chars p, const char *s, size_t size) {$/;"	f
chars_ninsert	String.c	/^int chars_ninsert(chars p, const char *str, size_t index, size_t size) {$/;"	f
chars_ninsert	backup/String.c	/^int chars_ninsert(chars p, const char *str, size_t index, size_t size) {$/;"	f
chars_print	String.c	/^void chars_print(chars p) {$/;"	f
chars_print	backup/String.c	/^void chars_print(chars p) {$/;"	f
chars_reallocate	String.c	/^void chars_reallocate(chars * p, size_t size) {$/;"	f
chars_reallocate	backup/String.c	/^void chars_reallocate(chars * p, size_t size) {$/;"	f
chars_split	String.c	/^int chars_split(chars s, chars *buf, const char * separator) {$/;"	f
compare	config.c	/^int compare(const void* a, const void *b){$/;"	f
configuration	config.c	/^int configuration(Config* config, char* filename){$/;"	f
data	stack.h	/^	Data *data;			\/* the data that contained in stack *\/$/;"	m	struct:_stack
database	config.h	/^	char database[MAX_LEN];$/;"	m	struct:_config
database	type.h	/^	char database[MAX_LEN];$/;"	m	struct:_config
doit	listrlimit.c	10;"	d	file:
dopath	traversal_dir.c	/^dopath(Myfunc * func)$/;"	f	file:
dos2unix	dos2unix.c	/^int dos2unix(const char *ifile, const char * ofile) {$/;"	f
env_init	exec_test.c	/^char    *env_init[] = { "USER=unknow", "PATH=\/tmp", NULL};$/;"	v
env_mutex	getenv_saft.c	/^pthread_mutex_t env_mutex = PTHREAD_MUTEX_INITIALIZER;$/;"	v
err_doit	apue.c	/^err_doit(int errnoflag, int error, const char *fmt, va_list ap){$/;"	f	file:
err_doit	backup/apue.c	/^err_doit(int errnoflag, int error, const char *fmt, va_list ap){$/;"	f	file:
err_dump	apue.c	/^err_dump(const char *fmt, ...){$/;"	f
err_dump	backup/apue.c	/^err_dump(const char *fmt, ...){$/;"	f
err_exit	apue.c	/^err_exit(int error, const char *fmt, ...){$/;"	f
err_exit	backup/apue.c	/^err_exit(int error, const char *fmt, ...){$/;"	f
err_msg	apue.c	/^err_msg(const char *fmt, ...){$/;"	f
err_msg	backup/apue.c	/^err_msg(const char *fmt, ...){$/;"	f
err_quit	apue.c	/^err_quit(const char *fmt, ...){$/;"	f
err_quit	backup/apue.c	/^err_quit(const char *fmt, ...){$/;"	f
err_ret	apue.c	/^err_ret(const char *fmt, ...){$/;"	f
err_ret	backup/apue.c	/^err_ret(const char *fmt, ...){$/;"	f
err_sys	apue.c	/^err_sys(const char* fmt, ...){$/;"	f
err_sys	backup/apue.c	/^err_sys(const char* fmt, ...){$/;"	f
fullpath	traversal_dir.c	/^static char fullpath[PATH_MAX + 1]; \/* contains full pathname for every file *\/$/;"	v	file:
getenv	getenv_saft.c	/^getenv(const char *name)$/;"	f
getlines	backup/file.c	/^size_t getlines(FILE *stream, size_t linesize)$/;"	f
getlines	file.c	/^size_t getlines(FILE *stream, size_t linesize)$/;"	f
glob	fork.c	/^int     glob = 6;$/;"	v
glob	vfork.c	/^int     glob = 6;$/;"	v
index_of	backup/qyh_string.c	/^size_t index_of(const char* src, const char* separator){$/;"	f
index_of	qyh_string.c	/^size_t index_of(const char* src, const char* separator){$/;"	f
index_of_at	qyh_string.c	/^size_t index_of_at(const char* src, const char* separator, size_t begin) {$/;"	f
index_of_reverse	backup/qyh_string.c	/^size_t index_of_reverse(const char* src, const char* separator){$/;"	f
index_of_reverse	qyh_string.c	/^size_t index_of_reverse(const char* src, const char* separator){$/;"	f
init_done	getenv_saft.c	/^static pthread_once_t init_done = PTHREAD_ONCE_INIT;$/;"	v	file:
insert_sort	config.c	/^void insert_sort(char* src[MAX_LEN], size_t size){$/;"	f
is_read_lockable	apue.h	104;"	d
is_read_lockable	backup/apue.h	104;"	d
is_write_lockable	apue.h	106;"	d
is_write_lockable	backup/apue.h	106;"	d
j_id	read_write_lock.c	/^    pthread_t   j_id;   \/* tells which thread handles this job *\/$/;"	m	struct:job	file:
j_next	read_write_lock.c	/^    struct job *j_next;$/;"	m	struct:job	typeref:struct:job::job	file:
j_prev	read_write_lock.c	/^    struct job *j_prev;$/;"	m	struct:job	typeref:struct:job::job	file:
jmpval	setjump.c	/^jmp_buf jmpval;$/;"	v
job	read_write_lock.c	/^struct job {$/;"	s	file:
job_append	read_write_lock.c	/^job_append(struct queue *qp, struct job *jp)$/;"	f
job_find	read_write_lock.c	/^job_find(struct queue *qp, pthread_t id) $/;"	f
job_insert	read_write_lock.c	/^job_insert(struct queue *qp, struct job *jp)$/;"	f
jop_remove	read_write_lock.c	/^jop_remove(struct queue *qp, struct job *jp)$/;"	f
key	config.h	/^	char key[MAX_LEN];$/;"	m	struct:_property
key	getenv_saft.c	/^static pthread_key_t key;$/;"	v	file:
key	type.h	/^	char key[MAX_LEN];$/;"	m	struct:_property
length	String.h	/^    size_t length;$/;"	m	struct:_String
length	backup/String.h	/^    size_t length;$/;"	m	struct:_String
length	stack.h	/^	size_t length;		\/* the length of stack *\/$/;"	m	struct:_stack
lock	pthread_wait.c	/^pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;$/;"	v
log_doit	apue.c	/^log_doit(int errnoflag, int priority, const char *fmt, va_list ap){$/;"	f	file:
log_doit	backup/apue.c	/^log_doit(int errnoflag, int priority, const char *fmt, va_list ap){$/;"	f	file:
log_msg	apue.c	/^log_msg(const char *fmt, ...){$/;"	f
log_msg	backup/apue.c	/^log_msg(const char *fmt, ...){$/;"	f
log_open	apue.c	/^log_open(const char *ident, int option, int facility){$/;"	f
log_open	backup/apue.c	/^log_open(const char *ident, int option, int facility){$/;"	f
log_quit	apue.c	/^log_quit(const char *fmt, ...){$/;"	f
log_quit	backup/apue.c	/^log_quit(const char *fmt, ...){$/;"	f
log_ret	apue.c	/^log_ret(const char *fmt, ...){$/;"	f
log_ret	backup/apue.c	/^log_ret(const char *fmt, ...){$/;"	f
log_sys	apue.c	/^log_sys(const char *fmt, ...){$/;"	f
log_sys	backup/apue.c	/^log_sys(const char *fmt, ...){$/;"	f
log_to_stderr	log_to_stderr.h	/^int log_to_stderr = 0;$/;"	v
lstrip	backup/qyh_string.c	/^const char* lstrip(char* src){$/;"	f
lstrip	qyh_string.c	/^const char* lstrip(char* src){$/;"	f
main	PthreadExitCode.c	/^main(void)$/;"	f
main	String_main.c	/^int main() {$/;"	f
main	access.c	/^main(int argc, char ** argv)$/;"	f
main	alloca.c	/^main(void)$/;"	f
main	atexit.c	/^main(void)$/;"	f
main	blocksize.c	/^int main(int argc, char ** argv)$/;"	f
main	chars.c	/^main(void)$/;"	f
main	config.c	/^int main()$/;"	f
main	dos2unix.c	/^int main(int argc, char ** argv) {$/;"	f
main	exec_test.c	/^main(void)$/;"	f
main	file_test.c	/^int main(void)$/;"	f
main	fork.c	/^main(void)$/;"	f
main	getenv.c	/^main(int argc, char ** argv)$/;"	f
main	getenv_saft.c	/^int main(void)$/;"	f
main	gethostname.c	/^main(void)$/;"	f
main	listrlimit.c	/^main(void)$/;"	f
main	main.c	/^int main(int argc, char ** argv)$/;"	f
main	pr_mask.c	/^main(void)$/;"	f
main	printids.c	/^main(void)$/;"	f
main	pthread_wait.c	/^main(void)$/;"	f
main	read_data_test.c	/^int main()$/;"	f
main	read_write_lock.c	/^main(void)$/;"	f
main	realloc.c	/^main(void)$/;"	f
main	set_fl.c	/^main(int argc, char ** argv)$/;"	f
main	setenv.c	/^main(int argc, char ** argv)$/;"	f
main	setjump.c	/^main(void)$/;"	f
main	shadow.c	/^main(int argc, char *argv[])$/;"	f
main	sig_cld.c	/^int main(void)$/;"	f
main	signal.c	/^int main(void)$/;"	f
main	stat_example.c	/^main(int argc, char ** argv) $/;"	f
main	strerror.c	/^main(int argc, char ** argv)$/;"	f
main	string_test.c	/^main() {$/;"	f
main	tell_wait.c	/^main(void)$/;"	f
main	test.c	/^int main(int argc, char ** argv) {$/;"	f
main	test_bck.c	/^int main(int argc, char ** argv) {$/;"	f
main	test_exec.c	/^int main(int argc, char ** argv) {$/;"	f
main	tmpfile.c	/^main(void)$/;"	f
main	traversal_dir.c	/^int main(int argc, char *argv[])$/;"	f
main	unix2dos.c	/^int main(int argc, char ** argv) {$/;"	f
main	vfork.c	/^main(void)$/;"	f
main	waitpid.c	/^main(void)$/;"	f
mask	pthread_wait.c	/^sigset_t    mask;$/;"	v
max	apue.h	45;"	d
max	backup/apue.h	45;"	d
min	apue.h	44;"	d
min	backup/apue.h	44;"	d
my_exit1	atexit.c	/^static void my_exit1(void)$/;"	f	file:
my_exit2	atexit.c	/^static void my_exit2(void)$/;"	f	file:
myftw	traversal_dir.c	/^myftw(char *pathname, Myfunc * func)$/;"	f	file:
myfunc	traversal_dir.c	/^myfunc(const char * pathname, const struct stat * statptr, int type)$/;"	f	file:
myfunc	traversal_dir.c	/^static Myfunc   myfunc;$/;"	v	file:
nblk	traversal_dir.c	/^static long nreg, ndir, nblk, nchr, nfifo, nslink, nsock, ntot;$/;"	v	file:
nchr	traversal_dir.c	/^static long nreg, ndir, nblk, nchr, nfifo, nslink, nsock, ntot;$/;"	v	file:
ndir	traversal_dir.c	/^static long nreg, ndir, nblk, nchr, nfifo, nslink, nsock, ntot;$/;"	v	file:
newmask	apue.c	/^static sigset_t newmask, oldmask, zeromask;$/;"	v	file:
next	String.h	/^    struct _String * next;$/;"	m	struct:_String	typeref:struct:_String::_String
nfifo	traversal_dir.c	/^static long nreg, ndir, nblk, nchr, nfifo, nslink, nsock, ntot;$/;"	v	file:
nreg	traversal_dir.c	/^static long nreg, ndir, nblk, nchr, nfifo, nslink, nsock, ntot;$/;"	v	file:
nslink	traversal_dir.c	/^static long nreg, ndir, nblk, nchr, nfifo, nslink, nsock, ntot;$/;"	v	file:
nsock	traversal_dir.c	/^static long nreg, ndir, nblk, nchr, nfifo, nslink, nsock, ntot;$/;"	v	file:
ntid	printids.c	/^pthread_t ntid;$/;"	v
ntot	traversal_dir.c	/^static long nreg, ndir, nblk, nchr, nfifo, nslink, nsock, ntot;$/;"	v	file:
oldmask	apue.c	/^static sigset_t newmask, oldmask, zeromask;$/;"	v	file:
pConfig	config.h	/^}Config, *pConfig;$/;"	t	typeref:struct:_config
pConfig	type.h	/^}Config, *pConfig;$/;"	t	typeref:struct:_config
pProperty	config.h	/^}Property, *pProperty;$/;"	t	typeref:struct:_property
pProperty	type.h	/^}Property, *pProperty;$/;"	t	typeref:struct:_property
pSet	config.h	/^}Set, *pSet;$/;"	t	typeref:struct:_set
pSetData	config.h	/^typedef pProperty pSetData;$/;"	t
pStack	stack.h	/^}Stack, *pStack;$/;"	t	typeref:struct:_stack
pString	String.h	/^}String, *pString;$/;"	t	typeref:struct:_String
pString	backup/String.h	/^}String, *pString;$/;"	t	typeref:struct:_String
password	config.h	/^	char password[MAX_LEN];$/;"	m	struct:_config
password	type.h	/^	char password[MAX_LEN];$/;"	m	struct:_config
pdata	config.h	/^	SetData *pdata;$/;"	m	struct:_set
port	config.h	/^	unsigned int port;$/;"	m	struct:_config
port	type.h	/^	unsigned short int port;$/;"	m	struct:_config
pr_exit	apue.c	/^pr_exit(int status)$/;"	f
pr_exit	backup/apue.c	/^pr_exit(int status)$/;"	f
pr_limits	listrlimit.c	/^pr_limits(char *name, int resource)$/;"	f	file:
pr_mask	apue.c	/^pr_mask(const char * str)$/;"	f
pr_mask	pr_mask.c	/^pr_mask(const char * str)$/;"	f
print_stack	stack.c	/^void print_stack(pStack ptr, void (*f)(Data)){$/;"	f
printids	printids.c	/^printids(const char *s)$/;"	f
println	backup/qyh.c	/^int println(const char *fmt, ...)$/;"	f
println	qyh.c	/^int println(const char *fmt, ...)$/;"	f
q_head	read_write_lock.c	/^    struct  job         *q_head;$/;"	m	struct:queue	typeref:struct:queue::job	file:
q_lock	read_write_lock.c	/^    pthread_rwlock_t    q_lock;$/;"	m	struct:queue	file:
q_tail	read_write_lock.c	/^    struct  job         *q_tail;$/;"	m	struct:queue	typeref:struct:queue::job	file:
queue	read_write_lock.c	/^struct queue {$/;"	s	file:
queue_init	read_write_lock.c	/^queue_init(struct queue *qp)$/;"	f
quitflag	pthread_wait.c	/^int         quitflag;   \/* set nonzero by thread *\/$/;"	v
read_lock	apue.h	91;"	d
read_lock	backup/apue.h	91;"	d
readw_lock	apue.h	93;"	d
readw_lock	backup/apue.h	93;"	d
rstrip	backup/qyh_string.c	/^const char* rstrip(char* src){$/;"	f
rstrip	qyh_string.c	/^const char* rstrip(char* src){$/;"	f
s	String.h	/^    char * s;$/;"	m	struct:_String
s	backup/String.h	/^    char * s;$/;"	m	struct:_String
search_str	config.c	/^int search_str(const char**src, size_t size, const char* dest){$/;"	f
server_host	config.h	/^	char server_host[MAX_LEN];$/;"	m	struct:_config
server_host	type.h	/^	char server_host[MAX_LEN];$/;"	m	struct:_config
set_add	config.c	/^int set_add(pSet* set_ptr, Set s){$/;"	f
set_fl	set_fl.c	/^set_fl(int fd, int flags) \/* flags are file status flags to turn on *\/$/;"	f
set_init	config.c	/^int set_init(pSet *set_ptr){$/;"	f
sig_cld	sig_cld.c	/^sig_cld(int signo)$/;"	f	file:
sig_int	signal.c	/^sig_int(int signo)$/;"	f
sig_usr	apue.c	/^sig_usr(int signo)	\/* one signal handler for SIGUSR1 and SIGUSR2 *\/$/;"	f	file:
sigflag	apue.c	/^static volatile sig_atomic_t sigflag; \/* set nonzero by sig handler *\/$/;"	v	file:
signal	apue.c	/^signal(int signo, Sigfunc *func)$/;"	f
signal	backup/apue.c	/^signal(int signo, Sigfunc *func)$/;"	f
signal	signal_impl.c	/^signal(int signo, Sigfunc *func)$/;"	f
signal_intr	apue.c	/^signal_intr(int signo, Sigfunc *func)$/;"	f
signal_intr	backup/apue.c	/^signal_intr(int signo, Sigfunc *func)$/;"	f
signal_intr	signal_intr.c	/^signal_intr(int signo, Sigfunc *func)$/;"	f
size	config.h	/^	size_t size;$/;"	m	struct:_set
split	test.c	/^static int split(const char *str, char ** buf, const char *sep){$/;"	f	file:
stack_destory	stack.c	/^void stack_destory(pStack* ptr){$/;"	f
stack_init	stack.c	/^void stack_init(pStack* ptr, size_t size){$/;"	f
stack_pop	stack.c	/^Data stack_pop(pStack ptr){$/;"	f
stack_push	stack.c	/^int stack_push(pStack ptr, Data val){$/;"	f
stack_size	stack.c	/^int stack_size(pStack ptr){$/;"	f
stack_top	stack.c	/^Data stack_top(pStack ptr){$/;"	f
string_append	String.c	/^int string_append(pString *p, const char * s) {$/;"	f
string_append	backup/String.c	/^int string_append(pString *p, const char * s) {$/;"	f
string_free	String.c	/^void string_free(pString * p) {$/;"	f
string_free	backup/String.c	/^void string_free(pString * p) {$/;"	f
string_init	String.c	/^void string_init(pString * p, size_t size) {$/;"	f
string_init	backup/String.c	/^void string_init(pString * p, size_t size) {$/;"	f
string_print	String.c	/^void string_print(pString p) {$/;"	f
string_print	backup/String.c	/^void string_print(pString p) {$/;"	f
string_reallocate	String.c	/^void string_reallocate(pString * p, size_t size) {$/;"	f
string_reallocate	backup/String.c	/^void string_reallocate(pString * p, size_t size) {$/;"	f
strip	backup/qyh_string.c	/^const char* strip(char* src){$/;"	f
strip	qyh_string.c	/^const char* strip(char* src){$/;"	f
thr_fn	printids.c	/^thr_fn(void *arg)$/;"	f
thr_fn	pthread_wait.c	/^thr_fn(void *arg)$/;"	f
thr_fn1	PthreadExitCode.c	/^thr_fn1(void *arg)$/;"	f
thr_fn2	PthreadExitCode.c	/^thr_fn2(void *arg)$/;"	f
thread_init	getenv_saft.c	/^thread_init(void)$/;"	f	file:
trim	backup/qyh_string.c	/^const char* trim(char *src){$/;"	f
trim	qyh_string.c	/^const char* trim(char *src){$/;"	f
un_lock	apue.h	99;"	d
un_lock	backup/apue.h	99;"	d
unix2dos	unix2dos.c	/^int unix2dos(const char *ifile, const char * ofile) {$/;"	f
username	config.h	/^	char username[MAX_LEN];$/;"	m	struct:_config
username	type.h	/^	char username[MAX_LEN];$/;"	m	struct:_config
value	config.h	/^	char value[MAX_LEN];$/;"	m	struct:_property
value	type.h	/^	char value[MAX_LEN];$/;"	m	struct:_property
wait	pthread_wait.c	/^pthread_cond_t  wait = PTHREAD_COND_INITIALIZER;$/;"	v
write_lock	apue.h	95;"	d
write_lock	backup/apue.h	95;"	d
writew_lock	apue.h	97;"	d
writew_lock	backup/apue.h	97;"	d
zeromask	apue.c	/^static sigset_t newmask, oldmask, zeromask;$/;"	v	file:
